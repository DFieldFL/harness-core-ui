/* Generated by restful-react */

import React from 'react'
import { Get, GetProps, useGet, UseGetProps, Mutate, MutateProps, useMutate, UseMutateProps } from 'restful-react'
import { getConfig, getUsingFetch, mutateUsingFetch, GetUsingFetchProps, MutateUsingFetchProps } from '../config'

export type Omit<T, K extends keyof T> = Pick<T, Exclude<keyof T, K>>

export interface ConnectorValidationResult {
  valid?: boolean
  errorMessage?: string
  testedAt?: number
}

export interface ResponseDTO {
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
  data?: { [key: string]: any }
  metaData?: { [key: string]: any }
  correlationId?: string
}

export interface ResponseDTOConnectorValidationResult {
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
  data?: ConnectorValidationResult
  metaData?: { [key: string]: any }
  correlationId?: string
}

export interface FailureDTO {
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
  code?:
    | 'DEFAULT_ERROR_CODE'
    | 'INVALID_ARGUMENT'
    | 'INVALID_EMAIL'
    | 'DOMAIN_NOT_ALLOWED_TO_REGISTER'
    | 'USER_ALREADY_REGISTERED'
    | 'USER_INVITATION_DOES_NOT_EXIST'
    | 'USER_DOES_NOT_EXIST'
    | 'USER_INVITE_OPERATION_FAILED'
    | 'USER_DISABLED'
    | 'ACCOUNT_DOES_NOT_EXIST'
    | 'INACTIVE_ACCOUNT'
    | 'ACCOUNT_MIGRATED'
    | 'USER_DOMAIN_NOT_ALLOWED'
    | 'MAX_FAILED_ATTEMPT_COUNT_EXCEEDED'
    | 'RESOURCE_NOT_FOUND'
    | 'ROLE_DOES_NOT_EXIST'
    | 'EMAIL_NOT_VERIFIED'
    | 'EMAIL_VERIFICATION_TOKEN_NOT_FOUND'
    | 'INVALID_TOKEN'
    | 'INVALID_CAPTCHA_TOKEN'
    | 'NOT_ACCOUNT_MGR_NOR_HAS_ALL_APP_ACCESS'
    | 'EXPIRED_TOKEN'
    | 'TOKEN_ALREADY_REFRESHED_ONCE'
    | 'ACCESS_DENIED'
    | 'INVALID_CREDENTIAL'
    | 'INVALID_KEY'
    | 'INVALID_KEYPATH'
    | 'INVALID_VARIABLE'
    | 'UNKNOWN_HOST'
    | 'UNREACHABLE_HOST'
    | 'INVALID_PORT'
    | 'SSH_SESSION_TIMEOUT'
    | 'SOCKET_CONNECTION_ERROR'
    | 'SOCKET_CONNECTION_TIMEOUT'
    | 'CONNECTION_TIMEOUT'
    | 'SSH_CONNECTION_ERROR'
    | 'USER_GROUP_ERROR'
    | 'INVALID_EXECUTION_ID'
    | 'ERROR_IN_GETTING_CHANNEL_STREAMS'
    | 'UNEXPECTED'
    | 'UNKNOWN_ERROR'
    | 'UNKNOWN_EXECUTOR_TYPE_ERROR'
    | 'DUPLICATE_STATE_NAMES'
    | 'TRANSITION_NOT_LINKED'
    | 'TRANSITION_TO_INCORRECT_STATE'
    | 'TRANSITION_TYPE_NULL'
    | 'STATES_WITH_DUP_TRANSITIONS'
    | 'BARRIERS_NOT_RUNNING_CONCURRENTLY'
    | 'NON_FORK_STATES'
    | 'NON_REPEAT_STATES'
    | 'INITIAL_STATE_NOT_DEFINED'
    | 'FILE_INTEGRITY_CHECK_FAILED'
    | 'INVALID_URL'
    | 'FILE_DOWNLOAD_FAILED'
    | 'PLATFORM_SOFTWARE_DELETE_ERROR'
    | 'INVALID_CSV_FILE'
    | 'INVALID_REQUEST'
    | 'INVALID_INFRA_STATE'
    | 'PIPELINE_ALREADY_TRIGGERED'
    | 'NON_EXISTING_PIPELINE'
    | 'DUPLICATE_COMMAND_NAMES'
    | 'INVALID_PIPELINE'
    | 'COMMAND_DOES_NOT_EXIST'
    | 'DUPLICATE_ARTIFACTSTREAM_NAMES'
    | 'DUPLICATE_HOST_NAMES'
    | 'STATE_NOT_FOR_TYPE'
    | 'STATE_MACHINE_ISSUE'
    | 'STATE_DISCONTINUE_FAILED'
    | 'STATE_PAUSE_FAILED'
    | 'PAUSE_ALL_ALREADY'
    | 'RESUME_ALL_ALREADY'
    | 'ROLLBACK_ALREADY'
    | 'ABORT_ALL_ALREADY'
    | 'RETRY_FAILED'
    | 'UNKNOWN_ARTIFACT_TYPE'
    | 'INIT_TIMEOUT'
    | 'LICENSE_EXPIRED'
    | 'NOT_LICENSED'
    | 'REQUEST_TIMEOUT'
    | 'WORKFLOW_ALREADY_TRIGGERED'
    | 'JENKINS_ERROR'
    | 'INVALID_ARTIFACT_SOURCE'
    | 'INVALID_ARTIFACT_SERVER'
    | 'INVALID_CLOUD_PROVIDER'
    | 'UPDATE_NOT_ALLOWED'
    | 'DELETE_NOT_ALLOWED'
    | 'APPDYNAMICS_CONFIGURATION_ERROR'
    | 'APM_CONFIGURATION_ERROR'
    | 'SPLUNK_CONFIGURATION_ERROR'
    | 'ELK_CONFIGURATION_ERROR'
    | 'LOGZ_CONFIGURATION_ERROR'
    | 'SUMO_CONFIGURATION_ERROR'
    | 'INSTANA_CONFIGURATION_ERROR'
    | 'APPDYNAMICS_ERROR'
    | 'STACKDRIVER_ERROR'
    | 'STACKDRIVER_CONFIGURATION_ERROR'
    | 'NEWRELIC_CONFIGURATION_ERROR'
    | 'NEWRELIC_ERROR'
    | 'DYNA_TRACE_CONFIGURATION_ERROR'
    | 'DYNA_TRACE_ERROR'
    | 'CLOUDWATCH_ERROR'
    | 'CLOUDWATCH_CONFIGURATION_ERROR'
    | 'PROMETHEUS_CONFIGURATION_ERROR'
    | 'DATA_DOG_CONFIGURATION_ERROR'
    | 'SERVICE_GUARD_CONFIGURATION_ERROR'
    | 'ENCRYPTION_NOT_CONFIGURED'
    | 'UNAVAILABLE_DELEGATES'
    | 'WORKFLOW_EXECUTION_IN_PROGRESS'
    | 'PIPELINE_EXECUTION_IN_PROGRESS'
    | 'AWS_ACCESS_DENIED'
    | 'AWS_CLUSTER_NOT_FOUND'
    | 'AWS_SERVICE_NOT_FOUND'
    | 'INVALID_YAML_PAYLOAD'
    | 'UNRECOGNIZED_YAML_FIELDS'
    | 'COULD_NOT_MAP_BEFORE_YAML'
    | 'MISSING_BEFORE_YAML'
    | 'MISSING_YAML'
    | 'NON_EMPTY_DELETIONS'
    | 'GENERAL_YAML_ERROR'
    | 'GENERAL_YAML_INFO'
    | 'YAML_GIT_SYNC_ERROR'
    | 'GIT_CONNECTION_ERROR'
    | 'GIT_ERROR'
    | 'ARTIFACT_SERVER_ERROR'
    | 'ENCRYPT_DECRYPT_ERROR'
    | 'SECRET_MANAGEMENT_ERROR'
    | 'KMS_OPERATION_ERROR'
    | 'GCP_KMS_OPERATION_ERROR'
    | 'VAULT_OPERATION_ERROR'
    | 'AWS_SECRETS_MANAGER_OPERATION_ERROR'
    | 'AZURE_KEY_VAULT_OPERATION_ERROR'
    | 'CYBERARK_OPERATION_ERROR'
    | 'UNSUPPORTED_OPERATION_EXCEPTION'
    | 'FEATURE_UNAVAILABLE'
    | 'GENERAL_ERROR'
    | 'BASELINE_CONFIGURATION_ERROR'
    | 'SAML_IDP_CONFIGURATION_NOT_AVAILABLE'
    | 'INVALID_AUTHENTICATION_MECHANISM'
    | 'INVALID_SAML_CONFIGURATION'
    | 'INVALID_OAUTH_CONFIGURATION'
    | 'INVALID_LDAP_CONFIGURATION'
    | 'USER_GROUP_SYNC_FAILURE'
    | 'USER_GROUP_ALREADY_EXIST'
    | 'INVALID_TWO_FACTOR_AUTHENTICATION_CONFIGURATION'
    | 'EXPLANATION'
    | 'HINT'
    | 'NOT_WHITELISTED_IP'
    | 'INVALID_TOTP_TOKEN'
    | 'EMAIL_FAILED'
    | 'SSL_HANDSHAKE_FAILED'
    | 'NO_APPS_ASSIGNED'
    | 'INVALID_INFRA_CONFIGURATION'
    | 'TEMPLATES_LINKED'
    | 'USER_HAS_NO_PERMISSIONS'
    | 'USER_NOT_AUTHORIZED'
    | 'USER_ALREADY_PRESENT'
    | 'INVALID_USAGE_RESTRICTION'
    | 'USAGE_RESTRICTION_ERROR'
    | 'STATE_EXECUTION_INSTANCE_NOT_FOUND'
    | 'DELEGATE_TASK_RETRY'
    | 'KUBERNETES_YAML_ERROR'
    | 'SAVE_FILE_INTO_GCP_STORAGE_FAILED'
    | 'READ_FILE_FROM_GCP_STORAGE_FAILED'
    | 'USAGE_LIMITS_EXCEEDED'
    | 'EVENT_PUBLISH_FAILED'
    | 'JIRA_ERROR'
    | 'EXPRESSION_EVALUATION_FAILED'
    | 'KUBERNETES_VALUES_ERROR'
    | 'KUBERNETES_CLUSTER_ERROR'
    | 'INCORRECT_SIGN_IN_MECHANISM'
    | 'OAUTH_LOGIN_FAILED'
    | 'INVALID_TERRAFORM_TARGETS_REQUEST'
    | 'FILE_READ_FAILED'
    | 'FILE_SIZE_EXCEEDS_LIMIT'
    | 'CLUSTER_NOT_FOUND'
    | 'MARKETPLACE_TOKEN_NOT_FOUND'
    | 'INVALID_MARKETPLACE_TOKEN'
    | 'INVALID_TICKETING_SERVER'
    | 'SERVICENOW_ERROR'
    | 'PASSWORD_EXPIRED'
    | 'USER_LOCKED'
    | 'PASSWORD_STRENGTH_CHECK_FAILED'
    | 'ACCOUNT_DISABLED'
    | 'INVALID_ACCOUNT_PERMISSION'
    | 'PAGERDUTY_ERROR'
    | 'HEALTH_ERROR'
    | 'SAML_TEST_SUCCESS_MECHANISM_NOT_ENABLED'
    | 'DOMAIN_WHITELIST_FILTER_CHECK_FAILED'
    | 'INVALID_DASHBOARD_UPDATE_REQUEST'
    | 'DUPLICATE_FIELD'
    | 'INVALID_AZURE_VAULT_CONFIGURATION'
    | 'USER_NOT_AUTHORIZED_DUE_TO_USAGE_RESTRICTIONS'
    | 'INVALID_ROLLBACK'
    | 'SUMO_DATA_COLLECTION_ERROR'
    | 'DEPLOYMENT_GOVERNANCE_ERROR'
    | 'BATCH_PROCESSING_ERROR'
    | 'GRAPHQL_ERROR'
    | 'FILE_CREATE_ERROR'
    | 'ILLEGAL_STATE'
    | 'GIT_DIFF_COMMIT_NOT_IN_ORDER'
    | 'FAILED_TO_ACQUIRE_PERSISTENT_LOCK'
    | 'FAILED_TO_ACQUIRE_NON_PERSISTENT_LOCK'
    | 'POD_NOT_FOUND_ERROR'
    | 'COMMAND_EXECUTION_ERROR'
    | 'REGISTRY_EXCEPTION'
    | 'ENGINE_INTERRUPT_PROCESSING_EXCEPTION'
    | 'ENGINE_IO_EXCEPTION'
    | 'ENGINE_OUTCOME_EXCEPTION'
    | 'ENGINE_SWEEPING_OUTPUT_EXCEPTION'
    | 'CACHE_NOT_FOUND_EXCEPTION'
    | 'ENGINE_ENTITY_UPDATE_EXCEPTION'
    | 'SHELL_EXECUTION_EXCEPTION'
    | 'TEMPLATE_NOT_FOUND'
    | 'AZURE_SERVICE_EXCEPTION'
    | 'GIT_UNSEEN_REMOTE_HEAD_COMMIT'
    | 'TIMEOUT_ENGINE_EXCEPTION'
    | 'NO_AVAILABLE_DELEGATES'
    | 'NO_INSTALLED_DELEGATES'
    | 'DUPLICATE_DELEGATE_EXCEPTION'
    | 'GCP_MARKETPLACE_EXCEPTION'
    | 'MISSING_DEFAULT_GOOGLE_CREDENTIALS'
    | 'INCORRECT_DEFAULT_GOOGLE_CREDENTIALS'
  message?: string
  correlationId?: string
  errors?: ValidationError[]
}

export interface ValidationError {
  fieldId?: string
  error?: string
}

export interface ErrorDTO {
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
  code?:
    | 'DEFAULT_ERROR_CODE'
    | 'INVALID_ARGUMENT'
    | 'INVALID_EMAIL'
    | 'DOMAIN_NOT_ALLOWED_TO_REGISTER'
    | 'USER_ALREADY_REGISTERED'
    | 'USER_INVITATION_DOES_NOT_EXIST'
    | 'USER_DOES_NOT_EXIST'
    | 'USER_INVITE_OPERATION_FAILED'
    | 'USER_DISABLED'
    | 'ACCOUNT_DOES_NOT_EXIST'
    | 'INACTIVE_ACCOUNT'
    | 'ACCOUNT_MIGRATED'
    | 'USER_DOMAIN_NOT_ALLOWED'
    | 'MAX_FAILED_ATTEMPT_COUNT_EXCEEDED'
    | 'RESOURCE_NOT_FOUND'
    | 'ROLE_DOES_NOT_EXIST'
    | 'EMAIL_NOT_VERIFIED'
    | 'EMAIL_VERIFICATION_TOKEN_NOT_FOUND'
    | 'INVALID_TOKEN'
    | 'INVALID_CAPTCHA_TOKEN'
    | 'NOT_ACCOUNT_MGR_NOR_HAS_ALL_APP_ACCESS'
    | 'EXPIRED_TOKEN'
    | 'TOKEN_ALREADY_REFRESHED_ONCE'
    | 'ACCESS_DENIED'
    | 'INVALID_CREDENTIAL'
    | 'INVALID_KEY'
    | 'INVALID_KEYPATH'
    | 'INVALID_VARIABLE'
    | 'UNKNOWN_HOST'
    | 'UNREACHABLE_HOST'
    | 'INVALID_PORT'
    | 'SSH_SESSION_TIMEOUT'
    | 'SOCKET_CONNECTION_ERROR'
    | 'SOCKET_CONNECTION_TIMEOUT'
    | 'CONNECTION_TIMEOUT'
    | 'SSH_CONNECTION_ERROR'
    | 'USER_GROUP_ERROR'
    | 'INVALID_EXECUTION_ID'
    | 'ERROR_IN_GETTING_CHANNEL_STREAMS'
    | 'UNEXPECTED'
    | 'UNKNOWN_ERROR'
    | 'UNKNOWN_EXECUTOR_TYPE_ERROR'
    | 'DUPLICATE_STATE_NAMES'
    | 'TRANSITION_NOT_LINKED'
    | 'TRANSITION_TO_INCORRECT_STATE'
    | 'TRANSITION_TYPE_NULL'
    | 'STATES_WITH_DUP_TRANSITIONS'
    | 'BARRIERS_NOT_RUNNING_CONCURRENTLY'
    | 'NON_FORK_STATES'
    | 'NON_REPEAT_STATES'
    | 'INITIAL_STATE_NOT_DEFINED'
    | 'FILE_INTEGRITY_CHECK_FAILED'
    | 'INVALID_URL'
    | 'FILE_DOWNLOAD_FAILED'
    | 'PLATFORM_SOFTWARE_DELETE_ERROR'
    | 'INVALID_CSV_FILE'
    | 'INVALID_REQUEST'
    | 'INVALID_INFRA_STATE'
    | 'PIPELINE_ALREADY_TRIGGERED'
    | 'NON_EXISTING_PIPELINE'
    | 'DUPLICATE_COMMAND_NAMES'
    | 'INVALID_PIPELINE'
    | 'COMMAND_DOES_NOT_EXIST'
    | 'DUPLICATE_ARTIFACTSTREAM_NAMES'
    | 'DUPLICATE_HOST_NAMES'
    | 'STATE_NOT_FOR_TYPE'
    | 'STATE_MACHINE_ISSUE'
    | 'STATE_DISCONTINUE_FAILED'
    | 'STATE_PAUSE_FAILED'
    | 'PAUSE_ALL_ALREADY'
    | 'RESUME_ALL_ALREADY'
    | 'ROLLBACK_ALREADY'
    | 'ABORT_ALL_ALREADY'
    | 'RETRY_FAILED'
    | 'UNKNOWN_ARTIFACT_TYPE'
    | 'INIT_TIMEOUT'
    | 'LICENSE_EXPIRED'
    | 'NOT_LICENSED'
    | 'REQUEST_TIMEOUT'
    | 'WORKFLOW_ALREADY_TRIGGERED'
    | 'JENKINS_ERROR'
    | 'INVALID_ARTIFACT_SOURCE'
    | 'INVALID_ARTIFACT_SERVER'
    | 'INVALID_CLOUD_PROVIDER'
    | 'UPDATE_NOT_ALLOWED'
    | 'DELETE_NOT_ALLOWED'
    | 'APPDYNAMICS_CONFIGURATION_ERROR'
    | 'APM_CONFIGURATION_ERROR'
    | 'SPLUNK_CONFIGURATION_ERROR'
    | 'ELK_CONFIGURATION_ERROR'
    | 'LOGZ_CONFIGURATION_ERROR'
    | 'SUMO_CONFIGURATION_ERROR'
    | 'INSTANA_CONFIGURATION_ERROR'
    | 'APPDYNAMICS_ERROR'
    | 'STACKDRIVER_ERROR'
    | 'STACKDRIVER_CONFIGURATION_ERROR'
    | 'NEWRELIC_CONFIGURATION_ERROR'
    | 'NEWRELIC_ERROR'
    | 'DYNA_TRACE_CONFIGURATION_ERROR'
    | 'DYNA_TRACE_ERROR'
    | 'CLOUDWATCH_ERROR'
    | 'CLOUDWATCH_CONFIGURATION_ERROR'
    | 'PROMETHEUS_CONFIGURATION_ERROR'
    | 'DATA_DOG_CONFIGURATION_ERROR'
    | 'SERVICE_GUARD_CONFIGURATION_ERROR'
    | 'ENCRYPTION_NOT_CONFIGURED'
    | 'UNAVAILABLE_DELEGATES'
    | 'WORKFLOW_EXECUTION_IN_PROGRESS'
    | 'PIPELINE_EXECUTION_IN_PROGRESS'
    | 'AWS_ACCESS_DENIED'
    | 'AWS_CLUSTER_NOT_FOUND'
    | 'AWS_SERVICE_NOT_FOUND'
    | 'INVALID_YAML_PAYLOAD'
    | 'UNRECOGNIZED_YAML_FIELDS'
    | 'COULD_NOT_MAP_BEFORE_YAML'
    | 'MISSING_BEFORE_YAML'
    | 'MISSING_YAML'
    | 'NON_EMPTY_DELETIONS'
    | 'GENERAL_YAML_ERROR'
    | 'GENERAL_YAML_INFO'
    | 'YAML_GIT_SYNC_ERROR'
    | 'GIT_CONNECTION_ERROR'
    | 'GIT_ERROR'
    | 'ARTIFACT_SERVER_ERROR'
    | 'ENCRYPT_DECRYPT_ERROR'
    | 'SECRET_MANAGEMENT_ERROR'
    | 'KMS_OPERATION_ERROR'
    | 'GCP_KMS_OPERATION_ERROR'
    | 'VAULT_OPERATION_ERROR'
    | 'AWS_SECRETS_MANAGER_OPERATION_ERROR'
    | 'AZURE_KEY_VAULT_OPERATION_ERROR'
    | 'CYBERARK_OPERATION_ERROR'
    | 'UNSUPPORTED_OPERATION_EXCEPTION'
    | 'FEATURE_UNAVAILABLE'
    | 'GENERAL_ERROR'
    | 'BASELINE_CONFIGURATION_ERROR'
    | 'SAML_IDP_CONFIGURATION_NOT_AVAILABLE'
    | 'INVALID_AUTHENTICATION_MECHANISM'
    | 'INVALID_SAML_CONFIGURATION'
    | 'INVALID_OAUTH_CONFIGURATION'
    | 'INVALID_LDAP_CONFIGURATION'
    | 'USER_GROUP_SYNC_FAILURE'
    | 'USER_GROUP_ALREADY_EXIST'
    | 'INVALID_TWO_FACTOR_AUTHENTICATION_CONFIGURATION'
    | 'EXPLANATION'
    | 'HINT'
    | 'NOT_WHITELISTED_IP'
    | 'INVALID_TOTP_TOKEN'
    | 'EMAIL_FAILED'
    | 'SSL_HANDSHAKE_FAILED'
    | 'NO_APPS_ASSIGNED'
    | 'INVALID_INFRA_CONFIGURATION'
    | 'TEMPLATES_LINKED'
    | 'USER_HAS_NO_PERMISSIONS'
    | 'USER_NOT_AUTHORIZED'
    | 'USER_ALREADY_PRESENT'
    | 'INVALID_USAGE_RESTRICTION'
    | 'USAGE_RESTRICTION_ERROR'
    | 'STATE_EXECUTION_INSTANCE_NOT_FOUND'
    | 'DELEGATE_TASK_RETRY'
    | 'KUBERNETES_YAML_ERROR'
    | 'SAVE_FILE_INTO_GCP_STORAGE_FAILED'
    | 'READ_FILE_FROM_GCP_STORAGE_FAILED'
    | 'USAGE_LIMITS_EXCEEDED'
    | 'EVENT_PUBLISH_FAILED'
    | 'JIRA_ERROR'
    | 'EXPRESSION_EVALUATION_FAILED'
    | 'KUBERNETES_VALUES_ERROR'
    | 'KUBERNETES_CLUSTER_ERROR'
    | 'INCORRECT_SIGN_IN_MECHANISM'
    | 'OAUTH_LOGIN_FAILED'
    | 'INVALID_TERRAFORM_TARGETS_REQUEST'
    | 'FILE_READ_FAILED'
    | 'FILE_SIZE_EXCEEDS_LIMIT'
    | 'CLUSTER_NOT_FOUND'
    | 'MARKETPLACE_TOKEN_NOT_FOUND'
    | 'INVALID_MARKETPLACE_TOKEN'
    | 'INVALID_TICKETING_SERVER'
    | 'SERVICENOW_ERROR'
    | 'PASSWORD_EXPIRED'
    | 'USER_LOCKED'
    | 'PASSWORD_STRENGTH_CHECK_FAILED'
    | 'ACCOUNT_DISABLED'
    | 'INVALID_ACCOUNT_PERMISSION'
    | 'PAGERDUTY_ERROR'
    | 'HEALTH_ERROR'
    | 'SAML_TEST_SUCCESS_MECHANISM_NOT_ENABLED'
    | 'DOMAIN_WHITELIST_FILTER_CHECK_FAILED'
    | 'INVALID_DASHBOARD_UPDATE_REQUEST'
    | 'DUPLICATE_FIELD'
    | 'INVALID_AZURE_VAULT_CONFIGURATION'
    | 'USER_NOT_AUTHORIZED_DUE_TO_USAGE_RESTRICTIONS'
    | 'INVALID_ROLLBACK'
    | 'SUMO_DATA_COLLECTION_ERROR'
    | 'DEPLOYMENT_GOVERNANCE_ERROR'
    | 'BATCH_PROCESSING_ERROR'
    | 'GRAPHQL_ERROR'
    | 'FILE_CREATE_ERROR'
    | 'ILLEGAL_STATE'
    | 'GIT_DIFF_COMMIT_NOT_IN_ORDER'
    | 'FAILED_TO_ACQUIRE_PERSISTENT_LOCK'
    | 'FAILED_TO_ACQUIRE_NON_PERSISTENT_LOCK'
    | 'POD_NOT_FOUND_ERROR'
    | 'COMMAND_EXECUTION_ERROR'
    | 'REGISTRY_EXCEPTION'
    | 'ENGINE_INTERRUPT_PROCESSING_EXCEPTION'
    | 'ENGINE_IO_EXCEPTION'
    | 'ENGINE_OUTCOME_EXCEPTION'
    | 'ENGINE_SWEEPING_OUTPUT_EXCEPTION'
    | 'CACHE_NOT_FOUND_EXCEPTION'
    | 'ENGINE_ENTITY_UPDATE_EXCEPTION'
    | 'SHELL_EXECUTION_EXCEPTION'
    | 'TEMPLATE_NOT_FOUND'
    | 'AZURE_SERVICE_EXCEPTION'
    | 'GIT_UNSEEN_REMOTE_HEAD_COMMIT'
    | 'TIMEOUT_ENGINE_EXCEPTION'
    | 'NO_AVAILABLE_DELEGATES'
    | 'NO_INSTALLED_DELEGATES'
    | 'DUPLICATE_DELEGATE_EXCEPTION'
    | 'GCP_MARKETPLACE_EXCEPTION'
    | 'MISSING_DEFAULT_GOOGLE_CREDENTIALS'
    | 'INCORRECT_DEFAULT_GOOGLE_CREDENTIALS'
  message?: string
  correlationId?: string
  detailedMessage?: string
}

export type AppDynamicsConnectorDTO = ConnectorConfigDTO & {
  username: string
  accountname: string
  controllerUrl: string
  accountId: string
  passwordRef: string
}

export type AwsConnectorDTO = ConnectorConfigDTO & {
  credential: AwsCredentialDTO
}

export interface AwsCredentialDTO {
  crossAccountAccess?: CrossAccountAccess
  type: 'InheritFromDelegate' | 'ManualConfig'
  spec: AwsCredentialSpecDTO
}

export interface AwsCredentialSpecDTO {
  [key: string]: any
}

export type AwsInheritFromDelegateSpecDTO = AwsCredentialSpecDTO & {
  delegateSelector: string
}

export type AwsManualConfigSpecDTO = AwsCredentialSpecDTO & {
  accessKey: string
  secretKeyRef: string
}

export interface ConnectorConfigDTO {
  [key: string]: any
}

export interface ConnectorConnectivityDetails {
  status?: 'SUCCESS' | 'FAILURE'
  errorMessage?: string
  lastTestedAt?: number
  lastConnectedAt?: number
}

export interface ConnectorInfoDTO {
  name: string
  identifier: string
  description?: string
  orgIdentifier?: string
  projectIdentifier?: string
  tags?: string[]
  type:
    | 'K8sCluster'
    | 'Git'
    | 'Splunk'
    | 'AppDynamics'
    | 'Vault'
    | 'DockerRegistry'
    | 'Local'
    | 'AwsKms'
    | 'GcpKms'
    | 'Awssecretsmanager'
    | 'Azurevault'
    | 'Cyberark'
    | 'CustomSecretManager'
    | 'Gcp'
    | 'Aws'
  spec: ConnectorConfigDTO
}

export interface ConnectorResponse {
  connector?: ConnectorInfoDTO
  createdAt?: number
  lastModifiedAt?: number
  status?: ConnectorConnectivityDetails
}

export interface CrossAccountAccess {
  crossAccountRoleArn: string
  externalId?: string
}

export interface CustomCommitAttributes {
  authorName?: string
  authorEmail?: string
  commitMessage?: string
}

export interface DockerAuthCredentialsDTO {
  [key: string]: any
}

export interface DockerAuthenticationDTO {
  type: 'UsernamePassword'
  spec: DockerAuthCredentialsDTO
}

export type DockerConnectorDTO = ConnectorConfigDTO & {
  dockerRegistryUrl: string
  auth?: DockerAuthenticationDTO
}

export type DockerUserNamePasswordDTO = DockerAuthCredentialsDTO & {
  username?: string
  passwordRef: string
}

export interface GcpConnectorCredentialDTO {
  type: 'InheritFromDelegate' | 'ManualConfig'
  spec: GcpCredentialSpecDTO
}

export type GcpConnectorDTO = ConnectorConfigDTO & {
  credential?: GcpConnectorCredentialDTO
}

export interface GcpCredentialSpecDTO {
  [key: string]: any
}

export type GcpDelegateDetailsDTO = GcpCredentialSpecDTO & {
  delegateSelector?: string
}

export type GcpKmsConnectorDTO = ConnectorConfigDTO & {
  projectId?: string
  region?: string
  keyRing?: string
  keyName?: string
  credentials?: string[]
  default?: boolean
}

export type GcpManualDetailsDTO = GcpCredentialSpecDTO & {
  spec: GcpSecretKeyAuthDTO
}

export interface GcpSecretKeyAuthDTO {
  secretKeyRef: string
}

export interface GitAuthenticationDTO {
  [key: string]: any
}

export type GitConfigDTO = ConnectorConfigDTO & {
  url: string
  branchName?: string
  type: 'Http' | 'Ssh'
  connectionType: 'ACCOUNT' | 'REPO'
  spec: GitAuthenticationDTO
  gitSync?: GitSyncConfig
}

export type GitHTTPAuthenticationDTO = GitAuthenticationDTO & {
  username: string
  passwordRef: string
}

export type GitSSHAuthenticationDTO = GitAuthenticationDTO & {
  sshKeyReference?: string
}

export interface GitSyncConfig {
  enabled?: boolean
  customCommitAttributes?: CustomCommitAttributes
  syncEnabled?: boolean
}

export interface KubernetesAuthCredentialDTO {
  [key: string]: any
}

export interface KubernetesAuthDTO {
  type: 'UsernamePassword' | 'ClientKeyCert' | 'ServiceAccount' | 'OpenIdConnect'
  spec: KubernetesAuthCredentialDTO
}

export type KubernetesClientKeyCertDTO = KubernetesAuthCredentialDTO & {
  caCertRef?: string
  clientCertRef: string
  clientKeyRef: string
  clientKeyPassphraseRef: string
  clientKeyAlgo?: string
}

export type KubernetesClusterConfigDTO = ConnectorConfigDTO & {
  credential?: KubernetesCredentialDTO
}

export type KubernetesClusterDetailsDTO = KubernetesCredentialSpecDTO & {
  masterUrl: string
  auth: KubernetesAuthDTO
}

export interface KubernetesCredentialDTO {
  type: 'InheritFromDelegate' | 'ManualConfig'
  spec: KubernetesCredentialSpecDTO
}

export interface KubernetesCredentialSpecDTO {
  [key: string]: any
}

export type KubernetesDelegateDetailsDTO = KubernetesCredentialSpecDTO & {
  delegateName: string
}

export type KubernetesOpenIdConnectDTO = KubernetesAuthCredentialDTO & {
  oidcIssuerUrl: string
  oidcClientIdRef: string
  oidcUsername: string
  oidcPasswordRef: string
  oidcSecretRef?: string
  oidcScopes?: string
}

export type KubernetesServiceAccountDTO = KubernetesAuthCredentialDTO & {
  serviceAccountTokenRef: string
}

export type KubernetesUserNamePasswordDTO = KubernetesAuthCredentialDTO & {
  username?: string
  passwordRef: string
}

export type LocalConnectorDTO = ConnectorConfigDTO & {
  default?: boolean
}

export interface ResponseDTOConnectorResponse {
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
  data?: ConnectorResponse
  metaData?: { [key: string]: any }
  correlationId?: string
}

export type SplunkConnectorDTO = ConnectorConfigDTO & {
  splunkUrl?: string
  username?: string
  accountId: string
  passwordRef: string
}

export type VaultConnectorDTO = ConnectorConfigDTO & {
  authToken?: string
  basePath?: string
  vaultUrl?: string
  renewIntervalHours?: number
  secretEngineName?: string
  appRoleId?: string
  secretId?: string
  secretEngineVersion?: number
  default?: boolean
  readOnly?: boolean
}

export interface Connector {
  connector?: ConnectorInfoDTO
}

export interface ResponseDTOBoolean {
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
  data?: boolean
  metaData?: { [key: string]: any }
  correlationId?: string
}

export interface NGPageResponse {
  pageCount?: number
  itemCount?: number
  pageSize?: number
  content?: { [key: string]: any }[]
  pageIndex?: number
  empty?: boolean
}

export interface NGPageResponseConnectorResponse {
  pageCount?: number
  itemCount?: number
  pageSize?: number
  content?: ConnectorResponse[]
  pageIndex?: number
  empty?: boolean
}

export interface ResponseDTONGPageResponseConnectorResponse {
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
  data?: NGPageResponseConnectorResponse
  metaData?: { [key: string]: any }
  correlationId?: string
}

export interface GitSyncEntityDTO {
  entityName?: string
  entityType?: 'projects' | 'pipelines' | 'connectors' | 'secrets'
  entityIdentifier?: string
  gitConnectorId?: string
  repositoryName?: string
  branch?: string
  filePath?: string
  repoProviderType?: 'github' | 'gitlab' | 'bitbucket' | 'unknown'
}

export interface GitSyncEntityListDTO {
  entityType?: 'projects' | 'pipelines' | 'connectors' | 'secrets'
  count?: number
  gitSyncEntities?: GitSyncEntityDTO[]
}

export interface GitSyncProductDTO {
  moduleType?: 'CD' | 'CI' | 'CORE' | 'CV' | 'CF' | 'CE'
  gitSyncEntityListDTOList?: GitSyncEntityListDTO[]
}

export interface ResponseDTOGitSyncProductDTO {
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
  data?: GitSyncProductDTO
  metaData?: { [key: string]: any }
  correlationId?: string
}

export interface NGPageResponseGitSyncEntityListDTO {
  pageCount?: number
  itemCount?: number
  pageSize?: number
  content?: GitSyncEntityListDTO[]
  pageIndex?: number
  empty?: boolean
}

export interface ResponseDTONGPageResponseGitSyncEntityListDTO {
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
  data?: NGPageResponseGitSyncEntityListDTO
  metaData?: { [key: string]: any }
  correlationId?: string
}

export interface GitSyncConfigDTO {
  identifier?: string
  projectId?: string
  organizationId?: string
  accountId?: string
  gitConnectorId?: string
  repo?: string
  branch?: string
  gitSyncFolderConfigDTOs?: GitSyncFolderConfigDTO[]
}

export interface GitSyncFolderConfigDTO {
  rootFolder?: string
  isDefault?: boolean
  identifier?: string
  enabled?: boolean
}

export interface Activity {
  accountIdentifier?: string
  referredEntityOrgIdentifier?: string
  referredEntityProjectIdentifier?: string
  referredEntityIdentifier?: string
  referredEntityScope: 'ACCOUNT' | 'ORG' | 'PROJECT'
  referredEntityType: 'projects' | 'pipelines' | 'connectors' | 'secrets'
  type: 'CONNECTIVITY_CHECK' | 'ENTITY_USAGE'
  activityStatus: 'SUCCESS' | 'FAILED'
  detail?: ActivityDetail
  activityTime: number
  description?: string
  errorMessage?: string
}

export interface ActivityDetail {
  [key: string]: any
}

export interface Page {
  totalPages?: number
  totalElements?: number
  size?: number
  content?: { [key: string]: any }[]
  number?: number
  sort?: Sort
  first?: boolean
  numberOfElements?: number
  last?: boolean
  pageable?: Pageable
  empty?: boolean
}

export interface PageActivity {
  totalPages?: number
  totalElements?: number
  size?: number
  content?: Activity[]
  number?: number
  sort?: Sort
  first?: boolean
  numberOfElements?: number
  last?: boolean
  pageable?: Pageable
  empty?: boolean
}

export interface Pageable {
  offset?: number
  sort?: Sort
  pageSize?: number
  paged?: boolean
  unpaged?: boolean
  pageNumber?: number
}

export interface ResponseDTOPageActivity {
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
  data?: PageActivity
  metaData?: { [key: string]: any }
  correlationId?: string
}

export interface Sort {
  sorted?: boolean
  unsorted?: boolean
  empty?: boolean
}

export interface ResponseDTOActivity {
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
  data?: Activity
  metaData?: { [key: string]: any }
  correlationId?: string
}

export interface DockerBuildDetailsDTO {
  tag?: string
  buildUrl?: string
  metadata?: {
    [key: string]: string
  }
  labels?: {
    [key: string]: string
  }
  imagePath?: string
}

export interface ResponseDTODockerBuildDetailsDTO {
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
  data?: DockerBuildDetailsDTO
  metaData?: { [key: string]: any }
  correlationId?: string
}

export interface DockerRequestDTO {
  tag?: string
  tagRegex?: string
  tagsList?: string[]
}

export interface DockerResponseDTO {
  buildDetailsList?: DockerBuildDetailsDTO[]
}

export interface ResponseDTODockerResponseDTO {
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
  data?: DockerResponseDTO
  metaData?: { [key: string]: any }
  correlationId?: string
}

export interface DelegateResponseData {
  [key: string]: any
}

export interface EntityReferenceDTO {
  accountIdentifier?: string
  referredEntityFQN?: string
  referredEntityName?: string
  referredEntityType: 'projects' | 'pipelines' | 'connectors' | 'secrets'
  referredByEntityFQN?: string
  referredByEntityType: 'projects' | 'pipelines' | 'connectors' | 'secrets'
  referredByEntityName?: string
  createdAt?: number
}

export interface PageEntityReferenceDTO {
  totalPages?: number
  totalElements?: number
  size?: number
  content?: EntityReferenceDTO[]
  number?: number
  sort?: Sort
  first?: boolean
  numberOfElements?: number
  last?: boolean
  pageable?: Pageable
  empty?: boolean
}

export interface ResponseDTOPageEntityReferenceDTO {
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
  data?: PageEntityReferenceDTO
  metaData?: { [key: string]: any }
  correlationId?: string
}

export interface ResponseDTOEntityReferenceDTO {
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
  data?: EntityReferenceDTO
  metaData?: { [key: string]: any }
  correlationId?: string
}

export interface EnvironmentResponseDTO {
  accountId?: string
  orgIdentifier?: string
  projectIdentifier?: string
  identifier?: string
  name?: string
  description?: string
  type?: 'PreProduction' | 'Production'
  deleted?: boolean
}

export interface ResponseDTOEnvironmentResponseDTO {
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
  data?: EnvironmentResponseDTO
  metaData?: { [key: string]: any }
  correlationId?: string
}

export interface EnvironmentRequestDTO {
  orgIdentifier: string
  projectIdentifier: string
  identifier: string
  name?: string
  description?: string
  type: 'PreProduction' | 'Production'
}

export interface NGPageResponseEnvironmentResponseDTO {
  pageCount?: number
  itemCount?: number
  pageSize?: number
  content?: EnvironmentResponseDTO[]
  pageIndex?: number
  empty?: boolean
}

export interface ResponseDTONGPageResponseEnvironmentResponseDTO {
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
  data?: NGPageResponseEnvironmentResponseDTO
  metaData?: { [key: string]: any }
  correlationId?: string
}

export interface InputSetTemplateResponse {
  inputSetTemplateYaml?: string
}

export interface ResponseDTOInputSetTemplateResponse {
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
  data?: InputSetTemplateResponse
  metaData?: { [key: string]: any }
  correlationId?: string
}

export interface InputSetResponse {
  accountId?: string
  orgIdentifier?: string
  projectIdentifier?: string
  pipelineIdentifier?: string
  identifier?: string
  inputSetYaml?: string
  name?: string
  description?: string
}

export interface ResponseDTOInputSetResponse {
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
  data?: InputSetResponse
  metaData?: { [key: string]: any }
  correlationId?: string
}

export interface OverlayInputSetResponseDTO {
  accountId?: string
  orgIdentifier?: string
  projectIdentifier?: string
  pipelineIdentifier?: string
  identifier?: string
  name?: string
  description?: string
  inputSetReferences?: string[]
  overlayInputSetYaml?: string
}

export interface ResponseDTOOverlayInputSetResponseDTO {
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
  data?: OverlayInputSetResponseDTO
  metaData?: { [key: string]: any }
  correlationId?: string
}

export interface ArtifactConfig {
  [key: string]: any
}

export interface ArtifactListConfig {
  primary?: ArtifactSpecWrapper
  sidecars?: SidecarArtifactWrapper[]
  metadata?: string
}

export interface ArtifactOverrideSets {
  identifier: string
  artifacts?: ArtifactListConfig
  metadata?: string
}

export interface ArtifactSpecWrapper {
  metadata?: string
  type: 'Dockerhub' | 'Gcr'
  spec?: ArtifactConfig
}

export interface CDInputSet {
  identifier: string
  name?: string
  description?: string
  pipeline?: CDPipeline
}

export interface CDPipeline {
  name: string
  identifier: string
  description?: string
  tags?: Tag[]
  stages?: StageElementWrapper[]
  metadata?: string
}

export type DeploymentStage = StageType & {
  service?: ServiceConfig
  infrastructure?: PipelineInfrastructure
  execution?: ExecutionElement
  stageVariables?: StageVariables
  skipCondition?: string
  metadata?: string
}

export type DockerHubArtifactConfig = ArtifactConfig & {
  dockerhubConnector?: string
  imagePath?: string
  tag?: string
  tagRegex?: string
  metadata?: string
}

export interface EnvironmentYaml {
  name?: string
  identifier?: string
  description?: string
  type?: 'PreProduction' | 'Production'
  tags?: Tag[]
  metadata?: string
}

export interface ExecutionElement {
  steps?: ExecutionWrapper[]
  rollbackSteps?: ExecutionWrapper[]
  metadata?: string
}

export interface ExecutionWrapper {
  [key: string]: any
}

export type GcrArtifactConfig = ArtifactConfig & {
  gcrConnector?: string
  registryHostname?: string
  imagePath?: string
  metadata?: string
}

export type GitStore = StoreConfig & {
  connectorIdentifier?: string
  gitFetchType?: 'BRANCH' | 'COMMIT'
  branch?: string
  commitId?: string
  paths?: string[]
  metadata?: string
}

export type HttpStepInfo = StepSpecType & {
  url?: string
  method?: string
  header?: string
  body?: string
  assertion?: string
  socketTimeoutMillis?: number
  metadata?: string
}

export interface InfraOverrides {
  environment?: EnvironmentYaml
  infrastructureDefinition?: InfrastructureDef
  metadata?: string
}

export interface InfraUseFromStage {
  stage: string
  overrides?: InfraOverrides
  metadata?: string
}

export interface Infrastructure {
  [key: string]: any
}

export interface InfrastructureDef {
  type?: string
  metadata?: string
  spec?: Infrastructure
}

export type K8SDirectInfrastructure = Infrastructure & {
  connectorIdentifier?: string
  namespace?: string
  releaseName?: string
  metadata?: string
}

export type K8sManifest = ManifestAttributes & {
  store?: StoreConfigWrapper
  metadata?: string
}

export type K8sRollingRollbackStepInfo = StepSpecType & {
  timeout?: number
  metadata?: string
}

export type K8sRollingStepInfo = StepSpecType & {
  timeout?: number
  skipDryRun?: boolean
  metadata?: string
}

export type KubernetesServiceSpec = ServiceSpec & {
  metadata?: string
}

export interface ManifestAttributes {
  [key: string]: any
}

export type ManifestConfig = ManifestConfigWrapper & {
  type?: string
  metadata?: string
  spec?: ManifestAttributes
}

export interface ManifestConfigWrapper {
  identifier: string
}

export interface ManifestOverrideSets {
  identifier: string
  manifests?: ManifestConfigWrapper[]
  metadata?: string
}

export type ParallelStageElement = StageElementWrapper & {
  sections: StageElementWrapper[]
  metadata?: string
}

export type ParallelStepElement = ExecutionWrapper & {
  sections: ExecutionWrapper[]
  metadata?: string
}

export interface PipelineInfrastructure {
  infrastructureDefinition?: InfrastructureDef
  useFromStage?: InfraUseFromStage
  environment?: EnvironmentYaml
  metadata?: string
}

export interface ServiceConfig {
  useFromStage?: ServiceUseFromStage
  identifier?: string
  name?: string
  description?: string
  serviceDefinition?: ServiceDefinition
  stageOverrides?: StageOverridesConfig
  metadata?: string
}

export interface ServiceDefinition {
  type?: string
  metadata?: string
  spec?: ServiceSpec
}

export interface ServiceOverrides {
  name?: string
  description?: string
  metadata?: string
}

export interface ServiceSpec {
  manifestOverrideSets?: ManifestOverrideSets[]
  artifactOverrideSets?: ArtifactOverrideSets[]
  artifacts?: ArtifactListConfig
  manifests?: ManifestConfigWrapper[]
}

export interface ServiceUseFromStage {
  stage: string
  overrides?: ServiceOverrides
  metadata?: string
}

export type ShellScriptStepInfo = StepSpecType & {
  executeOnDelegate?: boolean
  host?: string
  tags?: string[]
  connectionType?: 'SSH' | 'WINRM'
  sshKeyRef?: string
  connectionAttributes?: string
  commandPath?: string
  scriptType?: 'BASH' | 'POWERSHELL'
  scriptString?: string
  timeoutSecs?: string
  outputVars?: string
  sweepingOutputName?: string
  sweepingOutputScope?: string
  metadata?: string
}

export type SidecarArtifact = SidecarArtifactWrapper & {
  metadata?: string
  type: 'Dockerhub' | 'Gcr'
  spec?: ArtifactConfig
}

export interface SidecarArtifactWrapper {
  identifier: string
}

export type StageElement = StageElementWrapper & {
  identifier: string
  name?: string
  description?: string
  type?: string
  metadata?: string
  spec?: StageType
}

export interface StageElementWrapper {
  [key: string]: any
}

export interface StageOverridesConfig {
  useArtifactOverrideSets?: string[]
  artifacts?: ArtifactListConfig
  useManifestOverrideSets?: string[]
  manifests?: ManifestConfigWrapper[]
  metadata?: string
}

export interface StageType {
  identifier: string
}

export interface StageVariables {
  variables?: Variable[]
  previousStageIdentifier?: string
  overrides?: Variable[]
  metadata?: string
}

export type StepElement = ExecutionWrapper & {
  identifier: string
  name?: string
  type?: string
  metadata?: string
  spec?: StepSpecType
}

export type StepGroupElement = ExecutionWrapper & {
  identifier: string
  name?: string
  steps: ExecutionWrapper[]
  rollbackSteps?: ExecutionWrapper[]
  metadata?: string
}

export interface StepSpecType {
  [key: string]: any
}

export interface StoreConfig {
  [key: string]: any
}

export interface StoreConfigWrapper {
  type?: string
  metadata?: string
  spec?: StoreConfig
}

export interface Tag {
  key: string
  value: string
}

export type ValuesManifest = ManifestAttributes & {
  store?: StoreConfigWrapper
  metadata?: string
}

export interface Variable {
  name: string
  value: string
  type: string
}

export interface OverlayInputSet {
  identifier?: string
  name?: string
  description?: string
  inputSetReferences?: string[]
}

export interface InputSetSummaryResponse {
  identifier?: string
  name?: string
  pipelineIdentifier?: string
  description?: string
  inputSetType?: 'INPUT_SET' | 'OVERLAY_INPUT_SET'
}

export interface NGPageResponseInputSetSummaryResponse {
  pageCount?: number
  itemCount?: number
  pageSize?: number
  content?: InputSetSummaryResponse[]
  pageIndex?: number
  empty?: boolean
}

export interface ResponseDTONGPageResponseInputSetSummaryResponse {
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
  data?: NGPageResponseInputSetSummaryResponse
  metaData?: { [key: string]: any }
  correlationId?: string
}

export interface InviteDTO {
  id?: string
  name: string
  email: string
  role: RoleDTO
  inviteType: 'USER_INITIATED_INVITE' | 'ADMIN_INITIATED_INVITE'
  approved: boolean
}

export interface NGPageResponseInviteDTO {
  pageCount?: number
  itemCount?: number
  pageSize?: number
  content?: InviteDTO[]
  pageIndex?: number
  empty?: boolean
}

export interface ResponseDTONGPageResponseInviteDTO {
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
  data?: NGPageResponseInviteDTO
  metaData?: { [key: string]: any }
  correlationId?: string
}

export interface RoleDTO {
  name: string
}

export interface ResponseDTOOptionalInviteDTO {
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
  data?: InviteDTO
  metaData?: { [key: string]: any }
  correlationId?: string
}

export interface ResponseDTOListInviteOperationResponse {
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
  data?: (
    | 'ACCOUNT_INVITE_ACCEPTED_NEED_PASSWORD'
    | 'ACCOUNT_INVITE_ACCEPTED'
    | 'USER_INVITED_SUCCESSFULLY'
    | 'USER_ALREADY_ADDED'
    | 'USER_ALREADY_INVITED'
    | 'USER_REQUEST_REGISTERED'
    | 'FAIL'
  )[]
  metaData?: { [key: string]: any }
  correlationId?: string
}

export interface CreateInviteListDTO {
  users: string[]
  role: RoleDTO
  inviteType: 'USER_INITIATED_INVITE' | 'ADMIN_INITIATED_INVITE'
}

export interface ResponseDTOOptionalListRoleDTO {
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
  data?: RoleDTO[]
  metaData?: { [key: string]: any }
  correlationId?: string
}

export interface ResponseMessage {
  code?:
    | 'DEFAULT_ERROR_CODE'
    | 'INVALID_ARGUMENT'
    | 'INVALID_EMAIL'
    | 'DOMAIN_NOT_ALLOWED_TO_REGISTER'
    | 'USER_ALREADY_REGISTERED'
    | 'USER_INVITATION_DOES_NOT_EXIST'
    | 'USER_DOES_NOT_EXIST'
    | 'USER_INVITE_OPERATION_FAILED'
    | 'USER_DISABLED'
    | 'ACCOUNT_DOES_NOT_EXIST'
    | 'INACTIVE_ACCOUNT'
    | 'ACCOUNT_MIGRATED'
    | 'USER_DOMAIN_NOT_ALLOWED'
    | 'MAX_FAILED_ATTEMPT_COUNT_EXCEEDED'
    | 'RESOURCE_NOT_FOUND'
    | 'ROLE_DOES_NOT_EXIST'
    | 'EMAIL_NOT_VERIFIED'
    | 'EMAIL_VERIFICATION_TOKEN_NOT_FOUND'
    | 'INVALID_TOKEN'
    | 'INVALID_CAPTCHA_TOKEN'
    | 'NOT_ACCOUNT_MGR_NOR_HAS_ALL_APP_ACCESS'
    | 'EXPIRED_TOKEN'
    | 'TOKEN_ALREADY_REFRESHED_ONCE'
    | 'ACCESS_DENIED'
    | 'INVALID_CREDENTIAL'
    | 'INVALID_KEY'
    | 'INVALID_KEYPATH'
    | 'INVALID_VARIABLE'
    | 'UNKNOWN_HOST'
    | 'UNREACHABLE_HOST'
    | 'INVALID_PORT'
    | 'SSH_SESSION_TIMEOUT'
    | 'SOCKET_CONNECTION_ERROR'
    | 'SOCKET_CONNECTION_TIMEOUT'
    | 'CONNECTION_TIMEOUT'
    | 'SSH_CONNECTION_ERROR'
    | 'USER_GROUP_ERROR'
    | 'INVALID_EXECUTION_ID'
    | 'ERROR_IN_GETTING_CHANNEL_STREAMS'
    | 'UNEXPECTED'
    | 'UNKNOWN_ERROR'
    | 'UNKNOWN_EXECUTOR_TYPE_ERROR'
    | 'DUPLICATE_STATE_NAMES'
    | 'TRANSITION_NOT_LINKED'
    | 'TRANSITION_TO_INCORRECT_STATE'
    | 'TRANSITION_TYPE_NULL'
    | 'STATES_WITH_DUP_TRANSITIONS'
    | 'BARRIERS_NOT_RUNNING_CONCURRENTLY'
    | 'NON_FORK_STATES'
    | 'NON_REPEAT_STATES'
    | 'INITIAL_STATE_NOT_DEFINED'
    | 'FILE_INTEGRITY_CHECK_FAILED'
    | 'INVALID_URL'
    | 'FILE_DOWNLOAD_FAILED'
    | 'PLATFORM_SOFTWARE_DELETE_ERROR'
    | 'INVALID_CSV_FILE'
    | 'INVALID_REQUEST'
    | 'INVALID_INFRA_STATE'
    | 'PIPELINE_ALREADY_TRIGGERED'
    | 'NON_EXISTING_PIPELINE'
    | 'DUPLICATE_COMMAND_NAMES'
    | 'INVALID_PIPELINE'
    | 'COMMAND_DOES_NOT_EXIST'
    | 'DUPLICATE_ARTIFACTSTREAM_NAMES'
    | 'DUPLICATE_HOST_NAMES'
    | 'STATE_NOT_FOR_TYPE'
    | 'STATE_MACHINE_ISSUE'
    | 'STATE_DISCONTINUE_FAILED'
    | 'STATE_PAUSE_FAILED'
    | 'PAUSE_ALL_ALREADY'
    | 'RESUME_ALL_ALREADY'
    | 'ROLLBACK_ALREADY'
    | 'ABORT_ALL_ALREADY'
    | 'RETRY_FAILED'
    | 'UNKNOWN_ARTIFACT_TYPE'
    | 'INIT_TIMEOUT'
    | 'LICENSE_EXPIRED'
    | 'NOT_LICENSED'
    | 'REQUEST_TIMEOUT'
    | 'WORKFLOW_ALREADY_TRIGGERED'
    | 'JENKINS_ERROR'
    | 'INVALID_ARTIFACT_SOURCE'
    | 'INVALID_ARTIFACT_SERVER'
    | 'INVALID_CLOUD_PROVIDER'
    | 'UPDATE_NOT_ALLOWED'
    | 'DELETE_NOT_ALLOWED'
    | 'APPDYNAMICS_CONFIGURATION_ERROR'
    | 'APM_CONFIGURATION_ERROR'
    | 'SPLUNK_CONFIGURATION_ERROR'
    | 'ELK_CONFIGURATION_ERROR'
    | 'LOGZ_CONFIGURATION_ERROR'
    | 'SUMO_CONFIGURATION_ERROR'
    | 'INSTANA_CONFIGURATION_ERROR'
    | 'APPDYNAMICS_ERROR'
    | 'STACKDRIVER_ERROR'
    | 'STACKDRIVER_CONFIGURATION_ERROR'
    | 'NEWRELIC_CONFIGURATION_ERROR'
    | 'NEWRELIC_ERROR'
    | 'DYNA_TRACE_CONFIGURATION_ERROR'
    | 'DYNA_TRACE_ERROR'
    | 'CLOUDWATCH_ERROR'
    | 'CLOUDWATCH_CONFIGURATION_ERROR'
    | 'PROMETHEUS_CONFIGURATION_ERROR'
    | 'DATA_DOG_CONFIGURATION_ERROR'
    | 'SERVICE_GUARD_CONFIGURATION_ERROR'
    | 'ENCRYPTION_NOT_CONFIGURED'
    | 'UNAVAILABLE_DELEGATES'
    | 'WORKFLOW_EXECUTION_IN_PROGRESS'
    | 'PIPELINE_EXECUTION_IN_PROGRESS'
    | 'AWS_ACCESS_DENIED'
    | 'AWS_CLUSTER_NOT_FOUND'
    | 'AWS_SERVICE_NOT_FOUND'
    | 'INVALID_YAML_PAYLOAD'
    | 'UNRECOGNIZED_YAML_FIELDS'
    | 'COULD_NOT_MAP_BEFORE_YAML'
    | 'MISSING_BEFORE_YAML'
    | 'MISSING_YAML'
    | 'NON_EMPTY_DELETIONS'
    | 'GENERAL_YAML_ERROR'
    | 'GENERAL_YAML_INFO'
    | 'YAML_GIT_SYNC_ERROR'
    | 'GIT_CONNECTION_ERROR'
    | 'GIT_ERROR'
    | 'ARTIFACT_SERVER_ERROR'
    | 'ENCRYPT_DECRYPT_ERROR'
    | 'SECRET_MANAGEMENT_ERROR'
    | 'KMS_OPERATION_ERROR'
    | 'GCP_KMS_OPERATION_ERROR'
    | 'VAULT_OPERATION_ERROR'
    | 'AWS_SECRETS_MANAGER_OPERATION_ERROR'
    | 'AZURE_KEY_VAULT_OPERATION_ERROR'
    | 'CYBERARK_OPERATION_ERROR'
    | 'UNSUPPORTED_OPERATION_EXCEPTION'
    | 'FEATURE_UNAVAILABLE'
    | 'GENERAL_ERROR'
    | 'BASELINE_CONFIGURATION_ERROR'
    | 'SAML_IDP_CONFIGURATION_NOT_AVAILABLE'
    | 'INVALID_AUTHENTICATION_MECHANISM'
    | 'INVALID_SAML_CONFIGURATION'
    | 'INVALID_OAUTH_CONFIGURATION'
    | 'INVALID_LDAP_CONFIGURATION'
    | 'USER_GROUP_SYNC_FAILURE'
    | 'USER_GROUP_ALREADY_EXIST'
    | 'INVALID_TWO_FACTOR_AUTHENTICATION_CONFIGURATION'
    | 'EXPLANATION'
    | 'HINT'
    | 'NOT_WHITELISTED_IP'
    | 'INVALID_TOTP_TOKEN'
    | 'EMAIL_FAILED'
    | 'SSL_HANDSHAKE_FAILED'
    | 'NO_APPS_ASSIGNED'
    | 'INVALID_INFRA_CONFIGURATION'
    | 'TEMPLATES_LINKED'
    | 'USER_HAS_NO_PERMISSIONS'
    | 'USER_NOT_AUTHORIZED'
    | 'USER_ALREADY_PRESENT'
    | 'INVALID_USAGE_RESTRICTION'
    | 'USAGE_RESTRICTION_ERROR'
    | 'STATE_EXECUTION_INSTANCE_NOT_FOUND'
    | 'DELEGATE_TASK_RETRY'
    | 'KUBERNETES_YAML_ERROR'
    | 'SAVE_FILE_INTO_GCP_STORAGE_FAILED'
    | 'READ_FILE_FROM_GCP_STORAGE_FAILED'
    | 'USAGE_LIMITS_EXCEEDED'
    | 'EVENT_PUBLISH_FAILED'
    | 'JIRA_ERROR'
    | 'EXPRESSION_EVALUATION_FAILED'
    | 'KUBERNETES_VALUES_ERROR'
    | 'KUBERNETES_CLUSTER_ERROR'
    | 'INCORRECT_SIGN_IN_MECHANISM'
    | 'OAUTH_LOGIN_FAILED'
    | 'INVALID_TERRAFORM_TARGETS_REQUEST'
    | 'FILE_READ_FAILED'
    | 'FILE_SIZE_EXCEEDS_LIMIT'
    | 'CLUSTER_NOT_FOUND'
    | 'MARKETPLACE_TOKEN_NOT_FOUND'
    | 'INVALID_MARKETPLACE_TOKEN'
    | 'INVALID_TICKETING_SERVER'
    | 'SERVICENOW_ERROR'
    | 'PASSWORD_EXPIRED'
    | 'USER_LOCKED'
    | 'PASSWORD_STRENGTH_CHECK_FAILED'
    | 'ACCOUNT_DISABLED'
    | 'INVALID_ACCOUNT_PERMISSION'
    | 'PAGERDUTY_ERROR'
    | 'HEALTH_ERROR'
    | 'SAML_TEST_SUCCESS_MECHANISM_NOT_ENABLED'
    | 'DOMAIN_WHITELIST_FILTER_CHECK_FAILED'
    | 'INVALID_DASHBOARD_UPDATE_REQUEST'
    | 'DUPLICATE_FIELD'
    | 'INVALID_AZURE_VAULT_CONFIGURATION'
    | 'USER_NOT_AUTHORIZED_DUE_TO_USAGE_RESTRICTIONS'
    | 'INVALID_ROLLBACK'
    | 'SUMO_DATA_COLLECTION_ERROR'
    | 'DEPLOYMENT_GOVERNANCE_ERROR'
    | 'BATCH_PROCESSING_ERROR'
    | 'GRAPHQL_ERROR'
    | 'FILE_CREATE_ERROR'
    | 'ILLEGAL_STATE'
    | 'GIT_DIFF_COMMIT_NOT_IN_ORDER'
    | 'FAILED_TO_ACQUIRE_PERSISTENT_LOCK'
    | 'FAILED_TO_ACQUIRE_NON_PERSISTENT_LOCK'
    | 'POD_NOT_FOUND_ERROR'
    | 'COMMAND_EXECUTION_ERROR'
    | 'REGISTRY_EXCEPTION'
    | 'ENGINE_INTERRUPT_PROCESSING_EXCEPTION'
    | 'ENGINE_IO_EXCEPTION'
    | 'ENGINE_OUTCOME_EXCEPTION'
    | 'ENGINE_SWEEPING_OUTPUT_EXCEPTION'
    | 'CACHE_NOT_FOUND_EXCEPTION'
    | 'ENGINE_ENTITY_UPDATE_EXCEPTION'
    | 'SHELL_EXECUTION_EXCEPTION'
    | 'TEMPLATE_NOT_FOUND'
    | 'AZURE_SERVICE_EXCEPTION'
    | 'GIT_UNSEEN_REMOTE_HEAD_COMMIT'
    | 'TIMEOUT_ENGINE_EXCEPTION'
    | 'NO_AVAILABLE_DELEGATES'
    | 'NO_INSTALLED_DELEGATES'
    | 'DUPLICATE_DELEGATE_EXCEPTION'
    | 'GCP_MARKETPLACE_EXCEPTION'
    | 'MISSING_DEFAULT_GOOGLE_CREDENTIALS'
    | 'INCORRECT_DEFAULT_GOOGLE_CREDENTIALS'
  level?: 'INFO' | 'ERROR'
  message?: string
  exception?: Throwable
}

export interface RestResponse {
  metaData?: {
    [key: string]: { [key: string]: any }
  }
  resource?: { [key: string]: any }
  responseMessages?: ResponseMessage[]
}

export interface RestResponseString {
  metaData?: {
    [key: string]: { [key: string]: any }
  }
  resource?: string
  responseMessages?: ResponseMessage[]
}

export interface StackTraceElement {
  methodName?: string
  fileName?: string
  lineNumber?: number
  className?: string
  nativeMethod?: boolean
}

export interface Throwable {
  cause?: Throwable
  stackTrace?: StackTraceElement[]
  message?: string
  localizedMessage?: string
  suppressed?: Throwable[]
}

export interface RestResponseBoolean {
  metaData?: {
    [key: string]: { [key: string]: any }
  }
  resource?: boolean
  responseMessages?: ResponseMessage[]
}

export interface SecretFileDTO {
  account: string
  org: string
  project?: string
  identifier: string
  secretManager: string
  name: string
  tags: string[]
  description?: string
  type: 'SecretFile' | 'SecretText' | 'SSHKey'
}

export interface EncryptedDataDTO {
  type?: 'SecretFile' | 'SecretText' | 'SSHKey'
  valueType?: 'Inline' | 'Reference'
  value?: string
  draft?: boolean
  account?: string
  org?: string
  project?: string
  identifier?: string
  secretManager?: string
  secretManagerName?: string
  name?: string
  encryptionType?: 'LOCAL' | 'KMS' | 'GCP_KMS' | 'AWS_SECRETS_MANAGER' | 'AZURE_VAULT' | 'CYBERARK' | 'VAULT' | 'CUSTOM'
  tags?: string[]
  lastUpdatedAt?: number
  description?: string
}

export interface ResponseDTOEncryptedDataDTO {
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
  data?: EncryptedDataDTO
  metaData?: { [key: string]: any }
  correlationId?: string
}

export type GcpKmsConfigDTO = SecretManagerConfigDTO & {
  projectId?: string
  region?: string
  keyRing?: string
  keyName?: string
  credentials?: string[]
}

export type LocalConfigDTO = SecretManagerConfigDTO & {}

export interface ResponseDTOSecretManagerConfigDTO {
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
  data?: SecretManagerConfigDTO
  metaData?: { [key: string]: any }
  correlationId?: string
}

export interface SecretManagerConfigDTO {
  name?: string
  accountIdentifier?: string
  orgIdentifier?: string
  projectIdentifier?: string
  tags?: string[]
  identifier?: string
  description?: string
  encryptionType?: 'LOCAL' | 'KMS' | 'GCP_KMS' | 'AWS_SECRETS_MANAGER' | 'AZURE_VAULT' | 'CYBERARK' | 'VAULT' | 'CUSTOM'
  default?: boolean
}

export type VaultConfigDTO = SecretManagerConfigDTO & {
  authToken?: string
  basePath?: string
  vaultUrl?: string
  renewIntervalHours?: number
  secretEngineName?: string
  appRoleId?: string
  secretId?: string
  secretEngineVersion?: number
  readOnly?: boolean
}

export type GcpKmsConfigUpdateDTO = SecretManagerConfigUpdateDTO & {
  projectId?: string
  region?: string
  keyRing?: string
  keyName?: string
  credentials?: string[]
}

export interface SecretManagerConfigUpdateDTO {
  tags?: string[]
  encryptionType?: 'LOCAL' | 'KMS' | 'GCP_KMS' | 'AWS_SECRETS_MANAGER' | 'AZURE_VAULT' | 'CYBERARK' | 'VAULT' | 'CUSTOM'
  description?: string
  default?: boolean
}

export type VaultConfigUpdateDTO = SecretManagerConfigUpdateDTO & {
  authToken?: string
  basePath?: string
  vaultUrl?: string
  renewIntervalHours?: number
  secretEngineName?: string
  secretEngineVersion?: number
  appRoleId?: string
  secretId?: string
  readOnly?: boolean
}

export interface ResponseDTOListSecretManagerConfigDTO {
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
  data?: SecretManagerConfigDTO[]
  metaData?: { [key: string]: any }
  correlationId?: string
}

export interface SecretTextDTO {
  account?: string
  org?: string
  project?: string
  identifier?: string
  secretManager?: string
  name?: string
  tags?: string[]
  description?: string
  type: 'SecretFile' | 'SecretText' | 'SSHKey'
  valueType: 'Inline' | 'Reference'
  value?: string
}

export interface NGPageResponseEncryptedDataDTO {
  pageCount?: number
  itemCount?: number
  pageSize?: number
  content?: EncryptedDataDTO[]
  pageIndex?: number
  empty?: boolean
}

export interface ResponseDTONGPageResponseEncryptedDataDTO {
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
  data?: NGPageResponseEncryptedDataDTO
  metaData?: { [key: string]: any }
  correlationId?: string
}

export interface BaseSSHSpecDTO {
  [key: string]: any
}

export type KerberosConfigDTO = BaseSSHSpecDTO & {
  principal: string
  realm: string
  tgtGenerationMethod: 'KeyTabFilePath' | 'Password' | 'None'
  spec?: TGTGenerationSpecDTO
}

export type SSHConfigDTO = BaseSSHSpecDTO & {
  credentialType: 'Password' | 'KeyPath' | 'KeyReference'
  spec: SSHCredentialSpecDTO
}

export interface SSHCredentialSpecDTO {
  [key: string]: any
}

export type SSHKeyPathCredentialDTO = SSHCredentialSpecDTO & {
  userName: string
  keyPath: string
  encryptedPassphrase?: string
}

export type SSHKeyReferenceCredentialDTO = SSHCredentialSpecDTO & {
  userName: string
  key?: string
  encryptedPassphrase?: string
}

export type SSHKeySpecDTO = SecretSpecDTO & {
  authScheme: 'SSH' | 'Kerberos'
  port?: number
  spec: BaseSSHSpecDTO
}

export type SSHPasswordCredentialDTO = SSHCredentialSpecDTO & {
  userName: string
  password: string
}

export interface SecretDTOV2 {
  type: 'SecretFile' | 'SecretText' | 'SSHKey'
  name: string
  description?: string
  identifier: string
  orgIdentifier?: string
  projectIdentifier?: string
  tags: {
    [key: string]: string
  }
  spec: SecretSpecDTO
}

export type SecretFileSpecDTO = SecretSpecDTO & {
  secretManagerIdentifier: string
  draft?: boolean
}

export interface SecretRequestWrapper {
  secret: SecretDTOV2
}

export interface SecretSpecDTO {
  validYaml?: boolean
}

export type SecretTextSpecDTO = SecretSpecDTO & {
  secretManagerIdentifier: string
  valueType: 'Inline' | 'Reference'
  value?: string
  draft?: boolean
}

export interface TGTGenerationSpecDTO {
  [key: string]: any
}

export type TGTKeyTabFilePathSpecDTO = TGTGenerationSpecDTO & {
  keyPath?: string
}

export type TGTPasswordSpecDTO = TGTGenerationSpecDTO & {
  password?: string
}

export interface ResponseDTOSecretResponseWrapper {
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
  data?: SecretResponseWrapper
  metaData?: { [key: string]: any }
  correlationId?: string
}

export interface SecretResponseWrapper {
  secret: SecretDTOV2
  createdAt?: number
  updatedAt?: number
}

export interface NGPageResponseSecretResponseWrapper {
  pageCount?: number
  itemCount?: number
  pageSize?: number
  content?: SecretResponseWrapper[]
  pageIndex?: number
  empty?: boolean
}

export interface ResponseDTONGPageResponseSecretResponseWrapper {
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
  data?: NGPageResponseSecretResponseWrapper
  metaData?: { [key: string]: any }
  correlationId?: string
}

export interface ResponseDTOSecretValidationResultDTO {
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
  data?: SecretValidationResultDTO
  metaData?: { [key: string]: any }
  correlationId?: string
}

export interface SecretValidationResultDTO {
  success?: boolean
  message?: string
}

export type SSHKeyValidationMetadata = SecretValidationMetaData & {
  host?: string
}

export interface SecretValidationMetaData {
  type?: 'SecretFile' | 'SecretText' | 'SSHKey'
}

export interface Organization {
  accountIdentifier?: string
  identifier?: string
  name?: string
  color?: string
  description?: string
  tags?: string[]
  lastModifiedAt?: number
  version?: number
}

export interface ResponseDTOOrganization {
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
  data?: Organization
  metaData?: { [key: string]: any }
  correlationId?: string
}

export interface NGPageResponseOrganization {
  pageCount?: number
  itemCount?: number
  pageSize?: number
  content?: Organization[]
  pageIndex?: number
  empty?: boolean
}

export interface ResponseDTONGPageResponseOrganization {
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
  data?: NGPageResponseOrganization
  metaData?: { [key: string]: any }
  correlationId?: string
}

export interface Project {
  accountIdentifier?: string
  orgIdentifier?: string
  identifier?: string
  name?: string
  color?: string
  modules?: ('CD' | 'CI' | 'CORE' | 'CV' | 'CF' | 'CE')[]
  description?: string
  owners?: string[]
  tags?: string[]
  lastModifiedAt?: number
  version?: number
}

export interface ResponseDTOProject {
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
  data?: Project
  metaData?: { [key: string]: any }
  correlationId?: string
}

export interface NGPageResponseProject {
  pageCount?: number
  itemCount?: number
  pageSize?: number
  content?: Project[]
  pageIndex?: number
  empty?: boolean
}

export interface ResponseDTONGPageResponseProject {
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
  data?: NGPageResponseProject
  metaData?: { [key: string]: any }
  correlationId?: string
}

export interface ResponseDTOServiceResponseDTO {
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
  data?: ServiceResponseDTO
  metaData?: { [key: string]: any }
  correlationId?: string
}

export interface ServiceResponseDTO {
  accountId?: string
  identifier?: string
  orgIdentifier?: string
  projectIdentifier?: string
  name?: string
  description?: string
  deleted?: boolean
}

export interface ServiceRequestDTO {
  identifier: string
  orgIdentifier: string
  projectIdentifier: string
  name?: string
  description?: string
}

export interface NGPageResponseServiceResponseDTO {
  pageCount?: number
  itemCount?: number
  pageSize?: number
  content?: ServiceResponseDTO[]
  pageIndex?: number
  empty?: boolean
}

export interface ResponseDTONGPageResponseServiceResponseDTO {
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
  data?: NGPageResponseServiceResponseDTO
  metaData?: { [key: string]: any }
  correlationId?: string
}

export interface NGPageResponseUserSearchDTO {
  pageCount?: number
  itemCount?: number
  pageSize?: number
  content?: UserSearchDTO[]
  pageIndex?: number
  empty?: boolean
}

export interface ResponseDTONGPageResponseUserSearchDTO {
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
  data?: NGPageResponseUserSearchDTO
  metaData?: { [key: string]: any }
  correlationId?: string
}

export interface UserSearchDTO {
  name: string
  email: string
  uuid: string
}

export interface Artifact {
  identifier: string
  artifactStream: ArtifactStream
}

export interface ArtifactStream {
  type: string
}

export type CDStageExecutionDTO = StageExecutionDTO & {
  planExecutionId?: string
  stageIdentifier?: string
  stageName?: string
  artifactsDeployed?: Artifact[]
  deploymentType?: 'Ssh' | 'Kubernetes' | 'Ecs' | 'Helm' | 'Pcf'
  pipelineExecutionStatus?: 'RUNNING' | 'FAILED' | 'SUCCESS'
  startedAt?: number
  endedAt?: number
  serviceIdentifier?: string
  envIdentifier?: string
  errorMsg?: string
}

export type ParallelStageExecutionDTO = StageExecutionDTO & {
  stageExecutions?: StageExecutionDTO[]
}

export interface PipelineExecutionDTO {
  pipelineIdentifier?: string
  pipelineName?: string
  planExecutionId?: string
  pipelineExecutionStatus?: 'RUNNING' | 'FAILED' | 'SUCCESS'
  startedAt?: number
  endedAt?: number
  triggeredBy?: User
  triggerType?: 'MANUAL' | 'WEBHOOK'
  tags?: Tag[]
  stageExecutionSummaryElements?: StageExecutionDTO[]
  errorMsg?: string
  stageIdentifiers?: string[]
  serviceIdentifiers?: string[]
  envIdentifiers?: string[]
  serviceDefinitionTypes?: ('Ssh' | 'Kubernetes' | 'Ecs' | 'Helm' | 'Pcf')[]
  stageTypes?: StageType[]
  successfulStagesCount?: number
  runningStagesCount?: number
  failedStagesCount?: number
}

export interface ResponseDTOListPipelineExecutionDTO {
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
  data?: PipelineExecutionDTO[]
  metaData?: { [key: string]: any }
  correlationId?: string
}

export interface StageExecutionDTO {
  [key: string]: any
}

export interface User {
  uuid?: string
  name?: string
  email?: string
}

export interface ExecutionGraph {
  rootNodeId?: string
  nodeMap?: {
    [key: string]: ExecutionNode
  }
  nodeAdjacencyListMap?: {
    [key: string]: ExecutionNodeAdjacencyList
  }
}

export interface ExecutionNode {
  uuid?: string
  name?: string
  startTs?: number
  endTs?: number
  stepType?: string
  status?: 'RUNNING' | 'FAILED' | 'SUCCESS'
  failureInfo?: FailureInfo
}

export interface ExecutionNodeAdjacencyList {
  children?: string[]
  next?: string
}

export interface FailureInfo {
  errorMessage?: string
  failureTypes?: (
    | 'EXPIRED'
    | 'DELEGATE_PROVISIONING'
    | 'CONNECTIVITY'
    | 'AUTHENTICATION'
    | 'VERIFICATION_FAILURE'
    | 'APPLICATION_ERROR'
  )[]
}

export interface PipelineExecutionDetail {
  pipelineExecution?: PipelineExecutionDTO
  stageGraph?: ExecutionGraph
}

export interface ResponseDTOPipelineExecutionDetail {
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
  data?: PipelineExecutionDetail
  metaData?: { [key: string]: any }
  correlationId?: string
}

export interface Duration {
  seconds?: number
  zero?: boolean
  negative?: boolean
  units?: TemporalUnit[]
  nano?: number
}

export interface Graph {
  cacheContextOrder?: number
  cacheKey?: string
  cacheParams?: string[]
  planExecutionId?: string
  startTs?: number
  endTs?: number
  status?:
    | 'RUNNING'
    | 'INTERVENTION_WAITING'
    | 'TIMED_WAITING'
    | 'ASYNC_WAITING'
    | 'TASK_WAITING'
    | 'DISCONTINUING'
    | 'QUEUED'
    | 'SKIPPED'
    | 'PAUSED'
    | 'ABORTED'
    | 'ERRORED'
    | 'FAILED'
    | 'EXPIRED'
    | 'SUSPENDED'
    | 'SUCCEEDED'
  graphVertex?: GraphVertex
  lastUpdatedAt?: number
}

export interface GraphVertex {
  uuid?: string
  planNodeId?: string
  name?: string
  startTs?: number
  endTs?: number
  initialWaitDuration?: Duration
  lastUpdatedAt?: number
  stepType?: string
  status?:
    | 'RUNNING'
    | 'INTERVENTION_WAITING'
    | 'TIMED_WAITING'
    | 'ASYNC_WAITING'
    | 'TASK_WAITING'
    | 'DISCONTINUING'
    | 'QUEUED'
    | 'SKIPPED'
    | 'PAUSED'
    | 'ABORTED'
    | 'ERRORED'
    | 'FAILED'
    | 'EXPIRED'
    | 'SUSPENDED'
    | 'SUCCEEDED'
  failureInfo?: FailureInfo
  stepParameters?: StepParameters
  mode?:
    | 'SYNC'
    | 'ASYNC'
    | 'SKIP'
    | 'TASK_CHAIN'
    | 'TASK_CHAIN_V2'
    | 'TASK_CHAIN_V3'
    | 'TASK'
    | 'TASK_V2'
    | 'TASK_V3'
    | 'CHILD_CHAIN'
    | 'CHILDREN'
    | 'CHILD'
  interruptHistories?: InterruptEffect[]
  outcomes?: Outcome[]
  retryIds?: string[]
  subgraph?: Subgraph
  next?: GraphVertex
}

export interface InterruptEffect {
  interruptId: string
  tookEffectAt: number
  interruptType:
    | 'ABORT'
    | 'ABORT_ALL'
    | 'PAUSE'
    | 'PAUSE_ALL'
    | 'RESUME'
    | 'RESUME_ALL'
    | 'RETRY'
    | 'IGNORE'
    | 'MARK_FAILED'
    | 'MARK_SUCCESS'
    | 'ROLLBACK'
    | 'NEXT_STEP'
    | 'END_EXECUTION'
    | 'ROLLBACK_DONE'
    | 'MARK_EXPIRED'
}

export interface Outcome {
  refType?: RefType
}

export interface RefType {
  type?: string
}

export interface RestResponseGraph {
  metaData?: {
    [key: string]: { [key: string]: any }
  }
  resource?: Graph
  responseMessages?: ResponseMessage[]
}

export interface StepParameters {
  [key: string]: any
}

export interface Subgraph {
  mode?:
    | 'SYNC'
    | 'ASYNC'
    | 'SKIP'
    | 'TASK_CHAIN'
    | 'TASK_CHAIN_V2'
    | 'TASK_CHAIN_V3'
    | 'TASK'
    | 'TASK_V2'
    | 'TASK_V3'
    | 'CHILD_CHAIN'
    | 'CHILDREN'
    | 'CHILD'
  vertices?: GraphVertex[]
}

export interface TemporalUnit {
  timeBased?: boolean
  duration?: Duration
  dateBased?: boolean
  durationEstimated?: boolean
}

export interface StreamingOutput {
  [key: string]: any
}

export interface PlanExecution {
  uuid?: string
  createdAt?: number
  setupAbstractions?: {
    [key: string]: string
  }
  validUntil?: string
  status?:
    | 'RUNNING'
    | 'INTERVENTION_WAITING'
    | 'TIMED_WAITING'
    | 'ASYNC_WAITING'
    | 'TASK_WAITING'
    | 'DISCONTINUING'
    | 'QUEUED'
    | 'SKIPPED'
    | 'PAUSED'
    | 'ABORTED'
    | 'ERRORED'
    | 'FAILED'
    | 'EXPIRED'
    | 'SUSPENDED'
    | 'SUCCEEDED'
  startTs?: number
  endTs?: number
  lastUpdatedAt?: number
  version?: number
}

export interface RestResponsePlanExecution {
  metaData?: {
    [key: string]: { [key: string]: any }
  }
  resource?: PlanExecution
  responseMessages?: ResponseMessage[]
}

export interface ResponseDTOStepCategory {
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
  data?: StepCategory
  metaData?: { [key: string]: any }
  correlationId?: string
}

export interface StepCategory {
  name?: string
  stepsData?: StepData[]
  stepCategories?: StepCategory[]
}

export interface StepData {
  type?:
    | 'Placeholder'
    | 'Placeholder'
    | 'Placeholder'
    | 'K8sRollingDeploy'
    | 'K8sRollingRollback'
    | 'Placeholder'
    | 'Placeholder'
    | 'Placeholder'
    | 'Placeholder'
    | 'Placeholder'
    | 'Placeholder'
    | 'Placeholder'
    | 'Placeholder'
    | 'Placeholder'
    | 'Placeholder'
    | 'Placeholder'
    | 'Placeholder'
    | 'Placeholder'
    | 'ShellScript'
    | 'Http'
    | 'Placeholder'
    | 'Placeholder'
  name?: string
}

export interface ResponseDTOString {
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
  data?: string
  metaData?: { [key: string]: any }
  correlationId?: string
}

export interface ResponseDTOMapServiceDefinitionTypeListExecutionStrategyType {
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
  data?: {
    [key: string]: ('Basic' | 'Canary' | 'BlueGreen' | 'Rolling')[]
  }
  metaData?: { [key: string]: any }
  correlationId?: string
}

export interface ResponseDTOListServiceDefinitionType {
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
  data?: ('Ssh' | 'Kubernetes' | 'Ecs' | 'Helm' | 'Pcf')[]
  metaData?: { [key: string]: any }
  correlationId?: string
}

export interface CDPipelineValidationInfoDTO {
  pipelineYaml?: string
  uuidToErrorResponseMap?: {
    [key: string]: VisitorErrorResponseWrapper
  }
  errorResponse?: boolean
}

export interface ResponseDTOCDPipelineValidationInfoDTO {
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
  data?: CDPipelineValidationInfoDTO
  metaData?: { [key: string]: any }
  correlationId?: string
}

export interface VisitorErrorResponse {
  fieldName?: string
  message?: string
}

export interface VisitorErrorResponseWrapper {
  errors?: VisitorErrorResponse[]
}

export interface CDPipelineResponseDTO {
  cdPipeline?: CDPipeline
  executionsPlaceHolder?: string[]
  yamlPipeline?: string
}

export interface ResponseDTOCDPipelineResponseDTO {
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
  data?: CDPipelineResponseDTO
  metaData?: { [key: string]: any }
  correlationId?: string
}

export interface CDPipelineSummaryResponseDTO {
  name?: string
  identifier?: string
  description?: string
  tags?: Tag[]
}

export interface PageCDPipelineSummaryResponseDTO {
  totalPages?: number
  totalElements?: number
  size?: number
  content?: CDPipelineSummaryResponseDTO[]
  number?: number
  sort?: Sort
  first?: boolean
  numberOfElements?: number
  last?: boolean
  pageable?: Pageable
  empty?: boolean
}

export interface ResponseDTOPageCDPipelineSummaryResponseDTO {
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
  data?: PageCDPipelineSummaryResponseDTO
  metaData?: { [key: string]: any }
  correlationId?: string
}

export interface ResponseDTOPlanExecution {
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
  data?: PlanExecution
  metaData?: { [key: string]: any }
  correlationId?: string
}

export type SecretFileDTORequestBody = void

export type DockerRequestDTORequestBody = DockerRequestDTO

export type GitSyncConfigDTORequestBody = GitSyncConfigDTO

export type EnvironmentRequestDTORequestBody = EnvironmentRequestDTO

export type OrganizationRequestBody = Organization

export type ProjectRequestBody = Project

export type SecretTextDTORequestBody = void

export type ConnectorRequestBody = Connector

export type CDInputSetRequestBody = CDInputSet

export type OverlayInputSetRequestBody = OverlayInputSet

export type SecretTextDTO2RequestBody = SecretTextDTO

export type SecretRequestWrapperRequestBody = SecretRequestWrapper

export type SecretRequestWrapper2RequestBody = void

export type PutSecretFileV2RequestBody = void

export type ServiceRequestDTORequestBody = ServiceRequestDTO

export type PostPipelineBodyRequestBody = string

export interface GetTestConnectionResultQueryParams {
  accountIdentifier?: string
  orgIdentifier?: string
  projectIdentifier?: string
}

export interface GetTestConnectionResultPathParams {
  identifier: string
}

export type GetTestConnectionResultProps = Omit<
  MutateProps<
    ResponseDTOConnectorValidationResult,
    FailureDTO | ErrorDTO,
    GetTestConnectionResultQueryParams,
    void,
    GetTestConnectionResultPathParams
  >,
  'path' | 'verb'
> &
  GetTestConnectionResultPathParams

/**
 * Test the connection
 */
export const GetTestConnectionResult = ({ identifier, ...props }: GetTestConnectionResultProps) => (
  <Mutate<
    ResponseDTOConnectorValidationResult,
    FailureDTO | ErrorDTO,
    GetTestConnectionResultQueryParams,
    void,
    GetTestConnectionResultPathParams
  >
    verb="POST"
    path={`/connectors/testConnection/${identifier}`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetTestConnectionResultProps = Omit<
  UseMutateProps<
    ResponseDTOConnectorValidationResult,
    FailureDTO | ErrorDTO,
    GetTestConnectionResultQueryParams,
    void,
    GetTestConnectionResultPathParams
  >,
  'path' | 'verb'
> &
  GetTestConnectionResultPathParams

/**
 * Test the connection
 */
export const useGetTestConnectionResult = ({ identifier, ...props }: UseGetTestConnectionResultProps) =>
  useMutate<
    ResponseDTOConnectorValidationResult,
    FailureDTO | ErrorDTO,
    GetTestConnectionResultQueryParams,
    void,
    GetTestConnectionResultPathParams
  >(
    'POST',
    (paramsInPath: GetTestConnectionResultPathParams) => `/connectors/testConnection/${paramsInPath.identifier}`,
    { base: getConfig('ng/api'), pathParams: { identifier }, ...props }
  )

/**
 * Test the connection
 */
export const getTestConnectionResultPromise = (
  {
    identifier,
    ...props
  }: MutateUsingFetchProps<
    ResponseDTOConnectorValidationResult,
    FailureDTO | ErrorDTO,
    GetTestConnectionResultQueryParams,
    void,
    GetTestConnectionResultPathParams
  > & { identifier: string },
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseDTOConnectorValidationResult,
    FailureDTO | ErrorDTO,
    GetTestConnectionResultQueryParams,
    void,
    GetTestConnectionResultPathParams
  >('POST', getConfig('ng/api'), `/connectors/testConnection/${identifier}`, props, signal)

export interface GetConnectorQueryParams {
  accountIdentifier?: string
  orgIdentifier?: string
  projectIdentifier?: string
}

export interface GetConnectorPathParams {
  identifier: string
}

export type GetConnectorProps = Omit<
  GetProps<ResponseDTOConnectorResponse, FailureDTO | ErrorDTO, GetConnectorQueryParams, GetConnectorPathParams>,
  'path'
> &
  GetConnectorPathParams

/**
 * Get Connector
 */
export const GetConnector = ({ identifier, ...props }: GetConnectorProps) => (
  <Get<ResponseDTOConnectorResponse, FailureDTO | ErrorDTO, GetConnectorQueryParams, GetConnectorPathParams>
    path={`/connectors/${identifier}`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetConnectorProps = Omit<
  UseGetProps<ResponseDTOConnectorResponse, FailureDTO | ErrorDTO, GetConnectorQueryParams, GetConnectorPathParams>,
  'path'
> &
  GetConnectorPathParams

/**
 * Get Connector
 */
export const useGetConnector = ({ identifier, ...props }: UseGetConnectorProps) =>
  useGet<ResponseDTOConnectorResponse, FailureDTO | ErrorDTO, GetConnectorQueryParams, GetConnectorPathParams>(
    (paramsInPath: GetConnectorPathParams) => `/connectors/${paramsInPath.identifier}`,
    { base: getConfig('ng/api'), pathParams: { identifier }, ...props }
  )

/**
 * Get Connector
 */
export const getConnectorPromise = (
  {
    identifier,
    ...props
  }: GetUsingFetchProps<
    ResponseDTOConnectorResponse,
    FailureDTO | ErrorDTO,
    GetConnectorQueryParams,
    GetConnectorPathParams
  > & { identifier: string },
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseDTOConnectorResponse, FailureDTO | ErrorDTO, GetConnectorQueryParams, GetConnectorPathParams>(
    getConfig('ng/api'),
    `/connectors/${identifier}`,
    props,
    signal
  )

export interface DeleteConnectorQueryParams {
  accountIdentifier?: string
  orgIdentifier?: string
  projectIdentifier?: string
}

export type DeleteConnectorProps = Omit<
  MutateProps<ResponseDTOBoolean, FailureDTO | ErrorDTO, DeleteConnectorQueryParams, string, void>,
  'path' | 'verb'
>

/**
 * Delete a connector by identifier
 */
export const DeleteConnector = (props: DeleteConnectorProps) => (
  <Mutate<ResponseDTOBoolean, FailureDTO | ErrorDTO, DeleteConnectorQueryParams, string, void>
    verb="DELETE"
    path={`/connectors`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseDeleteConnectorProps = Omit<
  UseMutateProps<ResponseDTOBoolean, FailureDTO | ErrorDTO, DeleteConnectorQueryParams, string, void>,
  'path' | 'verb'
>

/**
 * Delete a connector by identifier
 */
export const useDeleteConnector = (props: UseDeleteConnectorProps) =>
  useMutate<ResponseDTOBoolean, FailureDTO | ErrorDTO, DeleteConnectorQueryParams, string, void>(
    'DELETE',
    `/connectors`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Delete a connector by identifier
 */
export const deleteConnectorPromise = (
  props: MutateUsingFetchProps<ResponseDTOBoolean, FailureDTO | ErrorDTO, DeleteConnectorQueryParams, string, void>,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<ResponseDTOBoolean, FailureDTO | ErrorDTO, DeleteConnectorQueryParams, string, void>(
    'DELETE',
    getConfig('ng/api'),
    `/connectors`,
    props,
    signal
  )

export interface GetConnectorListQueryParams {
  page?: number
  size?: number
  accountIdentifier?: string
  orgIdentifier?: string
  projectIdentifier?: string
  searchTerm?: string
  type?:
    | 'K8sCluster'
    | 'Git'
    | 'Splunk'
    | 'AppDynamics'
    | 'Vault'
    | 'DockerRegistry'
    | 'Local'
    | 'AwsKms'
    | 'GcpKms'
    | 'Awssecretsmanager'
    | 'Azurevault'
    | 'Cyberark'
    | 'CustomSecretManager'
    | 'Gcp'
    | 'Aws'
  category?: 'CLOUD_PROVIDER' | 'SECRET_MANAGER'
}

export type GetConnectorListProps = Omit<
  GetProps<ResponseDTONGPageResponseConnectorResponse, FailureDTO | ErrorDTO, GetConnectorListQueryParams, void>,
  'path'
>

/**
 * Gets Connector list
 */
export const GetConnectorList = (props: GetConnectorListProps) => (
  <Get<ResponseDTONGPageResponseConnectorResponse, FailureDTO | ErrorDTO, GetConnectorListQueryParams, void>
    path={`/connectors`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetConnectorListProps = Omit<
  UseGetProps<ResponseDTONGPageResponseConnectorResponse, FailureDTO | ErrorDTO, GetConnectorListQueryParams, void>,
  'path'
>

/**
 * Gets Connector list
 */
export const useGetConnectorList = (props: UseGetConnectorListProps) =>
  useGet<ResponseDTONGPageResponseConnectorResponse, FailureDTO | ErrorDTO, GetConnectorListQueryParams, void>(
    `/connectors`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Gets Connector list
 */
export const getConnectorListPromise = (
  props: GetUsingFetchProps<
    ResponseDTONGPageResponseConnectorResponse,
    FailureDTO | ErrorDTO,
    GetConnectorListQueryParams,
    void
  >,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseDTONGPageResponseConnectorResponse, FailureDTO | ErrorDTO, GetConnectorListQueryParams, void>(
    getConfig('ng/api'),
    `/connectors`,
    props,
    signal
  )

export interface CreateConnectorQueryParams {
  accountIdentifier?: string
}

export type CreateConnectorProps = Omit<
  MutateProps<
    ResponseDTOConnectorResponse,
    FailureDTO | ErrorDTO,
    CreateConnectorQueryParams,
    ConnectorRequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Creates a Connector
 */
export const CreateConnector = (props: CreateConnectorProps) => (
  <Mutate<ResponseDTOConnectorResponse, FailureDTO | ErrorDTO, CreateConnectorQueryParams, ConnectorRequestBody, void>
    verb="POST"
    path={`/connectors`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseCreateConnectorProps = Omit<
  UseMutateProps<
    ResponseDTOConnectorResponse,
    FailureDTO | ErrorDTO,
    CreateConnectorQueryParams,
    ConnectorRequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Creates a Connector
 */
export const useCreateConnector = (props: UseCreateConnectorProps) =>
  useMutate<
    ResponseDTOConnectorResponse,
    FailureDTO | ErrorDTO,
    CreateConnectorQueryParams,
    ConnectorRequestBody,
    void
  >('POST', `/connectors`, { base: getConfig('ng/api'), ...props })

/**
 * Creates a Connector
 */
export const createConnectorPromise = (
  props: MutateUsingFetchProps<
    ResponseDTOConnectorResponse,
    FailureDTO | ErrorDTO,
    CreateConnectorQueryParams,
    ConnectorRequestBody,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseDTOConnectorResponse,
    FailureDTO | ErrorDTO,
    CreateConnectorQueryParams,
    ConnectorRequestBody,
    void
  >('POST', getConfig('ng/api'), `/connectors`, props, signal)

export interface UpdateConnectorQueryParams {
  accountIdentifier?: string
}

export type UpdateConnectorProps = Omit<
  MutateProps<
    ResponseDTOConnectorResponse,
    FailureDTO | ErrorDTO,
    UpdateConnectorQueryParams,
    ConnectorRequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Updates a Connector
 */
export const UpdateConnector = (props: UpdateConnectorProps) => (
  <Mutate<ResponseDTOConnectorResponse, FailureDTO | ErrorDTO, UpdateConnectorQueryParams, ConnectorRequestBody, void>
    verb="PUT"
    path={`/connectors`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseUpdateConnectorProps = Omit<
  UseMutateProps<
    ResponseDTOConnectorResponse,
    FailureDTO | ErrorDTO,
    UpdateConnectorQueryParams,
    ConnectorRequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Updates a Connector
 */
export const useUpdateConnector = (props: UseUpdateConnectorProps) =>
  useMutate<
    ResponseDTOConnectorResponse,
    FailureDTO | ErrorDTO,
    UpdateConnectorQueryParams,
    ConnectorRequestBody,
    void
  >('PUT', `/connectors`, { base: getConfig('ng/api'), ...props })

/**
 * Updates a Connector
 */
export const updateConnectorPromise = (
  props: MutateUsingFetchProps<
    ResponseDTOConnectorResponse,
    FailureDTO | ErrorDTO,
    UpdateConnectorQueryParams,
    ConnectorRequestBody,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseDTOConnectorResponse,
    FailureDTO | ErrorDTO,
    UpdateConnectorQueryParams,
    ConnectorRequestBody,
    void
  >('PUT', getConfig('ng/api'), `/connectors`, props, signal)

export interface GetConnectorStatusQueryParams {
  accountIdentifier?: string
}

export type GetConnectorStatusProps = Omit<
  MutateProps<
    ResponseDTOConnectorValidationResult,
    FailureDTO | ErrorDTO,
    GetConnectorStatusQueryParams,
    ConnectorRequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Get the connectivity status of the Connector
 */
export const GetConnectorStatus = (props: GetConnectorStatusProps) => (
  <Mutate<
    ResponseDTOConnectorValidationResult,
    FailureDTO | ErrorDTO,
    GetConnectorStatusQueryParams,
    ConnectorRequestBody,
    void
  >
    verb="POST"
    path={`/connectors/validate`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetConnectorStatusProps = Omit<
  UseMutateProps<
    ResponseDTOConnectorValidationResult,
    FailureDTO | ErrorDTO,
    GetConnectorStatusQueryParams,
    ConnectorRequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Get the connectivity status of the Connector
 */
export const useGetConnectorStatus = (props: UseGetConnectorStatusProps) =>
  useMutate<
    ResponseDTOConnectorValidationResult,
    FailureDTO | ErrorDTO,
    GetConnectorStatusQueryParams,
    ConnectorRequestBody,
    void
  >('POST', `/connectors/validate`, { base: getConfig('ng/api'), ...props })

/**
 * Get the connectivity status of the Connector
 */
export const getConnectorStatusPromise = (
  props: MutateUsingFetchProps<
    ResponseDTOConnectorValidationResult,
    FailureDTO | ErrorDTO,
    GetConnectorStatusQueryParams,
    ConnectorRequestBody,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseDTOConnectorValidationResult,
    FailureDTO | ErrorDTO,
    GetConnectorStatusQueryParams,
    ConnectorRequestBody,
    void
  >('POST', getConfig('ng/api'), `/connectors/validate`, props, signal)

export interface ValidateTheIdentifierIsUniqueQueryParams {
  accountIdentifier?: string
  orgIdentifier?: string
  projectIdentifier?: string
  identifier?: string
}

export type ValidateTheIdentifierIsUniqueProps = Omit<
  GetProps<ResponseDTOBoolean, FailureDTO | ErrorDTO, ValidateTheIdentifierIsUniqueQueryParams, void>,
  'path'
>

/**
 * Validate Identifier is unique
 */
export const ValidateTheIdentifierIsUnique = (props: ValidateTheIdentifierIsUniqueProps) => (
  <Get<ResponseDTOBoolean, FailureDTO | ErrorDTO, ValidateTheIdentifierIsUniqueQueryParams, void>
    path={`/connectors/validateUniqueIdentifier`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseValidateTheIdentifierIsUniqueProps = Omit<
  UseGetProps<ResponseDTOBoolean, FailureDTO | ErrorDTO, ValidateTheIdentifierIsUniqueQueryParams, void>,
  'path'
>

/**
 * Validate Identifier is unique
 */
export const useValidateTheIdentifierIsUnique = (props: UseValidateTheIdentifierIsUniqueProps) =>
  useGet<ResponseDTOBoolean, FailureDTO | ErrorDTO, ValidateTheIdentifierIsUniqueQueryParams, void>(
    `/connectors/validateUniqueIdentifier`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Validate Identifier is unique
 */
export const validateTheIdentifierIsUniquePromise = (
  props: GetUsingFetchProps<ResponseDTOBoolean, FailureDTO | ErrorDTO, ValidateTheIdentifierIsUniqueQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseDTOBoolean, FailureDTO | ErrorDTO, ValidateTheIdentifierIsUniqueQueryParams, void>(
    getConfig('ng/api'),
    `/connectors/validateUniqueIdentifier`,
    props,
    signal
  )

export interface ListGitSyncEntitiesByProductQueryParams {
  projectId?: string
  organizationId?: string
  accountId?: string
  size?: number
  moduleType?: 'CD' | 'CI' | 'CORE' | 'CV' | 'CF' | 'CE'
}

export type ListGitSyncEntitiesByProductProps = Omit<
  GetProps<ResponseDTOGitSyncProductDTO, unknown, ListGitSyncEntitiesByProductQueryParams, void>,
  'path'
>

/**
 * List Git Sync Entity by product
 */
export const ListGitSyncEntitiesByProduct = (props: ListGitSyncEntitiesByProductProps) => (
  <Get<ResponseDTOGitSyncProductDTO, unknown, ListGitSyncEntitiesByProductQueryParams, void>
    path={`/git-sync-entities`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseListGitSyncEntitiesByProductProps = Omit<
  UseGetProps<ResponseDTOGitSyncProductDTO, unknown, ListGitSyncEntitiesByProductQueryParams, void>,
  'path'
>

/**
 * List Git Sync Entity by product
 */
export const useListGitSyncEntitiesByProduct = (props: UseListGitSyncEntitiesByProductProps) =>
  useGet<ResponseDTOGitSyncProductDTO, unknown, ListGitSyncEntitiesByProductQueryParams, void>(`/git-sync-entities`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * List Git Sync Entity by product
 */
export const listGitSyncEntitiesByProductPromise = (
  props: GetUsingFetchProps<ResponseDTOGitSyncProductDTO, unknown, ListGitSyncEntitiesByProductQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseDTOGitSyncProductDTO, unknown, ListGitSyncEntitiesByProductQueryParams, void>(
    getConfig('ng/api'),
    `/git-sync-entities`,
    props,
    signal
  )

export interface ListGitSyncEntitiesByTypeQueryParams {
  projectId?: string
  organizationId?: string
  accountId?: string
  page?: number
  size?: number
  moduleType?: string
}

export interface ListGitSyncEntitiesByTypePathParams {
  entityType: 'projects' | 'pipelines' | 'connectors' | 'secrets'
}

export type ListGitSyncEntitiesByTypeProps = Omit<
  GetProps<
    ResponseDTONGPageResponseGitSyncEntityListDTO,
    unknown,
    ListGitSyncEntitiesByTypeQueryParams,
    ListGitSyncEntitiesByTypePathParams
  >,
  'path'
> &
  ListGitSyncEntitiesByTypePathParams

/**
 * Get Git Sync Entity By Type
 */
export const ListGitSyncEntitiesByType = ({ entityType, ...props }: ListGitSyncEntitiesByTypeProps) => (
  <Get<
    ResponseDTONGPageResponseGitSyncEntityListDTO,
    unknown,
    ListGitSyncEntitiesByTypeQueryParams,
    ListGitSyncEntitiesByTypePathParams
  >
    path={`/git-sync-entities/entities/${entityType}`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseListGitSyncEntitiesByTypeProps = Omit<
  UseGetProps<
    ResponseDTONGPageResponseGitSyncEntityListDTO,
    unknown,
    ListGitSyncEntitiesByTypeQueryParams,
    ListGitSyncEntitiesByTypePathParams
  >,
  'path'
> &
  ListGitSyncEntitiesByTypePathParams

/**
 * Get Git Sync Entity By Type
 */
export const useListGitSyncEntitiesByType = ({ entityType, ...props }: UseListGitSyncEntitiesByTypeProps) =>
  useGet<
    ResponseDTONGPageResponseGitSyncEntityListDTO,
    unknown,
    ListGitSyncEntitiesByTypeQueryParams,
    ListGitSyncEntitiesByTypePathParams
  >((paramsInPath: ListGitSyncEntitiesByTypePathParams) => `/git-sync-entities/entities/${paramsInPath.entityType}`, {
    base: getConfig('ng/api'),
    pathParams: { entityType },
    ...props
  })

/**
 * Get Git Sync Entity By Type
 */
export const listGitSyncEntitiesByTypePromise = (
  {
    entityType,
    ...props
  }: GetUsingFetchProps<
    ResponseDTONGPageResponseGitSyncEntityListDTO,
    unknown,
    ListGitSyncEntitiesByTypeQueryParams,
    ListGitSyncEntitiesByTypePathParams
  > & { entityType: 'projects' | 'pipelines' | 'connectors' | 'secrets' },
  signal?: RequestInit['signal']
) =>
  getUsingFetch<
    ResponseDTONGPageResponseGitSyncEntityListDTO,
    unknown,
    ListGitSyncEntitiesByTypeQueryParams,
    ListGitSyncEntitiesByTypePathParams
  >(getConfig('ng/api'), `/git-sync-entities/entities/${entityType}`, props, signal)

export interface PutGitSyncQueryParams {
  projectId?: string
  organizationId?: string
  accountId?: string
}

export interface PutGitSyncPathParams {
  identifier: string
}

export type PutGitSyncProps = Omit<
  MutateProps<GitSyncConfigDTO, unknown, PutGitSyncQueryParams, GitSyncConfigDTORequestBody, PutGitSyncPathParams>,
  'path' | 'verb'
> &
  PutGitSyncPathParams

/**
 * Update Git Sync by id
 */
export const PutGitSync = ({ identifier, ...props }: PutGitSyncProps) => (
  <Mutate<GitSyncConfigDTO, unknown, PutGitSyncQueryParams, GitSyncConfigDTORequestBody, PutGitSyncPathParams>
    verb="PUT"
    path={`/git-sync/${identifier}`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UsePutGitSyncProps = Omit<
  UseMutateProps<GitSyncConfigDTO, unknown, PutGitSyncQueryParams, GitSyncConfigDTORequestBody, PutGitSyncPathParams>,
  'path' | 'verb'
> &
  PutGitSyncPathParams

/**
 * Update Git Sync by id
 */
export const usePutGitSync = ({ identifier, ...props }: UsePutGitSyncProps) =>
  useMutate<GitSyncConfigDTO, unknown, PutGitSyncQueryParams, GitSyncConfigDTORequestBody, PutGitSyncPathParams>(
    'PUT',
    (paramsInPath: PutGitSyncPathParams) => `/git-sync/${paramsInPath.identifier}`,
    { base: getConfig('ng/api'), pathParams: { identifier }, ...props }
  )

/**
 * Update Git Sync by id
 */
export const putGitSyncPromise = (
  {
    identifier,
    ...props
  }: MutateUsingFetchProps<
    GitSyncConfigDTO,
    unknown,
    PutGitSyncQueryParams,
    GitSyncConfigDTORequestBody,
    PutGitSyncPathParams
  > & { identifier: string },
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<GitSyncConfigDTO, unknown, PutGitSyncQueryParams, GitSyncConfigDTORequestBody, PutGitSyncPathParams>(
    'PUT',
    getConfig('ng/api'),
    `/git-sync/${identifier}`,
    props,
    signal
  )

export interface ListGitSyncQueryParams {
  projectId?: string
  organizationId?: string
  accountId?: string
}

export type ListGitSyncProps = Omit<GetProps<GitSyncConfigDTO[], unknown, ListGitSyncQueryParams, void>, 'path'>

/**
 * List Git Sync
 */
export const ListGitSync = (props: ListGitSyncProps) => (
  <Get<GitSyncConfigDTO[], unknown, ListGitSyncQueryParams, void>
    path={`/git-sync`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseListGitSyncProps = Omit<UseGetProps<GitSyncConfigDTO[], unknown, ListGitSyncQueryParams, void>, 'path'>

/**
 * List Git Sync
 */
export const useListGitSync = (props: UseListGitSyncProps) =>
  useGet<GitSyncConfigDTO[], unknown, ListGitSyncQueryParams, void>(`/git-sync`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * List Git Sync
 */
export const listGitSyncPromise = (
  props: GetUsingFetchProps<GitSyncConfigDTO[], unknown, ListGitSyncQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<GitSyncConfigDTO[], unknown, ListGitSyncQueryParams, void>(
    getConfig('ng/api'),
    `/git-sync`,
    props,
    signal
  )

export interface PostGitSyncQueryParams {
  projectId?: string
  organizationId?: string
  accountId?: string
}

export type PostGitSyncProps = Omit<
  MutateProps<GitSyncConfigDTO, unknown, PostGitSyncQueryParams, GitSyncConfigDTORequestBody, void>,
  'path' | 'verb'
>

/**
 * Create a Git Sync
 */
export const PostGitSync = (props: PostGitSyncProps) => (
  <Mutate<GitSyncConfigDTO, unknown, PostGitSyncQueryParams, GitSyncConfigDTORequestBody, void>
    verb="POST"
    path={`/git-sync`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UsePostGitSyncProps = Omit<
  UseMutateProps<GitSyncConfigDTO, unknown, PostGitSyncQueryParams, GitSyncConfigDTORequestBody, void>,
  'path' | 'verb'
>

/**
 * Create a Git Sync
 */
export const usePostGitSync = (props: UsePostGitSyncProps) =>
  useMutate<GitSyncConfigDTO, unknown, PostGitSyncQueryParams, GitSyncConfigDTORequestBody, void>('POST', `/git-sync`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * Create a Git Sync
 */
export const postGitSyncPromise = (
  props: MutateUsingFetchProps<GitSyncConfigDTO, unknown, PostGitSyncQueryParams, GitSyncConfigDTORequestBody, void>,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<GitSyncConfigDTO, unknown, PostGitSyncQueryParams, GitSyncConfigDTORequestBody, void>(
    'POST',
    getConfig('ng/api'),
    `/git-sync`,
    props,
    signal
  )

export interface PutGitSyncDefaultQueryParams {
  projectId?: string
  organizationId?: string
  accountId?: string
}

export interface PutGitSyncDefaultPathParams {
  identifier: string
  folderIdentifier: string
}

export type PutGitSyncDefaultProps = Omit<
  MutateProps<GitSyncConfigDTO[], unknown, PutGitSyncDefaultQueryParams, void, PutGitSyncDefaultPathParams>,
  'path' | 'verb'
> &
  PutGitSyncDefaultPathParams

/**
 * Update Git Sync default by id
 */
export const PutGitSyncDefault = ({ identifier, folderIdentifier, ...props }: PutGitSyncDefaultProps) => (
  <Mutate<GitSyncConfigDTO[], unknown, PutGitSyncDefaultQueryParams, void, PutGitSyncDefaultPathParams>
    verb="PUT"
    path={`/git-sync/${identifier}/folder/${folderIdentifier}/default`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UsePutGitSyncDefaultProps = Omit<
  UseMutateProps<GitSyncConfigDTO[], unknown, PutGitSyncDefaultQueryParams, void, PutGitSyncDefaultPathParams>,
  'path' | 'verb'
> &
  PutGitSyncDefaultPathParams

/**
 * Update Git Sync default by id
 */
export const usePutGitSyncDefault = ({ identifier, folderIdentifier, ...props }: UsePutGitSyncDefaultProps) =>
  useMutate<GitSyncConfigDTO[], unknown, PutGitSyncDefaultQueryParams, void, PutGitSyncDefaultPathParams>(
    'PUT',
    (paramsInPath: PutGitSyncDefaultPathParams) =>
      `/git-sync/${paramsInPath.identifier}/folder/${paramsInPath.folderIdentifier}/default`,
    { base: getConfig('ng/api'), pathParams: { identifier, folderIdentifier }, ...props }
  )

/**
 * Update Git Sync default by id
 */
export const putGitSyncDefaultPromise = (
  {
    identifier,
    folderIdentifier,
    ...props
  }: MutateUsingFetchProps<
    GitSyncConfigDTO[],
    unknown,
    PutGitSyncDefaultQueryParams,
    void,
    PutGitSyncDefaultPathParams
  > & { identifier: string; folderIdentifier: string },
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<GitSyncConfigDTO[], unknown, PutGitSyncDefaultQueryParams, void, PutGitSyncDefaultPathParams>(
    'PUT',
    getConfig('ng/api'),
    `/git-sync/${identifier}/folder/${folderIdentifier}/default`,
    props,
    signal
  )

export interface ListEntityUsageActivityQueryParams {
  page?: number
  size?: number
  accountIdentifier?: string
  orgIdentifier?: string
  projectIdentifier?: string
  identifier?: string
}

export type ListEntityUsageActivityProps = Omit<
  GetProps<ResponseDTOPageActivity, unknown, ListEntityUsageActivityQueryParams, void>,
  'path'
>

/**
 * Get Activities where this resource was used
 */
export const ListEntityUsageActivity = (props: ListEntityUsageActivityProps) => (
  <Get<ResponseDTOPageActivity, unknown, ListEntityUsageActivityQueryParams, void>
    path={`/activityHistory`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseListEntityUsageActivityProps = Omit<
  UseGetProps<ResponseDTOPageActivity, unknown, ListEntityUsageActivityQueryParams, void>,
  'path'
>

/**
 * Get Activities where this resource was used
 */
export const useListEntityUsageActivity = (props: UseListEntityUsageActivityProps) =>
  useGet<ResponseDTOPageActivity, unknown, ListEntityUsageActivityQueryParams, void>(`/activityHistory`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * Get Activities where this resource was used
 */
export const listEntityUsageActivityPromise = (
  props: GetUsingFetchProps<ResponseDTOPageActivity, unknown, ListEntityUsageActivityQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseDTOPageActivity, unknown, ListEntityUsageActivityQueryParams, void>(
    getConfig('ng/api'),
    `/activityHistory`,
    props,
    signal
  )

export type PostActivityProps = Omit<MutateProps<ResponseDTOActivity, unknown, void, Activity, void>, 'path' | 'verb'>

/**
 * Saves the activity
 */
export const PostActivity = (props: PostActivityProps) => (
  <Mutate<ResponseDTOActivity, unknown, void, Activity, void>
    verb="POST"
    path={`/activityHistory`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UsePostActivityProps = Omit<
  UseMutateProps<ResponseDTOActivity, unknown, void, Activity, void>,
  'path' | 'verb'
>

/**
 * Saves the activity
 */
export const usePostActivity = (props: UsePostActivityProps) =>
  useMutate<ResponseDTOActivity, unknown, void, Activity, void>('POST', `/activityHistory`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * Saves the activity
 */
export const postActivityPromise = (
  props: MutateUsingFetchProps<ResponseDTOActivity, unknown, void, Activity, void>,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<ResponseDTOActivity, unknown, void, Activity, void>(
    'POST',
    getConfig('ng/api'),
    `/activityHistory`,
    props,
    signal
  )

export interface ValidateArtifactServerForDockerQueryParams {
  dockerhubConnector?: string
  accountId?: string
  orgIdentifier?: string
  projectIdentifier?: string
}

export type ValidateArtifactServerForDockerProps = Omit<
  GetProps<ResponseDTOBoolean, FailureDTO | ErrorDTO, ValidateArtifactServerForDockerQueryParams, void>,
  'path'
>

/**
 * Validate docker artifact server
 */
export const ValidateArtifactServerForDocker = (props: ValidateArtifactServerForDockerProps) => (
  <Get<ResponseDTOBoolean, FailureDTO | ErrorDTO, ValidateArtifactServerForDockerQueryParams, void>
    path={`/artifacts/docker/validateArtifactServer`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseValidateArtifactServerForDockerProps = Omit<
  UseGetProps<ResponseDTOBoolean, FailureDTO | ErrorDTO, ValidateArtifactServerForDockerQueryParams, void>,
  'path'
>

/**
 * Validate docker artifact server
 */
export const useValidateArtifactServerForDocker = (props: UseValidateArtifactServerForDockerProps) =>
  useGet<ResponseDTOBoolean, FailureDTO | ErrorDTO, ValidateArtifactServerForDockerQueryParams, void>(
    `/artifacts/docker/validateArtifactServer`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Validate docker artifact server
 */
export const validateArtifactServerForDockerPromise = (
  props: GetUsingFetchProps<
    ResponseDTOBoolean,
    FailureDTO | ErrorDTO,
    ValidateArtifactServerForDockerQueryParams,
    void
  >,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseDTOBoolean, FailureDTO | ErrorDTO, ValidateArtifactServerForDockerQueryParams, void>(
    getConfig('ng/api'),
    `/artifacts/docker/validateArtifactServer`,
    props,
    signal
  )

export interface GetLastSuccessfulBuildForDockerQueryParams {
  imagePath?: string
  dockerhubConnector?: string
  accountId?: string
  orgIdentifier?: string
  projectIdentifier?: string
}

export type GetLastSuccessfulBuildForDockerProps = Omit<
  GetProps<ResponseDTODockerBuildDetailsDTO, FailureDTO | ErrorDTO, GetLastSuccessfulBuildForDockerQueryParams, void>,
  'path'
>

/**
 * Gets docker last successful build
 */
export const GetLastSuccessfulBuildForDocker = (props: GetLastSuccessfulBuildForDockerProps) => (
  <Get<ResponseDTODockerBuildDetailsDTO, FailureDTO | ErrorDTO, GetLastSuccessfulBuildForDockerQueryParams, void>
    path={`/artifacts/docker/getLastSuccessfulBuild`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetLastSuccessfulBuildForDockerProps = Omit<
  UseGetProps<
    ResponseDTODockerBuildDetailsDTO,
    FailureDTO | ErrorDTO,
    GetLastSuccessfulBuildForDockerQueryParams,
    void
  >,
  'path'
>

/**
 * Gets docker last successful build
 */
export const useGetLastSuccessfulBuildForDocker = (props: UseGetLastSuccessfulBuildForDockerProps) =>
  useGet<ResponseDTODockerBuildDetailsDTO, FailureDTO | ErrorDTO, GetLastSuccessfulBuildForDockerQueryParams, void>(
    `/artifacts/docker/getLastSuccessfulBuild`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Gets docker last successful build
 */
export const getLastSuccessfulBuildForDockerPromise = (
  props: GetUsingFetchProps<
    ResponseDTODockerBuildDetailsDTO,
    FailureDTO | ErrorDTO,
    GetLastSuccessfulBuildForDockerQueryParams,
    void
  >,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<
    ResponseDTODockerBuildDetailsDTO,
    FailureDTO | ErrorDTO,
    GetLastSuccessfulBuildForDockerQueryParams,
    void
  >(getConfig('ng/api'), `/artifacts/docker/getLastSuccessfulBuild`, props, signal)

export interface GetLabelsForDockerQueryParams {
  imagePath?: string
  dockerhubConnector?: string
  accountId?: string
  orgIdentifier?: string
  projectIdentifier?: string
}

export type GetLabelsForDockerProps = Omit<
  GetProps<ResponseDTODockerResponseDTO, FailureDTO | ErrorDTO, GetLabelsForDockerQueryParams, void>,
  'path'
>

/**
 * Gets docker labels
 */
export const GetLabelsForDocker = (props: GetLabelsForDockerProps) => (
  <Get<ResponseDTODockerResponseDTO, FailureDTO | ErrorDTO, GetLabelsForDockerQueryParams, void>
    path={`/artifacts/docker/getLabels`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetLabelsForDockerProps = Omit<
  UseGetProps<ResponseDTODockerResponseDTO, FailureDTO | ErrorDTO, GetLabelsForDockerQueryParams, void>,
  'path'
>

/**
 * Gets docker labels
 */
export const useGetLabelsForDocker = (props: UseGetLabelsForDockerProps) =>
  useGet<ResponseDTODockerResponseDTO, FailureDTO | ErrorDTO, GetLabelsForDockerQueryParams, void>(
    `/artifacts/docker/getLabels`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Gets docker labels
 */
export const getLabelsForDockerPromise = (
  props: GetUsingFetchProps<ResponseDTODockerResponseDTO, FailureDTO | ErrorDTO, GetLabelsForDockerQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseDTODockerResponseDTO, FailureDTO | ErrorDTO, GetLabelsForDockerQueryParams, void>(
    getConfig('ng/api'),
    `/artifacts/docker/getLabels`,
    props,
    signal
  )

export interface ValidateArtifactImageForDockerQueryParams {
  imagePath?: string
  dockerhubConnector?: string
  accountId?: string
  orgIdentifier?: string
  projectIdentifier?: string
}

export type ValidateArtifactImageForDockerProps = Omit<
  GetProps<ResponseDTOBoolean, FailureDTO | ErrorDTO, ValidateArtifactImageForDockerQueryParams, void>,
  'path'
>

/**
 * Validate docker image
 */
export const ValidateArtifactImageForDocker = (props: ValidateArtifactImageForDockerProps) => (
  <Get<ResponseDTOBoolean, FailureDTO | ErrorDTO, ValidateArtifactImageForDockerQueryParams, void>
    path={`/artifacts/docker/validateArtifactSource`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseValidateArtifactImageForDockerProps = Omit<
  UseGetProps<ResponseDTOBoolean, FailureDTO | ErrorDTO, ValidateArtifactImageForDockerQueryParams, void>,
  'path'
>

/**
 * Validate docker image
 */
export const useValidateArtifactImageForDocker = (props: UseValidateArtifactImageForDockerProps) =>
  useGet<ResponseDTOBoolean, FailureDTO | ErrorDTO, ValidateArtifactImageForDockerQueryParams, void>(
    `/artifacts/docker/validateArtifactSource`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Validate docker image
 */
export const validateArtifactImageForDockerPromise = (
  props: GetUsingFetchProps<ResponseDTOBoolean, FailureDTO | ErrorDTO, ValidateArtifactImageForDockerQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseDTOBoolean, FailureDTO | ErrorDTO, ValidateArtifactImageForDockerQueryParams, void>(
    getConfig('ng/api'),
    `/artifacts/docker/validateArtifactSource`,
    props,
    signal
  )

export interface GetBuildDetailsForDockerQueryParams {
  imagePath?: string
  dockerhubConnector?: string
  accountId?: string
  orgIdentifier?: string
  projectIdentifier?: string
}

export type GetBuildDetailsForDockerProps = Omit<
  GetProps<ResponseDTODockerResponseDTO, FailureDTO | ErrorDTO, GetBuildDetailsForDockerQueryParams, void>,
  'path'
>

/**
 * Gets docker build details
 */
export const GetBuildDetailsForDocker = (props: GetBuildDetailsForDockerProps) => (
  <Get<ResponseDTODockerResponseDTO, FailureDTO | ErrorDTO, GetBuildDetailsForDockerQueryParams, void>
    path={`/artifacts/docker/getBuildDetails`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetBuildDetailsForDockerProps = Omit<
  UseGetProps<ResponseDTODockerResponseDTO, FailureDTO | ErrorDTO, GetBuildDetailsForDockerQueryParams, void>,
  'path'
>

/**
 * Gets docker build details
 */
export const useGetBuildDetailsForDocker = (props: UseGetBuildDetailsForDockerProps) =>
  useGet<ResponseDTODockerResponseDTO, FailureDTO | ErrorDTO, GetBuildDetailsForDockerQueryParams, void>(
    `/artifacts/docker/getBuildDetails`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Gets docker build details
 */
export const getBuildDetailsForDockerPromise = (
  props: GetUsingFetchProps<
    ResponseDTODockerResponseDTO,
    FailureDTO | ErrorDTO,
    GetBuildDetailsForDockerQueryParams,
    void
  >,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseDTODockerResponseDTO, FailureDTO | ErrorDTO, GetBuildDetailsForDockerQueryParams, void>(
    getConfig('ng/api'),
    `/artifacts/docker/getBuildDetails`,
    props,
    signal
  )

export interface SyncTaskD2QueryParams {
  accountId?: string
  orgIdentifier?: string
  projectIdentifier?: string
}

export type SyncTaskD2Props = Omit<
  MutateProps<DelegateResponseData, unknown, SyncTaskD2QueryParams, void, void>,
  'path' | 'verb'
>

/**
 * Sync task using Delegate 2.0 framework
 */
export const SyncTaskD2 = (props: SyncTaskD2Props) => (
  <Mutate<DelegateResponseData, unknown, SyncTaskD2QueryParams, void, void>
    verb="POST"
    path={`/delegate2-tasks/sync`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseSyncTaskD2Props = Omit<
  UseMutateProps<DelegateResponseData, unknown, SyncTaskD2QueryParams, void, void>,
  'path' | 'verb'
>

/**
 * Sync task using Delegate 2.0 framework
 */
export const useSyncTaskD2 = (props: UseSyncTaskD2Props) =>
  useMutate<DelegateResponseData, unknown, SyncTaskD2QueryParams, void, void>('POST', `/delegate2-tasks/sync`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * Sync task using Delegate 2.0 framework
 */
export const syncTaskD2Promise = (
  props: MutateUsingFetchProps<DelegateResponseData, unknown, SyncTaskD2QueryParams, void, void>,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<DelegateResponseData, unknown, SyncTaskD2QueryParams, void, void>(
    'POST',
    getConfig('ng/api'),
    `/delegate2-tasks/sync`,
    props,
    signal
  )

export interface AsyncTaskD2QueryParams {
  accountId?: string
  orgIdentifier?: string
  projectIdentifier?: string
}

export type AsyncTaskD2Props = Omit<MutateProps<string, unknown, AsyncTaskD2QueryParams, void, void>, 'path' | 'verb'>

/**
 * Create a delegate tasks
 */
export const AsyncTaskD2 = (props: AsyncTaskD2Props) => (
  <Mutate<string, unknown, AsyncTaskD2QueryParams, void, void>
    verb="POST"
    path={`/delegate2-tasks/async`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseAsyncTaskD2Props = Omit<
  UseMutateProps<string, unknown, AsyncTaskD2QueryParams, void, void>,
  'path' | 'verb'
>

/**
 * Create a delegate tasks
 */
export const useAsyncTaskD2 = (props: UseAsyncTaskD2Props) =>
  useMutate<string, unknown, AsyncTaskD2QueryParams, void, void>('POST', `/delegate2-tasks/async`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * Create a delegate tasks
 */
export const asyncTaskD2Promise = (
  props: MutateUsingFetchProps<string, unknown, AsyncTaskD2QueryParams, void, void>,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<string, unknown, AsyncTaskD2QueryParams, void, void>(
    'POST',
    getConfig('ng/api'),
    `/delegate2-tasks/async`,
    props,
    signal
  )

export interface ListReferredByEntitiesQueryParams {
  page?: number
  size?: number
  account?: string
  org?: string
  project?: string
  identifier?: string
  searchTerm?: string
}

export type ListReferredByEntitiesProps = Omit<
  GetProps<ResponseDTOPageEntityReferenceDTO, unknown, ListReferredByEntitiesQueryParams, void>,
  'path'
>

/**
 * Get Entities referring this resouce
 */
export const ListReferredByEntities = (props: ListReferredByEntitiesProps) => (
  <Get<ResponseDTOPageEntityReferenceDTO, unknown, ListReferredByEntitiesQueryParams, void>
    path={`/entityReference`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseListReferredByEntitiesProps = Omit<
  UseGetProps<ResponseDTOPageEntityReferenceDTO, unknown, ListReferredByEntitiesQueryParams, void>,
  'path'
>

/**
 * Get Entities referring this resouce
 */
export const useListReferredByEntities = (props: UseListReferredByEntitiesProps) =>
  useGet<ResponseDTOPageEntityReferenceDTO, unknown, ListReferredByEntitiesQueryParams, void>(`/entityReference`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * Get Entities referring this resouce
 */
export const listReferredByEntitiesPromise = (
  props: GetUsingFetchProps<ResponseDTOPageEntityReferenceDTO, unknown, ListReferredByEntitiesQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseDTOPageEntityReferenceDTO, unknown, ListReferredByEntitiesQueryParams, void>(
    getConfig('ng/api'),
    `/entityReference`,
    props,
    signal
  )

export type PostEntityReferenceProps = Omit<
  MutateProps<ResponseDTOEntityReferenceDTO, unknown, void, EntityReferenceDTO, void>,
  'path' | 'verb'
>

/**
 * Saves the entity reference
 */
export const PostEntityReference = (props: PostEntityReferenceProps) => (
  <Mutate<ResponseDTOEntityReferenceDTO, unknown, void, EntityReferenceDTO, void>
    verb="POST"
    path={`/entityReference`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UsePostEntityReferenceProps = Omit<
  UseMutateProps<ResponseDTOEntityReferenceDTO, unknown, void, EntityReferenceDTO, void>,
  'path' | 'verb'
>

/**
 * Saves the entity reference
 */
export const usePostEntityReference = (props: UsePostEntityReferenceProps) =>
  useMutate<ResponseDTOEntityReferenceDTO, unknown, void, EntityReferenceDTO, void>('POST', `/entityReference`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * Saves the entity reference
 */
export const postEntityReferencePromise = (
  props: MutateUsingFetchProps<ResponseDTOEntityReferenceDTO, unknown, void, EntityReferenceDTO, void>,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<ResponseDTOEntityReferenceDTO, unknown, void, EntityReferenceDTO, void>(
    'POST',
    getConfig('ng/api'),
    `/entityReference`,
    props,
    signal
  )

export interface DeleteEntityReferenceQueryParams {
  referredEntityFQN?: string
  referredByEntityFQN?: string
}

export type DeleteEntityReferenceProps = Omit<
  MutateProps<ResponseDTOBoolean, unknown, DeleteEntityReferenceQueryParams, void, void>,
  'path' | 'verb'
>

/**
 * Deletes the entity reference
 */
export const DeleteEntityReference = (props: DeleteEntityReferenceProps) => (
  <Mutate<ResponseDTOBoolean, unknown, DeleteEntityReferenceQueryParams, void, void>
    verb="DELETE"
    path={`/entityReference`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseDeleteEntityReferenceProps = Omit<
  UseMutateProps<ResponseDTOBoolean, unknown, DeleteEntityReferenceQueryParams, void, void>,
  'path' | 'verb'
>

/**
 * Deletes the entity reference
 */
export const useDeleteEntityReference = (props: UseDeleteEntityReferenceProps) =>
  useMutate<ResponseDTOBoolean, unknown, DeleteEntityReferenceQueryParams, void, void>('DELETE', `/entityReference`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * Deletes the entity reference
 */
export const deleteEntityReferencePromise = (
  props: MutateUsingFetchProps<ResponseDTOBoolean, unknown, DeleteEntityReferenceQueryParams, void, void>,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<ResponseDTOBoolean, unknown, DeleteEntityReferenceQueryParams, void, void>(
    'DELETE',
    getConfig('ng/api'),
    `/entityReference`,
    props,
    signal
  )

export interface IsEntityReferencedQueryParams {
  accountIdentifier?: string
  orgIdentifier?: string
  projectIdentifier?: string
  identifier?: string
}

export type IsEntityReferencedProps = Omit<
  GetProps<ResponseDTOBoolean, unknown, IsEntityReferencedQueryParams, void>,
  'path'
>

/**
 * Returns true if the entity is referenced by other resource
 */
export const IsEntityReferenced = (props: IsEntityReferencedProps) => (
  <Get<ResponseDTOBoolean, unknown, IsEntityReferencedQueryParams, void>
    path={`/entityReference/isEntityReferenced`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseIsEntityReferencedProps = Omit<
  UseGetProps<ResponseDTOBoolean, unknown, IsEntityReferencedQueryParams, void>,
  'path'
>

/**
 * Returns true if the entity is referenced by other resource
 */
export const useIsEntityReferenced = (props: UseIsEntityReferencedProps) =>
  useGet<ResponseDTOBoolean, unknown, IsEntityReferencedQueryParams, void>(`/entityReference/isEntityReferenced`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * Returns true if the entity is referenced by other resource
 */
export const isEntityReferencedPromise = (
  props: GetUsingFetchProps<ResponseDTOBoolean, unknown, IsEntityReferencedQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseDTOBoolean, unknown, IsEntityReferencedQueryParams, void>(
    getConfig('ng/api'),
    `/entityReference/isEntityReferenced`,
    props,
    signal
  )

export interface GetEnvironmentQueryParams {
  accountId?: string
  orgIdentifier?: string
  projectIdentifier?: string
  deleted?: boolean
}

export interface GetEnvironmentPathParams {
  environmentIdentifier: string
}

export type GetEnvironmentProps = Omit<
  GetProps<
    ResponseDTOEnvironmentResponseDTO,
    FailureDTO | ErrorDTO,
    GetEnvironmentQueryParams,
    GetEnvironmentPathParams
  >,
  'path'
> &
  GetEnvironmentPathParams

/**
 * Gets a Environment by identifier
 */
export const GetEnvironment = ({ environmentIdentifier, ...props }: GetEnvironmentProps) => (
  <Get<ResponseDTOEnvironmentResponseDTO, FailureDTO | ErrorDTO, GetEnvironmentQueryParams, GetEnvironmentPathParams>
    path={`/environments/${environmentIdentifier}`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetEnvironmentProps = Omit<
  UseGetProps<
    ResponseDTOEnvironmentResponseDTO,
    FailureDTO | ErrorDTO,
    GetEnvironmentQueryParams,
    GetEnvironmentPathParams
  >,
  'path'
> &
  GetEnvironmentPathParams

/**
 * Gets a Environment by identifier
 */
export const useGetEnvironment = ({ environmentIdentifier, ...props }: UseGetEnvironmentProps) =>
  useGet<ResponseDTOEnvironmentResponseDTO, FailureDTO | ErrorDTO, GetEnvironmentQueryParams, GetEnvironmentPathParams>(
    (paramsInPath: GetEnvironmentPathParams) => `/environments/${paramsInPath.environmentIdentifier}`,
    { base: getConfig('ng/api'), pathParams: { environmentIdentifier }, ...props }
  )

/**
 * Gets a Environment by identifier
 */
export const getEnvironmentPromise = (
  {
    environmentIdentifier,
    ...props
  }: GetUsingFetchProps<
    ResponseDTOEnvironmentResponseDTO,
    FailureDTO | ErrorDTO,
    GetEnvironmentQueryParams,
    GetEnvironmentPathParams
  > & { environmentIdentifier: string },
  signal?: RequestInit['signal']
) =>
  getUsingFetch<
    ResponseDTOEnvironmentResponseDTO,
    FailureDTO | ErrorDTO,
    GetEnvironmentQueryParams,
    GetEnvironmentPathParams
  >(getConfig('ng/api'), `/environments/${environmentIdentifier}`, props, signal)

export interface DeleteEnvironmentQueryParams {
  accountId?: string
  orgIdentifier?: string
  projectIdentifier?: string
}

export type DeleteEnvironmentProps = Omit<
  MutateProps<ResponseDTOBoolean, FailureDTO | ErrorDTO, DeleteEnvironmentQueryParams, string, void>,
  'path' | 'verb'
>

/**
 * Delete en environment by identifier
 */
export const DeleteEnvironment = (props: DeleteEnvironmentProps) => (
  <Mutate<ResponseDTOBoolean, FailureDTO | ErrorDTO, DeleteEnvironmentQueryParams, string, void>
    verb="DELETE"
    path={`/environments`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseDeleteEnvironmentProps = Omit<
  UseMutateProps<ResponseDTOBoolean, FailureDTO | ErrorDTO, DeleteEnvironmentQueryParams, string, void>,
  'path' | 'verb'
>

/**
 * Delete en environment by identifier
 */
export const useDeleteEnvironment = (props: UseDeleteEnvironmentProps) =>
  useMutate<ResponseDTOBoolean, FailureDTO | ErrorDTO, DeleteEnvironmentQueryParams, string, void>(
    'DELETE',
    `/environments`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Delete en environment by identifier
 */
export const deleteEnvironmentPromise = (
  props: MutateUsingFetchProps<ResponseDTOBoolean, FailureDTO | ErrorDTO, DeleteEnvironmentQueryParams, string, void>,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<ResponseDTOBoolean, FailureDTO | ErrorDTO, DeleteEnvironmentQueryParams, string, void>(
    'DELETE',
    getConfig('ng/api'),
    `/environments`,
    props,
    signal
  )

export interface GetEnvironmentListForProjectQueryParams {
  page?: number
  size?: number
  accountId?: string
  orgIdentifier?: string
  projectIdentifier?: string
  sort?: string[]
}

export type GetEnvironmentListForProjectProps = Omit<
  GetProps<
    ResponseDTONGPageResponseEnvironmentResponseDTO,
    FailureDTO | ErrorDTO,
    GetEnvironmentListForProjectQueryParams,
    void
  >,
  'path'
>

/**
 * Gets environment list for a project
 */
export const GetEnvironmentListForProject = (props: GetEnvironmentListForProjectProps) => (
  <Get<
    ResponseDTONGPageResponseEnvironmentResponseDTO,
    FailureDTO | ErrorDTO,
    GetEnvironmentListForProjectQueryParams,
    void
  >
    path={`/environments`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetEnvironmentListForProjectProps = Omit<
  UseGetProps<
    ResponseDTONGPageResponseEnvironmentResponseDTO,
    FailureDTO | ErrorDTO,
    GetEnvironmentListForProjectQueryParams,
    void
  >,
  'path'
>

/**
 * Gets environment list for a project
 */
export const useGetEnvironmentListForProject = (props: UseGetEnvironmentListForProjectProps) =>
  useGet<
    ResponseDTONGPageResponseEnvironmentResponseDTO,
    FailureDTO | ErrorDTO,
    GetEnvironmentListForProjectQueryParams,
    void
  >(`/environments`, { base: getConfig('ng/api'), ...props })

/**
 * Gets environment list for a project
 */
export const getEnvironmentListForProjectPromise = (
  props: GetUsingFetchProps<
    ResponseDTONGPageResponseEnvironmentResponseDTO,
    FailureDTO | ErrorDTO,
    GetEnvironmentListForProjectQueryParams,
    void
  >,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<
    ResponseDTONGPageResponseEnvironmentResponseDTO,
    FailureDTO | ErrorDTO,
    GetEnvironmentListForProjectQueryParams,
    void
  >(getConfig('ng/api'), `/environments`, props, signal)

export interface CreateEnvironmentQueryParams {
  accountId?: string
}

export type CreateEnvironmentProps = Omit<
  MutateProps<
    ResponseDTOEnvironmentResponseDTO,
    FailureDTO | ErrorDTO,
    CreateEnvironmentQueryParams,
    EnvironmentRequestDTORequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Create an Environment
 */
export const CreateEnvironment = (props: CreateEnvironmentProps) => (
  <Mutate<
    ResponseDTOEnvironmentResponseDTO,
    FailureDTO | ErrorDTO,
    CreateEnvironmentQueryParams,
    EnvironmentRequestDTORequestBody,
    void
  >
    verb="POST"
    path={`/environments`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseCreateEnvironmentProps = Omit<
  UseMutateProps<
    ResponseDTOEnvironmentResponseDTO,
    FailureDTO | ErrorDTO,
    CreateEnvironmentQueryParams,
    EnvironmentRequestDTORequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Create an Environment
 */
export const useCreateEnvironment = (props: UseCreateEnvironmentProps) =>
  useMutate<
    ResponseDTOEnvironmentResponseDTO,
    FailureDTO | ErrorDTO,
    CreateEnvironmentQueryParams,
    EnvironmentRequestDTORequestBody,
    void
  >('POST', `/environments`, { base: getConfig('ng/api'), ...props })

/**
 * Create an Environment
 */
export const createEnvironmentPromise = (
  props: MutateUsingFetchProps<
    ResponseDTOEnvironmentResponseDTO,
    FailureDTO | ErrorDTO,
    CreateEnvironmentQueryParams,
    EnvironmentRequestDTORequestBody,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseDTOEnvironmentResponseDTO,
    FailureDTO | ErrorDTO,
    CreateEnvironmentQueryParams,
    EnvironmentRequestDTORequestBody,
    void
  >('POST', getConfig('ng/api'), `/environments`, props, signal)

export interface UpdateEnvironmentQueryParams {
  accountId?: string
}

export type UpdateEnvironmentProps = Omit<
  MutateProps<
    ResponseDTOEnvironmentResponseDTO,
    FailureDTO | ErrorDTO,
    UpdateEnvironmentQueryParams,
    EnvironmentRequestDTORequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Update an environment by identifier
 */
export const UpdateEnvironment = (props: UpdateEnvironmentProps) => (
  <Mutate<
    ResponseDTOEnvironmentResponseDTO,
    FailureDTO | ErrorDTO,
    UpdateEnvironmentQueryParams,
    EnvironmentRequestDTORequestBody,
    void
  >
    verb="PUT"
    path={`/environments`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseUpdateEnvironmentProps = Omit<
  UseMutateProps<
    ResponseDTOEnvironmentResponseDTO,
    FailureDTO | ErrorDTO,
    UpdateEnvironmentQueryParams,
    EnvironmentRequestDTORequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Update an environment by identifier
 */
export const useUpdateEnvironment = (props: UseUpdateEnvironmentProps) =>
  useMutate<
    ResponseDTOEnvironmentResponseDTO,
    FailureDTO | ErrorDTO,
    UpdateEnvironmentQueryParams,
    EnvironmentRequestDTORequestBody,
    void
  >('PUT', `/environments`, { base: getConfig('ng/api'), ...props })

/**
 * Update an environment by identifier
 */
export const updateEnvironmentPromise = (
  props: MutateUsingFetchProps<
    ResponseDTOEnvironmentResponseDTO,
    FailureDTO | ErrorDTO,
    UpdateEnvironmentQueryParams,
    EnvironmentRequestDTORequestBody,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseDTOEnvironmentResponseDTO,
    FailureDTO | ErrorDTO,
    UpdateEnvironmentQueryParams,
    EnvironmentRequestDTORequestBody,
    void
  >('PUT', getConfig('ng/api'), `/environments`, props, signal)

export interface UpsertEnvironmentQueryParams {
  accountId?: string
}

export type UpsertEnvironmentProps = Omit<
  MutateProps<
    ResponseDTOEnvironmentResponseDTO,
    FailureDTO | ErrorDTO,
    UpsertEnvironmentQueryParams,
    EnvironmentRequestDTORequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Upsert an environment by identifier
 */
export const UpsertEnvironment = (props: UpsertEnvironmentProps) => (
  <Mutate<
    ResponseDTOEnvironmentResponseDTO,
    FailureDTO | ErrorDTO,
    UpsertEnvironmentQueryParams,
    EnvironmentRequestDTORequestBody,
    void
  >
    verb="PUT"
    path={`/environments/upsert`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseUpsertEnvironmentProps = Omit<
  UseMutateProps<
    ResponseDTOEnvironmentResponseDTO,
    FailureDTO | ErrorDTO,
    UpsertEnvironmentQueryParams,
    EnvironmentRequestDTORequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Upsert an environment by identifier
 */
export const useUpsertEnvironment = (props: UseUpsertEnvironmentProps) =>
  useMutate<
    ResponseDTOEnvironmentResponseDTO,
    FailureDTO | ErrorDTO,
    UpsertEnvironmentQueryParams,
    EnvironmentRequestDTORequestBody,
    void
  >('PUT', `/environments/upsert`, { base: getConfig('ng/api'), ...props })

/**
 * Upsert an environment by identifier
 */
export const upsertEnvironmentPromise = (
  props: MutateUsingFetchProps<
    ResponseDTOEnvironmentResponseDTO,
    FailureDTO | ErrorDTO,
    UpsertEnvironmentQueryParams,
    EnvironmentRequestDTORequestBody,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseDTOEnvironmentResponseDTO,
    FailureDTO | ErrorDTO,
    UpsertEnvironmentQueryParams,
    EnvironmentRequestDTORequestBody,
    void
  >('PUT', getConfig('ng/api'), `/environments/upsert`, props, signal)

export interface GetInputSetForPipelineQueryParams {
  accountIdentifier: string
  orgIdentifier: string
  projectIdentifier: string
  pipelineIdentifier: string
  deleted?: boolean
}

export interface GetInputSetForPipelinePathParams {
  inputSetIdentifier: string
}

export type GetInputSetForPipelineProps = Omit<
  GetProps<
    ResponseDTOInputSetResponse,
    FailureDTO | ErrorDTO,
    GetInputSetForPipelineQueryParams,
    GetInputSetForPipelinePathParams
  >,
  'path'
> &
  GetInputSetForPipelinePathParams

/**
 * Gets an InputSet by identifier
 */
export const GetInputSetForPipeline = ({ inputSetIdentifier, ...props }: GetInputSetForPipelineProps) => (
  <Get<
    ResponseDTOInputSetResponse,
    FailureDTO | ErrorDTO,
    GetInputSetForPipelineQueryParams,
    GetInputSetForPipelinePathParams
  >
    path={`/inputSets/${inputSetIdentifier}`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetInputSetForPipelineProps = Omit<
  UseGetProps<
    ResponseDTOInputSetResponse,
    FailureDTO | ErrorDTO,
    GetInputSetForPipelineQueryParams,
    GetInputSetForPipelinePathParams
  >,
  'path'
> &
  GetInputSetForPipelinePathParams

/**
 * Gets an InputSet by identifier
 */
export const useGetInputSetForPipeline = ({ inputSetIdentifier, ...props }: UseGetInputSetForPipelineProps) =>
  useGet<
    ResponseDTOInputSetResponse,
    FailureDTO | ErrorDTO,
    GetInputSetForPipelineQueryParams,
    GetInputSetForPipelinePathParams
  >((paramsInPath: GetInputSetForPipelinePathParams) => `/inputSets/${paramsInPath.inputSetIdentifier}`, {
    base: getConfig('ng/api'),
    pathParams: { inputSetIdentifier },
    ...props
  })

/**
 * Gets an InputSet by identifier
 */
export const getInputSetForPipelinePromise = (
  {
    inputSetIdentifier,
    ...props
  }: GetUsingFetchProps<
    ResponseDTOInputSetResponse,
    FailureDTO | ErrorDTO,
    GetInputSetForPipelineQueryParams,
    GetInputSetForPipelinePathParams
  > & { inputSetIdentifier: string },
  signal?: RequestInit['signal']
) =>
  getUsingFetch<
    ResponseDTOInputSetResponse,
    FailureDTO | ErrorDTO,
    GetInputSetForPipelineQueryParams,
    GetInputSetForPipelinePathParams
  >(getConfig('ng/api'), `/inputSets/${inputSetIdentifier}`, props, signal)

export interface UpdateInputSetForPipelineQueryParams {
  accountIdentifier: string
  orgIdentifier: string
  projectIdentifier: string
  pipelineIdentifier: string
}

export interface UpdateInputSetForPipelinePathParams {
  inputSetIdentifier: string
}

export type UpdateInputSetForPipelineProps = Omit<
  MutateProps<
    ResponseDTOInputSetResponse,
    FailureDTO | ErrorDTO,
    UpdateInputSetForPipelineQueryParams,
    CDInputSetRequestBody,
    UpdateInputSetForPipelinePathParams
  >,
  'path' | 'verb'
> &
  UpdateInputSetForPipelinePathParams

/**
 * Update an InputSet by identifier
 */
export const UpdateInputSetForPipeline = ({ inputSetIdentifier, ...props }: UpdateInputSetForPipelineProps) => (
  <Mutate<
    ResponseDTOInputSetResponse,
    FailureDTO | ErrorDTO,
    UpdateInputSetForPipelineQueryParams,
    CDInputSetRequestBody,
    UpdateInputSetForPipelinePathParams
  >
    verb="PUT"
    path={`/inputSets/${inputSetIdentifier}`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseUpdateInputSetForPipelineProps = Omit<
  UseMutateProps<
    ResponseDTOInputSetResponse,
    FailureDTO | ErrorDTO,
    UpdateInputSetForPipelineQueryParams,
    CDInputSetRequestBody,
    UpdateInputSetForPipelinePathParams
  >,
  'path' | 'verb'
> &
  UpdateInputSetForPipelinePathParams

/**
 * Update an InputSet by identifier
 */
export const useUpdateInputSetForPipeline = ({ inputSetIdentifier, ...props }: UseUpdateInputSetForPipelineProps) =>
  useMutate<
    ResponseDTOInputSetResponse,
    FailureDTO | ErrorDTO,
    UpdateInputSetForPipelineQueryParams,
    CDInputSetRequestBody,
    UpdateInputSetForPipelinePathParams
  >('PUT', (paramsInPath: UpdateInputSetForPipelinePathParams) => `/inputSets/${paramsInPath.inputSetIdentifier}`, {
    base: getConfig('ng/api'),
    pathParams: { inputSetIdentifier },
    ...props
  })

/**
 * Update an InputSet by identifier
 */
export const updateInputSetForPipelinePromise = (
  {
    inputSetIdentifier,
    ...props
  }: MutateUsingFetchProps<
    ResponseDTOInputSetResponse,
    FailureDTO | ErrorDTO,
    UpdateInputSetForPipelineQueryParams,
    CDInputSetRequestBody,
    UpdateInputSetForPipelinePathParams
  > & { inputSetIdentifier: string },
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseDTOInputSetResponse,
    FailureDTO | ErrorDTO,
    UpdateInputSetForPipelineQueryParams,
    CDInputSetRequestBody,
    UpdateInputSetForPipelinePathParams
  >('PUT', getConfig('ng/api'), `/inputSets/${inputSetIdentifier}`, props, signal)

export interface DeleteInputSetForPipelineQueryParams {
  accountIdentifier: string
  orgIdentifier: string
  projectIdentifier: string
  pipelineIdentifier: string
}

export type DeleteInputSetForPipelineProps = Omit<
  MutateProps<ResponseDTOBoolean, FailureDTO | ErrorDTO, DeleteInputSetForPipelineQueryParams, string, void>,
  'path' | 'verb'
>

/**
 * Delete an inputSet by identifier
 */
export const DeleteInputSetForPipeline = (props: DeleteInputSetForPipelineProps) => (
  <Mutate<ResponseDTOBoolean, FailureDTO | ErrorDTO, DeleteInputSetForPipelineQueryParams, string, void>
    verb="DELETE"
    path={`/inputSets`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseDeleteInputSetForPipelineProps = Omit<
  UseMutateProps<ResponseDTOBoolean, FailureDTO | ErrorDTO, DeleteInputSetForPipelineQueryParams, string, void>,
  'path' | 'verb'
>

/**
 * Delete an inputSet by identifier
 */
export const useDeleteInputSetForPipeline = (props: UseDeleteInputSetForPipelineProps) =>
  useMutate<ResponseDTOBoolean, FailureDTO | ErrorDTO, DeleteInputSetForPipelineQueryParams, string, void>(
    'DELETE',
    `/inputSets`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Delete an inputSet by identifier
 */
export const deleteInputSetForPipelinePromise = (
  props: MutateUsingFetchProps<
    ResponseDTOBoolean,
    FailureDTO | ErrorDTO,
    DeleteInputSetForPipelineQueryParams,
    string,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<ResponseDTOBoolean, FailureDTO | ErrorDTO, DeleteInputSetForPipelineQueryParams, string, void>(
    'DELETE',
    getConfig('ng/api'),
    `/inputSets`,
    props,
    signal
  )

export interface GetTemplateFromPipelineQueryParams {
  accountIdentifier: string
  orgIdentifier: string
  projectIdentifier: string
  pipelineIdentifier: string
}

export type GetTemplateFromPipelineProps = Omit<
  GetProps<ResponseDTOInputSetTemplateResponse, FailureDTO | ErrorDTO, GetTemplateFromPipelineQueryParams, void>,
  'path'
>

/**
 * Get template from a pipeline yaml
 */
export const GetTemplateFromPipeline = (props: GetTemplateFromPipelineProps) => (
  <Get<ResponseDTOInputSetTemplateResponse, FailureDTO | ErrorDTO, GetTemplateFromPipelineQueryParams, void>
    path={`/inputSets/template`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetTemplateFromPipelineProps = Omit<
  UseGetProps<ResponseDTOInputSetTemplateResponse, FailureDTO | ErrorDTO, GetTemplateFromPipelineQueryParams, void>,
  'path'
>

/**
 * Get template from a pipeline yaml
 */
export const useGetTemplateFromPipeline = (props: UseGetTemplateFromPipelineProps) =>
  useGet<ResponseDTOInputSetTemplateResponse, FailureDTO | ErrorDTO, GetTemplateFromPipelineQueryParams, void>(
    `/inputSets/template`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Get template from a pipeline yaml
 */
export const getTemplateFromPipelinePromise = (
  props: GetUsingFetchProps<
    ResponseDTOInputSetTemplateResponse,
    FailureDTO | ErrorDTO,
    GetTemplateFromPipelineQueryParams,
    void
  >,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseDTOInputSetTemplateResponse, FailureDTO | ErrorDTO, GetTemplateFromPipelineQueryParams, void>(
    getConfig('ng/api'),
    `/inputSets/template`,
    props,
    signal
  )

export interface GetOverlayInputSetForPipelineQueryParams {
  accountIdentifier: string
  orgIdentifier: string
  projectIdentifier: string
  pipelineIdentifier: string
  deleted?: boolean
}

export interface GetOverlayInputSetForPipelinePathParams {
  inputSetIdentifier: string
}

export type GetOverlayInputSetForPipelineProps = Omit<
  GetProps<
    ResponseDTOOverlayInputSetResponseDTO,
    FailureDTO | ErrorDTO,
    GetOverlayInputSetForPipelineQueryParams,
    GetOverlayInputSetForPipelinePathParams
  >,
  'path'
> &
  GetOverlayInputSetForPipelinePathParams

/**
 * Gets an Overlay InputSet by identifier
 */
export const GetOverlayInputSetForPipeline = ({ inputSetIdentifier, ...props }: GetOverlayInputSetForPipelineProps) => (
  <Get<
    ResponseDTOOverlayInputSetResponseDTO,
    FailureDTO | ErrorDTO,
    GetOverlayInputSetForPipelineQueryParams,
    GetOverlayInputSetForPipelinePathParams
  >
    path={`/inputSets/overlay/${inputSetIdentifier}`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetOverlayInputSetForPipelineProps = Omit<
  UseGetProps<
    ResponseDTOOverlayInputSetResponseDTO,
    FailureDTO | ErrorDTO,
    GetOverlayInputSetForPipelineQueryParams,
    GetOverlayInputSetForPipelinePathParams
  >,
  'path'
> &
  GetOverlayInputSetForPipelinePathParams

/**
 * Gets an Overlay InputSet by identifier
 */
export const useGetOverlayInputSetForPipeline = ({
  inputSetIdentifier,
  ...props
}: UseGetOverlayInputSetForPipelineProps) =>
  useGet<
    ResponseDTOOverlayInputSetResponseDTO,
    FailureDTO | ErrorDTO,
    GetOverlayInputSetForPipelineQueryParams,
    GetOverlayInputSetForPipelinePathParams
  >(
    (paramsInPath: GetOverlayInputSetForPipelinePathParams) => `/inputSets/overlay/${paramsInPath.inputSetIdentifier}`,
    { base: getConfig('ng/api'), pathParams: { inputSetIdentifier }, ...props }
  )

/**
 * Gets an Overlay InputSet by identifier
 */
export const getOverlayInputSetForPipelinePromise = (
  {
    inputSetIdentifier,
    ...props
  }: GetUsingFetchProps<
    ResponseDTOOverlayInputSetResponseDTO,
    FailureDTO | ErrorDTO,
    GetOverlayInputSetForPipelineQueryParams,
    GetOverlayInputSetForPipelinePathParams
  > & { inputSetIdentifier: string },
  signal?: RequestInit['signal']
) =>
  getUsingFetch<
    ResponseDTOOverlayInputSetResponseDTO,
    FailureDTO | ErrorDTO,
    GetOverlayInputSetForPipelineQueryParams,
    GetOverlayInputSetForPipelinePathParams
  >(getConfig('ng/api'), `/inputSets/overlay/${inputSetIdentifier}`, props, signal)

export interface UpdateOverlayInputSetForPipelineQueryParams {
  accountIdentifier: string
  orgIdentifier: string
  projectIdentifier: string
  pipelineIdentifier: string
}

export interface UpdateOverlayInputSetForPipelinePathParams {
  inputSetIdentifier: string
}

export type UpdateOverlayInputSetForPipelineProps = Omit<
  MutateProps<
    ResponseDTOOverlayInputSetResponseDTO,
    FailureDTO | ErrorDTO,
    UpdateOverlayInputSetForPipelineQueryParams,
    OverlayInputSetRequestBody,
    UpdateOverlayInputSetForPipelinePathParams
  >,
  'path' | 'verb'
> &
  UpdateOverlayInputSetForPipelinePathParams

/**
 * Update an Overlay InputSet by identifier
 */
export const UpdateOverlayInputSetForPipeline = ({
  inputSetIdentifier,
  ...props
}: UpdateOverlayInputSetForPipelineProps) => (
  <Mutate<
    ResponseDTOOverlayInputSetResponseDTO,
    FailureDTO | ErrorDTO,
    UpdateOverlayInputSetForPipelineQueryParams,
    OverlayInputSetRequestBody,
    UpdateOverlayInputSetForPipelinePathParams
  >
    verb="PUT"
    path={`/inputSets/overlay/${inputSetIdentifier}`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseUpdateOverlayInputSetForPipelineProps = Omit<
  UseMutateProps<
    ResponseDTOOverlayInputSetResponseDTO,
    FailureDTO | ErrorDTO,
    UpdateOverlayInputSetForPipelineQueryParams,
    OverlayInputSetRequestBody,
    UpdateOverlayInputSetForPipelinePathParams
  >,
  'path' | 'verb'
> &
  UpdateOverlayInputSetForPipelinePathParams

/**
 * Update an Overlay InputSet by identifier
 */
export const useUpdateOverlayInputSetForPipeline = ({
  inputSetIdentifier,
  ...props
}: UseUpdateOverlayInputSetForPipelineProps) =>
  useMutate<
    ResponseDTOOverlayInputSetResponseDTO,
    FailureDTO | ErrorDTO,
    UpdateOverlayInputSetForPipelineQueryParams,
    OverlayInputSetRequestBody,
    UpdateOverlayInputSetForPipelinePathParams
  >(
    'PUT',
    (paramsInPath: UpdateOverlayInputSetForPipelinePathParams) =>
      `/inputSets/overlay/${paramsInPath.inputSetIdentifier}`,
    { base: getConfig('ng/api'), pathParams: { inputSetIdentifier }, ...props }
  )

/**
 * Update an Overlay InputSet by identifier
 */
export const updateOverlayInputSetForPipelinePromise = (
  {
    inputSetIdentifier,
    ...props
  }: MutateUsingFetchProps<
    ResponseDTOOverlayInputSetResponseDTO,
    FailureDTO | ErrorDTO,
    UpdateOverlayInputSetForPipelineQueryParams,
    OverlayInputSetRequestBody,
    UpdateOverlayInputSetForPipelinePathParams
  > & { inputSetIdentifier: string },
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseDTOOverlayInputSetResponseDTO,
    FailureDTO | ErrorDTO,
    UpdateOverlayInputSetForPipelineQueryParams,
    OverlayInputSetRequestBody,
    UpdateOverlayInputSetForPipelinePathParams
  >('PUT', getConfig('ng/api'), `/inputSets/overlay/${inputSetIdentifier}`, props, signal)

export interface GetInputSetsListForPipelineQueryParams {
  page?: number
  size?: number
  accountIdentifier: string
  orgIdentifier: string
  projectIdentifier: string
  pipelineIdentifier: string
  inputSetType?: 'ALL' | 'INPUT_SET' | 'OVERLAY_INPUT_SET'
  searchTerm?: string
  sort?: string[]
}

export type GetInputSetsListForPipelineProps = Omit<
  GetProps<
    ResponseDTONGPageResponseInputSetSummaryResponse,
    FailureDTO | ErrorDTO,
    GetInputSetsListForPipelineQueryParams,
    void
  >,
  'path'
>

/**
 * Gets InputSets list for a pipeline
 */
export const GetInputSetsListForPipeline = (props: GetInputSetsListForPipelineProps) => (
  <Get<
    ResponseDTONGPageResponseInputSetSummaryResponse,
    FailureDTO | ErrorDTO,
    GetInputSetsListForPipelineQueryParams,
    void
  >
    path={`/inputSets`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetInputSetsListForPipelineProps = Omit<
  UseGetProps<
    ResponseDTONGPageResponseInputSetSummaryResponse,
    FailureDTO | ErrorDTO,
    GetInputSetsListForPipelineQueryParams,
    void
  >,
  'path'
>

/**
 * Gets InputSets list for a pipeline
 */
export const useGetInputSetsListForPipeline = (props: UseGetInputSetsListForPipelineProps) =>
  useGet<
    ResponseDTONGPageResponseInputSetSummaryResponse,
    FailureDTO | ErrorDTO,
    GetInputSetsListForPipelineQueryParams,
    void
  >(`/inputSets`, { base: getConfig('ng/api'), ...props })

/**
 * Gets InputSets list for a pipeline
 */
export const getInputSetsListForPipelinePromise = (
  props: GetUsingFetchProps<
    ResponseDTONGPageResponseInputSetSummaryResponse,
    FailureDTO | ErrorDTO,
    GetInputSetsListForPipelineQueryParams,
    void
  >,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<
    ResponseDTONGPageResponseInputSetSummaryResponse,
    FailureDTO | ErrorDTO,
    GetInputSetsListForPipelineQueryParams,
    void
  >(getConfig('ng/api'), `/inputSets`, props, signal)

export interface CreateInputSetForPipelineQueryParams {
  accountIdentifier: string
  orgIdentifier: string
  projectIdentifier: string
  pipelineIdentifier: string
}

export type CreateInputSetForPipelineProps = Omit<
  MutateProps<
    ResponseDTOInputSetResponse,
    FailureDTO | ErrorDTO,
    CreateInputSetForPipelineQueryParams,
    CDInputSetRequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Create an InputSet For Pipeline
 */
export const CreateInputSetForPipeline = (props: CreateInputSetForPipelineProps) => (
  <Mutate<
    ResponseDTOInputSetResponse,
    FailureDTO | ErrorDTO,
    CreateInputSetForPipelineQueryParams,
    CDInputSetRequestBody,
    void
  >
    verb="POST"
    path={`/inputSets`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseCreateInputSetForPipelineProps = Omit<
  UseMutateProps<
    ResponseDTOInputSetResponse,
    FailureDTO | ErrorDTO,
    CreateInputSetForPipelineQueryParams,
    CDInputSetRequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Create an InputSet For Pipeline
 */
export const useCreateInputSetForPipeline = (props: UseCreateInputSetForPipelineProps) =>
  useMutate<
    ResponseDTOInputSetResponse,
    FailureDTO | ErrorDTO,
    CreateInputSetForPipelineQueryParams,
    CDInputSetRequestBody,
    void
  >('POST', `/inputSets`, { base: getConfig('ng/api'), ...props })

/**
 * Create an InputSet For Pipeline
 */
export const createInputSetForPipelinePromise = (
  props: MutateUsingFetchProps<
    ResponseDTOInputSetResponse,
    FailureDTO | ErrorDTO,
    CreateInputSetForPipelineQueryParams,
    CDInputSetRequestBody,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseDTOInputSetResponse,
    FailureDTO | ErrorDTO,
    CreateInputSetForPipelineQueryParams,
    CDInputSetRequestBody,
    void
  >('POST', getConfig('ng/api'), `/inputSets`, props, signal)

export interface CreateOverlayInputSetForPipelineQueryParams {
  accountIdentifier: string
  orgIdentifier: string
  projectIdentifier: string
  pipelineIdentifier: string
}

export type CreateOverlayInputSetForPipelineProps = Omit<
  MutateProps<
    ResponseDTOOverlayInputSetResponseDTO,
    FailureDTO | ErrorDTO,
    CreateOverlayInputSetForPipelineQueryParams,
    OverlayInputSetRequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Create an Overlay InputSet For Pipeline
 */
export const CreateOverlayInputSetForPipeline = (props: CreateOverlayInputSetForPipelineProps) => (
  <Mutate<
    ResponseDTOOverlayInputSetResponseDTO,
    FailureDTO | ErrorDTO,
    CreateOverlayInputSetForPipelineQueryParams,
    OverlayInputSetRequestBody,
    void
  >
    verb="POST"
    path={`/inputSets/overlay`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseCreateOverlayInputSetForPipelineProps = Omit<
  UseMutateProps<
    ResponseDTOOverlayInputSetResponseDTO,
    FailureDTO | ErrorDTO,
    CreateOverlayInputSetForPipelineQueryParams,
    OverlayInputSetRequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Create an Overlay InputSet For Pipeline
 */
export const useCreateOverlayInputSetForPipeline = (props: UseCreateOverlayInputSetForPipelineProps) =>
  useMutate<
    ResponseDTOOverlayInputSetResponseDTO,
    FailureDTO | ErrorDTO,
    CreateOverlayInputSetForPipelineQueryParams,
    OverlayInputSetRequestBody,
    void
  >('POST', `/inputSets/overlay`, { base: getConfig('ng/api'), ...props })

/**
 * Create an Overlay InputSet For Pipeline
 */
export const createOverlayInputSetForPipelinePromise = (
  props: MutateUsingFetchProps<
    ResponseDTOOverlayInputSetResponseDTO,
    FailureDTO | ErrorDTO,
    CreateOverlayInputSetForPipelineQueryParams,
    OverlayInputSetRequestBody,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseDTOOverlayInputSetResponseDTO,
    FailureDTO | ErrorDTO,
    CreateOverlayInputSetForPipelineQueryParams,
    OverlayInputSetRequestBody,
    void
  >('POST', getConfig('ng/api'), `/inputSets/overlay`, props, signal)

export interface GetInvitesQueryParams {
  accountIdentifier?: string
  orgIdentifier?: string
  projectIdentifier?: string
  page?: number
  size?: number
  sort?: string[]
}

export type GetInvitesProps = Omit<
  GetProps<ResponseDTONGPageResponseInviteDTO, FailureDTO | ErrorDTO, GetInvitesQueryParams, void>,
  'path'
>

/**
 * Get all invites for the queried project
 */
export const GetInvites = (props: GetInvitesProps) => (
  <Get<ResponseDTONGPageResponseInviteDTO, FailureDTO | ErrorDTO, GetInvitesQueryParams, void>
    path={`/invites`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetInvitesProps = Omit<
  UseGetProps<ResponseDTONGPageResponseInviteDTO, FailureDTO | ErrorDTO, GetInvitesQueryParams, void>,
  'path'
>

/**
 * Get all invites for the queried project
 */
export const useGetInvites = (props: UseGetInvitesProps) =>
  useGet<ResponseDTONGPageResponseInviteDTO, FailureDTO | ErrorDTO, GetInvitesQueryParams, void>(`/invites`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * Get all invites for the queried project
 */
export const getInvitesPromise = (
  props: GetUsingFetchProps<ResponseDTONGPageResponseInviteDTO, FailureDTO | ErrorDTO, GetInvitesQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseDTONGPageResponseInviteDTO, FailureDTO | ErrorDTO, GetInvitesQueryParams, void>(
    getConfig('ng/api'),
    `/invites`,
    props,
    signal
  )

export interface SendInviteQueryParams {
  accountIdentifier: string
  orgIdentifier: string
  projectIdentifier: string
}

export type SendInviteProps = Omit<
  MutateProps<
    ResponseDTOListInviteOperationResponse,
    FailureDTO | ErrorDTO,
    SendInviteQueryParams,
    CreateInviteListDTO,
    void
  >,
  'path' | 'verb'
>

/**
 * Add a new invite for the specified project
 */
export const SendInvite = (props: SendInviteProps) => (
  <Mutate<
    ResponseDTOListInviteOperationResponse,
    FailureDTO | ErrorDTO,
    SendInviteQueryParams,
    CreateInviteListDTO,
    void
  >
    verb="POST"
    path={`/invites`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseSendInviteProps = Omit<
  UseMutateProps<
    ResponseDTOListInviteOperationResponse,
    FailureDTO | ErrorDTO,
    SendInviteQueryParams,
    CreateInviteListDTO,
    void
  >,
  'path' | 'verb'
>

/**
 * Add a new invite for the specified project
 */
export const useSendInvite = (props: UseSendInviteProps) =>
  useMutate<
    ResponseDTOListInviteOperationResponse,
    FailureDTO | ErrorDTO,
    SendInviteQueryParams,
    CreateInviteListDTO,
    void
  >('POST', `/invites`, { base: getConfig('ng/api'), ...props })

/**
 * Add a new invite for the specified project
 */
export const sendInvitePromise = (
  props: MutateUsingFetchProps<
    ResponseDTOListInviteOperationResponse,
    FailureDTO | ErrorDTO,
    SendInviteQueryParams,
    CreateInviteListDTO,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseDTOListInviteOperationResponse,
    FailureDTO | ErrorDTO,
    SendInviteQueryParams,
    CreateInviteListDTO,
    void
  >('POST', getConfig('ng/api'), `/invites`, props, signal)

export interface UpdateInviteQueryParams {
  accountIdentifier?: string
}

export interface UpdateInvitePathParams {
  inviteId: string
}

export type UpdateInviteProps = Omit<
  MutateProps<
    ResponseDTOOptionalInviteDTO,
    FailureDTO | ErrorDTO,
    UpdateInviteQueryParams,
    InviteDTO,
    UpdateInvitePathParams
  >,
  'path' | 'verb'
> &
  UpdateInvitePathParams

/**
 * Resend invite mail
 */
export const UpdateInvite = ({ inviteId, ...props }: UpdateInviteProps) => (
  <Mutate<
    ResponseDTOOptionalInviteDTO,
    FailureDTO | ErrorDTO,
    UpdateInviteQueryParams,
    InviteDTO,
    UpdateInvitePathParams
  >
    verb="PUT"
    path={`/invites/${inviteId}`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseUpdateInviteProps = Omit<
  UseMutateProps<
    ResponseDTOOptionalInviteDTO,
    FailureDTO | ErrorDTO,
    UpdateInviteQueryParams,
    InviteDTO,
    UpdateInvitePathParams
  >,
  'path' | 'verb'
> &
  UpdateInvitePathParams

/**
 * Resend invite mail
 */
export const useUpdateInvite = ({ inviteId, ...props }: UseUpdateInviteProps) =>
  useMutate<
    ResponseDTOOptionalInviteDTO,
    FailureDTO | ErrorDTO,
    UpdateInviteQueryParams,
    InviteDTO,
    UpdateInvitePathParams
  >('PUT', (paramsInPath: UpdateInvitePathParams) => `/invites/${paramsInPath.inviteId}`, {
    base: getConfig('ng/api'),
    pathParams: { inviteId },
    ...props
  })

/**
 * Resend invite mail
 */
export const updateInvitePromise = (
  {
    inviteId,
    ...props
  }: MutateUsingFetchProps<
    ResponseDTOOptionalInviteDTO,
    FailureDTO | ErrorDTO,
    UpdateInviteQueryParams,
    InviteDTO,
    UpdateInvitePathParams
  > & { inviteId: string },
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseDTOOptionalInviteDTO,
    FailureDTO | ErrorDTO,
    UpdateInviteQueryParams,
    InviteDTO,
    UpdateInvitePathParams
  >('PUT', getConfig('ng/api'), `/invites/${inviteId}`, props, signal)

export interface DeleteInviteQueryParams {
  accountIdentifier?: string
}

export type DeleteInviteProps = Omit<
  MutateProps<ResponseDTOOptionalInviteDTO, FailureDTO | ErrorDTO, DeleteInviteQueryParams, string, void>,
  'path' | 'verb'
>

/**
 * Delete a invite for the specified project
 */
export const DeleteInvite = (props: DeleteInviteProps) => (
  <Mutate<ResponseDTOOptionalInviteDTO, FailureDTO | ErrorDTO, DeleteInviteQueryParams, string, void>
    verb="DELETE"
    path={`/invites`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseDeleteInviteProps = Omit<
  UseMutateProps<ResponseDTOOptionalInviteDTO, FailureDTO | ErrorDTO, DeleteInviteQueryParams, string, void>,
  'path' | 'verb'
>

/**
 * Delete a invite for the specified project
 */
export const useDeleteInvite = (props: UseDeleteInviteProps) =>
  useMutate<ResponseDTOOptionalInviteDTO, FailureDTO | ErrorDTO, DeleteInviteQueryParams, string, void>(
    'DELETE',
    `/invites`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Delete a invite for the specified project
 */
export const deleteInvitePromise = (
  props: MutateUsingFetchProps<
    ResponseDTOOptionalInviteDTO,
    FailureDTO | ErrorDTO,
    DeleteInviteQueryParams,
    string,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<ResponseDTOOptionalInviteDTO, FailureDTO | ErrorDTO, DeleteInviteQueryParams, string, void>(
    'DELETE',
    getConfig('ng/api'),
    `/invites`,
    props,
    signal
  )

export interface VerifyInviteQueryParams {
  token: string
  accountIdentifier?: string
}

export type VerifyInviteProps = Omit<GetProps<void, FailureDTO | ErrorDTO, VerifyInviteQueryParams, void>, 'path'>

/**
 * Verify user invite
 */
export const VerifyInvite = (props: VerifyInviteProps) => (
  <Get<void, FailureDTO | ErrorDTO, VerifyInviteQueryParams, void>
    path={`/invites/verify`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseVerifyInviteProps = Omit<UseGetProps<void, FailureDTO | ErrorDTO, VerifyInviteQueryParams, void>, 'path'>

/**
 * Verify user invite
 */
export const useVerifyInvite = (props: UseVerifyInviteProps) =>
  useGet<void, FailureDTO | ErrorDTO, VerifyInviteQueryParams, void>(`/invites/verify`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * Verify user invite
 */
export const verifyInvitePromise = (
  props: GetUsingFetchProps<void, FailureDTO | ErrorDTO, VerifyInviteQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<void, FailureDTO | ErrorDTO, VerifyInviteQueryParams, void>(
    getConfig('ng/api'),
    `/invites/verify`,
    props,
    signal
  )

export interface GetRolesQueryParams {
  accountIdentifier: string
  orgIdentifier: string
  projectIdentifier: string
}

export type GetRolesProps = Omit<
  GetProps<ResponseDTOOptionalListRoleDTO, FailureDTO | ErrorDTO, GetRolesQueryParams, void>,
  'path'
>

/**
 * Get all roles for the queried project
 */
export const GetRoles = (props: GetRolesProps) => (
  <Get<ResponseDTOOptionalListRoleDTO, FailureDTO | ErrorDTO, GetRolesQueryParams, void>
    path={`/roles`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetRolesProps = Omit<
  UseGetProps<ResponseDTOOptionalListRoleDTO, FailureDTO | ErrorDTO, GetRolesQueryParams, void>,
  'path'
>

/**
 * Get all roles for the queried project
 */
export const useGetRoles = (props: UseGetRolesProps) =>
  useGet<ResponseDTOOptionalListRoleDTO, FailureDTO | ErrorDTO, GetRolesQueryParams, void>(`/roles`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * Get all roles for the queried project
 */
export const getRolesPromise = (
  props: GetUsingFetchProps<ResponseDTOOptionalListRoleDTO, FailureDTO | ErrorDTO, GetRolesQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseDTOOptionalListRoleDTO, FailureDTO | ErrorDTO, GetRolesQueryParams, void>(
    getConfig('ng/api'),
    `/roles`,
    props,
    signal
  )

export interface PostDelegateQueryParams {
  accountId?: string
}

export type PostDelegateProps = Omit<GetProps<DelegateResponseData, unknown, PostDelegateQueryParams, void>, 'path'>

/**
 * Create a delegate tasks
 */
export const PostDelegate = (props: PostDelegateProps) => (
  <Get<DelegateResponseData, unknown, PostDelegateQueryParams, void>
    path={`/delegate-tasks`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UsePostDelegateProps = Omit<
  UseGetProps<DelegateResponseData, unknown, PostDelegateQueryParams, void>,
  'path'
>

/**
 * Create a delegate tasks
 */
export const usePostDelegate = (props: UsePostDelegateProps) =>
  useGet<DelegateResponseData, unknown, PostDelegateQueryParams, void>(`/delegate-tasks`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * Create a delegate tasks
 */
export const postDelegatePromise = (
  props: GetUsingFetchProps<DelegateResponseData, unknown, PostDelegateQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<DelegateResponseData, unknown, PostDelegateQueryParams, void>(
    getConfig('ng/api'),
    `/delegate-tasks`,
    props,
    signal
  )

export interface CreateSamplePTaskQueryParams {
  accountId?: string
  country?: string
  population?: number
}

export type CreateSamplePTaskProps = Omit<
  MutateProps<RestResponseString, unknown, CreateSamplePTaskQueryParams, void, void>,
  'path' | 'verb'
>

/**
 * Create a sample perpetual task
 */
export const CreateSamplePTask = (props: CreateSamplePTaskProps) => (
  <Mutate<RestResponseString, unknown, CreateSamplePTaskQueryParams, void, void>
    verb="POST"
    path={`/delegate-tasks/perpetual-tasks/sample`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseCreateSamplePTaskProps = Omit<
  UseMutateProps<RestResponseString, unknown, CreateSamplePTaskQueryParams, void, void>,
  'path' | 'verb'
>

/**
 * Create a sample perpetual task
 */
export const useCreateSamplePTask = (props: UseCreateSamplePTaskProps) =>
  useMutate<RestResponseString, unknown, CreateSamplePTaskQueryParams, void, void>(
    'POST',
    `/delegate-tasks/perpetual-tasks/sample`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Create a sample perpetual task
 */
export const createSamplePTaskPromise = (
  props: MutateUsingFetchProps<RestResponseString, unknown, CreateSamplePTaskQueryParams, void, void>,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<RestResponseString, unknown, CreateSamplePTaskQueryParams, void, void>(
    'POST',
    getConfig('ng/api'),
    `/delegate-tasks/perpetual-tasks/sample`,
    props,
    signal
  )

export interface ResetSamplePTaskQueryParams {
  accountId?: string
  country?: string
  population?: number
}

export interface ResetSamplePTaskPathParams {
  taskId: string
}

export type ResetSamplePTaskProps = Omit<
  MutateProps<RestResponseBoolean, unknown, ResetSamplePTaskQueryParams, void, ResetSamplePTaskPathParams>,
  'path' | 'verb'
> &
  ResetSamplePTaskPathParams

/**
 * reset sample perpetual task
 */
export const ResetSamplePTask = ({ taskId, ...props }: ResetSamplePTaskProps) => (
  <Mutate<RestResponseBoolean, unknown, ResetSamplePTaskQueryParams, void, ResetSamplePTaskPathParams>
    verb="PUT"
    path={`/delegate-tasks/perpetual-tasks/sample/${taskId}`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseResetSamplePTaskProps = Omit<
  UseMutateProps<RestResponseBoolean, unknown, ResetSamplePTaskQueryParams, void, ResetSamplePTaskPathParams>,
  'path' | 'verb'
> &
  ResetSamplePTaskPathParams

/**
 * reset sample perpetual task
 */
export const useResetSamplePTask = ({ taskId, ...props }: UseResetSamplePTaskProps) =>
  useMutate<RestResponseBoolean, unknown, ResetSamplePTaskQueryParams, void, ResetSamplePTaskPathParams>(
    'PUT',
    (paramsInPath: ResetSamplePTaskPathParams) => `/delegate-tasks/perpetual-tasks/sample/${paramsInPath.taskId}`,
    { base: getConfig('ng/api'), pathParams: { taskId }, ...props }
  )

/**
 * reset sample perpetual task
 */
export const resetSamplePTaskPromise = (
  {
    taskId,
    ...props
  }: MutateUsingFetchProps<
    RestResponseBoolean,
    unknown,
    ResetSamplePTaskQueryParams,
    void,
    ResetSamplePTaskPathParams
  > & { taskId: string },
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<RestResponseBoolean, unknown, ResetSamplePTaskQueryParams, void, ResetSamplePTaskPathParams>(
    'PUT',
    getConfig('ng/api'),
    `/delegate-tasks/perpetual-tasks/sample/${taskId}`,
    props,
    signal
  )

export interface DeleteSamplePTaskQueryParams {
  accountId?: string
}

export type DeleteSamplePTaskProps = Omit<
  MutateProps<RestResponseBoolean, unknown, DeleteSamplePTaskQueryParams, string, void>,
  'path' | 'verb'
>

/**
 * delete sample perpetual task
 */
export const DeleteSamplePTask = (props: DeleteSamplePTaskProps) => (
  <Mutate<RestResponseBoolean, unknown, DeleteSamplePTaskQueryParams, string, void>
    verb="DELETE"
    path={`/delegate-tasks/perpetual-tasks/sample`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseDeleteSamplePTaskProps = Omit<
  UseMutateProps<RestResponseBoolean, unknown, DeleteSamplePTaskQueryParams, string, void>,
  'path' | 'verb'
>

/**
 * delete sample perpetual task
 */
export const useDeleteSamplePTask = (props: UseDeleteSamplePTaskProps) =>
  useMutate<RestResponseBoolean, unknown, DeleteSamplePTaskQueryParams, string, void>(
    'DELETE',
    `/delegate-tasks/perpetual-tasks/sample`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * delete sample perpetual task
 */
export const deleteSamplePTaskPromise = (
  props: MutateUsingFetchProps<RestResponseBoolean, unknown, DeleteSamplePTaskQueryParams, string, void>,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<RestResponseBoolean, unknown, DeleteSamplePTaskQueryParams, string, void>(
    'DELETE',
    getConfig('ng/api'),
    `/delegate-tasks/perpetual-tasks/sample`,
    props,
    signal
  )

export interface PutSecretFileViaYamlPathParams {
  identifier: string
}

export type PutSecretFileViaYamlProps = Omit<
  MutateProps<
    ResponseDTOBoolean,
    FailureDTO | ErrorDTO,
    void,
    SecretFileDTORequestBody,
    PutSecretFileViaYamlPathParams
  >,
  'path' | 'verb'
> &
  PutSecretFileViaYamlPathParams

/**
 * Update a secret file via yaml
 */
export const PutSecretFileViaYaml = ({ identifier, ...props }: PutSecretFileViaYamlProps) => (
  <Mutate<ResponseDTOBoolean, FailureDTO | ErrorDTO, void, SecretFileDTORequestBody, PutSecretFileViaYamlPathParams>
    verb="PUT"
    path={`/secrets/files/${identifier}/yaml`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UsePutSecretFileViaYamlProps = Omit<
  UseMutateProps<
    ResponseDTOBoolean,
    FailureDTO | ErrorDTO,
    void,
    SecretFileDTORequestBody,
    PutSecretFileViaYamlPathParams
  >,
  'path' | 'verb'
> &
  PutSecretFileViaYamlPathParams

/**
 * Update a secret file via yaml
 */
export const usePutSecretFileViaYaml = ({ identifier, ...props }: UsePutSecretFileViaYamlProps) =>
  useMutate<ResponseDTOBoolean, FailureDTO | ErrorDTO, void, SecretFileDTORequestBody, PutSecretFileViaYamlPathParams>(
    'PUT',
    (paramsInPath: PutSecretFileViaYamlPathParams) => `/secrets/files/${paramsInPath.identifier}/yaml`,
    { base: getConfig('ng/api'), pathParams: { identifier }, ...props }
  )

/**
 * Update a secret file via yaml
 */
export const putSecretFileViaYamlPromise = (
  {
    identifier,
    ...props
  }: MutateUsingFetchProps<
    ResponseDTOBoolean,
    FailureDTO | ErrorDTO,
    void,
    SecretFileDTORequestBody,
    PutSecretFileViaYamlPathParams
  > & { identifier: string },
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseDTOBoolean,
    FailureDTO | ErrorDTO,
    void,
    SecretFileDTORequestBody,
    PutSecretFileViaYamlPathParams
  >('PUT', getConfig('ng/api'), `/secrets/files/${identifier}/yaml`, props, signal)

export interface PutSecretFilePathParams {
  identifier: string
}

export type PutSecretFileProps = Omit<
  MutateProps<ResponseDTOBoolean, FailureDTO | ErrorDTO, void, void, PutSecretFilePathParams>,
  'path' | 'verb'
> &
  PutSecretFilePathParams

/**
 * Update a secret file
 */
export const PutSecretFile = ({ identifier, ...props }: PutSecretFileProps) => (
  <Mutate<ResponseDTOBoolean, FailureDTO | ErrorDTO, void, void, PutSecretFilePathParams>
    verb="PUT"
    path={`/secrets/files/${identifier}`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UsePutSecretFileProps = Omit<
  UseMutateProps<ResponseDTOBoolean, FailureDTO | ErrorDTO, void, void, PutSecretFilePathParams>,
  'path' | 'verb'
> &
  PutSecretFilePathParams

/**
 * Update a secret file
 */
export const usePutSecretFile = ({ identifier, ...props }: UsePutSecretFileProps) =>
  useMutate<ResponseDTOBoolean, FailureDTO | ErrorDTO, void, void, PutSecretFilePathParams>(
    'PUT',
    (paramsInPath: PutSecretFilePathParams) => `/secrets/files/${paramsInPath.identifier}`,
    { base: getConfig('ng/api'), pathParams: { identifier }, ...props }
  )

/**
 * Update a secret file
 */
export const putSecretFilePromise = (
  {
    identifier,
    ...props
  }: MutateUsingFetchProps<ResponseDTOBoolean, FailureDTO | ErrorDTO, void, void, PutSecretFilePathParams> & {
    identifier: string
  },
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<ResponseDTOBoolean, FailureDTO | ErrorDTO, void, void, PutSecretFilePathParams>(
    'PUT',
    getConfig('ng/api'),
    `/secrets/files/${identifier}`,
    props,
    signal
  )

export type PostSecretFileViaYamlProps = Omit<
  MutateProps<ResponseDTOEncryptedDataDTO, FailureDTO | ErrorDTO, void, SecretFileDTORequestBody, void>,
  'path' | 'verb'
>

/**
 * Create a secret file via yaml
 */
export const PostSecretFileViaYaml = (props: PostSecretFileViaYamlProps) => (
  <Mutate<ResponseDTOEncryptedDataDTO, FailureDTO | ErrorDTO, void, SecretFileDTORequestBody, void>
    verb="POST"
    path={`/secrets/files/yaml`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UsePostSecretFileViaYamlProps = Omit<
  UseMutateProps<ResponseDTOEncryptedDataDTO, FailureDTO | ErrorDTO, void, SecretFileDTORequestBody, void>,
  'path' | 'verb'
>

/**
 * Create a secret file via yaml
 */
export const usePostSecretFileViaYaml = (props: UsePostSecretFileViaYamlProps) =>
  useMutate<ResponseDTOEncryptedDataDTO, FailureDTO | ErrorDTO, void, SecretFileDTORequestBody, void>(
    'POST',
    `/secrets/files/yaml`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Create a secret file via yaml
 */
export const postSecretFileViaYamlPromise = (
  props: MutateUsingFetchProps<
    ResponseDTOEncryptedDataDTO,
    FailureDTO | ErrorDTO,
    void,
    SecretFileDTORequestBody,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<ResponseDTOEncryptedDataDTO, FailureDTO | ErrorDTO, void, SecretFileDTORequestBody, void>(
    'POST',
    getConfig('ng/api'),
    `/secrets/files/yaml`,
    props,
    signal
  )

export interface GetSecretManagerByIdentifierQueryParams {
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
}

export interface GetSecretManagerByIdentifierPathParams {
  identifier: string
}

export type GetSecretManagerByIdentifierProps = Omit<
  GetProps<
    ResponseDTOSecretManagerConfigDTO,
    FailureDTO | ErrorDTO,
    GetSecretManagerByIdentifierQueryParams,
    GetSecretManagerByIdentifierPathParams
  >,
  'path'
> &
  GetSecretManagerByIdentifierPathParams

/**
 * Get a secret manager by identifier
 */
export const GetSecretManagerByIdentifier = ({ identifier, ...props }: GetSecretManagerByIdentifierProps) => (
  <Get<
    ResponseDTOSecretManagerConfigDTO,
    FailureDTO | ErrorDTO,
    GetSecretManagerByIdentifierQueryParams,
    GetSecretManagerByIdentifierPathParams
  >
    path={`/secret-managers/${identifier}`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetSecretManagerByIdentifierProps = Omit<
  UseGetProps<
    ResponseDTOSecretManagerConfigDTO,
    FailureDTO | ErrorDTO,
    GetSecretManagerByIdentifierQueryParams,
    GetSecretManagerByIdentifierPathParams
  >,
  'path'
> &
  GetSecretManagerByIdentifierPathParams

/**
 * Get a secret manager by identifier
 */
export const useGetSecretManagerByIdentifier = ({ identifier, ...props }: UseGetSecretManagerByIdentifierProps) =>
  useGet<
    ResponseDTOSecretManagerConfigDTO,
    FailureDTO | ErrorDTO,
    GetSecretManagerByIdentifierQueryParams,
    GetSecretManagerByIdentifierPathParams
  >((paramsInPath: GetSecretManagerByIdentifierPathParams) => `/secret-managers/${paramsInPath.identifier}`, {
    base: getConfig('ng/api'),
    pathParams: { identifier },
    ...props
  })

/**
 * Get a secret manager by identifier
 */
export const getSecretManagerByIdentifierPromise = (
  {
    identifier,
    ...props
  }: GetUsingFetchProps<
    ResponseDTOSecretManagerConfigDTO,
    FailureDTO | ErrorDTO,
    GetSecretManagerByIdentifierQueryParams,
    GetSecretManagerByIdentifierPathParams
  > & { identifier: string },
  signal?: RequestInit['signal']
) =>
  getUsingFetch<
    ResponseDTOSecretManagerConfigDTO,
    FailureDTO | ErrorDTO,
    GetSecretManagerByIdentifierQueryParams,
    GetSecretManagerByIdentifierPathParams
  >(getConfig('ng/api'), `/secret-managers/${identifier}`, props, signal)

export interface UpdateSecretManagerQueryParams {
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
}

export interface UpdateSecretManagerPathParams {
  identifier: string
}

export type UpdateSecretManagerProps = Omit<
  MutateProps<
    ResponseDTOSecretManagerConfigDTO,
    FailureDTO | ErrorDTO,
    UpdateSecretManagerQueryParams,
    SecretManagerConfigUpdateDTO,
    UpdateSecretManagerPathParams
  >,
  'path' | 'verb'
> &
  UpdateSecretManagerPathParams

/**
 * Update secret manager
 */
export const UpdateSecretManager = ({ identifier, ...props }: UpdateSecretManagerProps) => (
  <Mutate<
    ResponseDTOSecretManagerConfigDTO,
    FailureDTO | ErrorDTO,
    UpdateSecretManagerQueryParams,
    SecretManagerConfigUpdateDTO,
    UpdateSecretManagerPathParams
  >
    verb="PUT"
    path={`/secret-managers/${identifier}`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseUpdateSecretManagerProps = Omit<
  UseMutateProps<
    ResponseDTOSecretManagerConfigDTO,
    FailureDTO | ErrorDTO,
    UpdateSecretManagerQueryParams,
    SecretManagerConfigUpdateDTO,
    UpdateSecretManagerPathParams
  >,
  'path' | 'verb'
> &
  UpdateSecretManagerPathParams

/**
 * Update secret manager
 */
export const useUpdateSecretManager = ({ identifier, ...props }: UseUpdateSecretManagerProps) =>
  useMutate<
    ResponseDTOSecretManagerConfigDTO,
    FailureDTO | ErrorDTO,
    UpdateSecretManagerQueryParams,
    SecretManagerConfigUpdateDTO,
    UpdateSecretManagerPathParams
  >('PUT', (paramsInPath: UpdateSecretManagerPathParams) => `/secret-managers/${paramsInPath.identifier}`, {
    base: getConfig('ng/api'),
    pathParams: { identifier },
    ...props
  })

/**
 * Update secret manager
 */
export const updateSecretManagerPromise = (
  {
    identifier,
    ...props
  }: MutateUsingFetchProps<
    ResponseDTOSecretManagerConfigDTO,
    FailureDTO | ErrorDTO,
    UpdateSecretManagerQueryParams,
    SecretManagerConfigUpdateDTO,
    UpdateSecretManagerPathParams
  > & { identifier: string },
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseDTOSecretManagerConfigDTO,
    FailureDTO | ErrorDTO,
    UpdateSecretManagerQueryParams,
    SecretManagerConfigUpdateDTO,
    UpdateSecretManagerPathParams
  >('PUT', getConfig('ng/api'), `/secret-managers/${identifier}`, props, signal)

export interface DeleteSecretManagerQueryParams {
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
}

export type DeleteSecretManagerProps = Omit<
  MutateProps<ResponseDTOBoolean, FailureDTO | ErrorDTO, DeleteSecretManagerQueryParams, string, void>,
  'path' | 'verb'
>

/**
 * Delete secret manager
 */
export const DeleteSecretManager = (props: DeleteSecretManagerProps) => (
  <Mutate<ResponseDTOBoolean, FailureDTO | ErrorDTO, DeleteSecretManagerQueryParams, string, void>
    verb="DELETE"
    path={`/secret-managers`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseDeleteSecretManagerProps = Omit<
  UseMutateProps<ResponseDTOBoolean, FailureDTO | ErrorDTO, DeleteSecretManagerQueryParams, string, void>,
  'path' | 'verb'
>

/**
 * Delete secret manager
 */
export const useDeleteSecretManager = (props: UseDeleteSecretManagerProps) =>
  useMutate<ResponseDTOBoolean, FailureDTO | ErrorDTO, DeleteSecretManagerQueryParams, string, void>(
    'DELETE',
    `/secret-managers`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Delete secret manager
 */
export const deleteSecretManagerPromise = (
  props: MutateUsingFetchProps<ResponseDTOBoolean, FailureDTO | ErrorDTO, DeleteSecretManagerQueryParams, string, void>,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<ResponseDTOBoolean, FailureDTO | ErrorDTO, DeleteSecretManagerQueryParams, string, void>(
    'DELETE',
    getConfig('ng/api'),
    `/secret-managers`,
    props,
    signal
  )

export interface ListSecretManagersQueryParams {
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
}

export type ListSecretManagersProps = Omit<
  GetProps<ResponseDTOListSecretManagerConfigDTO, FailureDTO | ErrorDTO, ListSecretManagersQueryParams, void>,
  'path'
>

/**
 * Get secret managers
 */
export const ListSecretManagers = (props: ListSecretManagersProps) => (
  <Get<ResponseDTOListSecretManagerConfigDTO, FailureDTO | ErrorDTO, ListSecretManagersQueryParams, void>
    path={`/secret-managers`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseListSecretManagersProps = Omit<
  UseGetProps<ResponseDTOListSecretManagerConfigDTO, FailureDTO | ErrorDTO, ListSecretManagersQueryParams, void>,
  'path'
>

/**
 * Get secret managers
 */
export const useListSecretManagers = (props: UseListSecretManagersProps) =>
  useGet<ResponseDTOListSecretManagerConfigDTO, FailureDTO | ErrorDTO, ListSecretManagersQueryParams, void>(
    `/secret-managers`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Get secret managers
 */
export const listSecretManagersPromise = (
  props: GetUsingFetchProps<
    ResponseDTOListSecretManagerConfigDTO,
    FailureDTO | ErrorDTO,
    ListSecretManagersQueryParams,
    void
  >,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseDTOListSecretManagerConfigDTO, FailureDTO | ErrorDTO, ListSecretManagersQueryParams, void>(
    getConfig('ng/api'),
    `/secret-managers`,
    props,
    signal
  )

export type CreateSecretManagerProps = Omit<
  MutateProps<ResponseDTOSecretManagerConfigDTO, FailureDTO | ErrorDTO, void, SecretManagerConfigDTO, void>,
  'path' | 'verb'
>

/**
 * Create a secret manager
 */
export const CreateSecretManager = (props: CreateSecretManagerProps) => (
  <Mutate<ResponseDTOSecretManagerConfigDTO, FailureDTO | ErrorDTO, void, SecretManagerConfigDTO, void>
    verb="POST"
    path={`/secret-managers`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseCreateSecretManagerProps = Omit<
  UseMutateProps<ResponseDTOSecretManagerConfigDTO, FailureDTO | ErrorDTO, void, SecretManagerConfigDTO, void>,
  'path' | 'verb'
>

/**
 * Create a secret manager
 */
export const useCreateSecretManager = (props: UseCreateSecretManagerProps) =>
  useMutate<ResponseDTOSecretManagerConfigDTO, FailureDTO | ErrorDTO, void, SecretManagerConfigDTO, void>(
    'POST',
    `/secret-managers`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Create a secret manager
 */
export const createSecretManagerPromise = (
  props: MutateUsingFetchProps<
    ResponseDTOSecretManagerConfigDTO,
    FailureDTO | ErrorDTO,
    void,
    SecretManagerConfigDTO,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<ResponseDTOSecretManagerConfigDTO, FailureDTO | ErrorDTO, void, SecretManagerConfigDTO, void>(
    'POST',
    getConfig('ng/api'),
    `/secret-managers`,
    props,
    signal
  )

export interface GetSecretQueryParams {
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
}

export interface GetSecretPathParams {
  identifier: string
}

export type GetSecretProps = Omit<
  GetProps<ResponseDTOEncryptedDataDTO, FailureDTO | ErrorDTO, GetSecretQueryParams, GetSecretPathParams>,
  'path'
> &
  GetSecretPathParams

/**
 * Gets secret
 */
export const GetSecret = ({ identifier, ...props }: GetSecretProps) => (
  <Get<ResponseDTOEncryptedDataDTO, FailureDTO | ErrorDTO, GetSecretQueryParams, GetSecretPathParams>
    path={`/secrets/${identifier}`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetSecretProps = Omit<
  UseGetProps<ResponseDTOEncryptedDataDTO, FailureDTO | ErrorDTO, GetSecretQueryParams, GetSecretPathParams>,
  'path'
> &
  GetSecretPathParams

/**
 * Gets secret
 */
export const useGetSecret = ({ identifier, ...props }: UseGetSecretProps) =>
  useGet<ResponseDTOEncryptedDataDTO, FailureDTO | ErrorDTO, GetSecretQueryParams, GetSecretPathParams>(
    (paramsInPath: GetSecretPathParams) => `/secrets/${paramsInPath.identifier}`,
    { base: getConfig('ng/api'), pathParams: { identifier }, ...props }
  )

/**
 * Gets secret
 */
export const getSecretPromise = (
  {
    identifier,
    ...props
  }: GetUsingFetchProps<
    ResponseDTOEncryptedDataDTO,
    FailureDTO | ErrorDTO,
    GetSecretQueryParams,
    GetSecretPathParams
  > & { identifier: string },
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseDTOEncryptedDataDTO, FailureDTO | ErrorDTO, GetSecretQueryParams, GetSecretPathParams>(
    getConfig('ng/api'),
    `/secrets/${identifier}`,
    props,
    signal
  )

export interface PutSecretTextPathParams {
  identifier: string
}

export type PutSecretTextProps = Omit<
  MutateProps<ResponseDTOBoolean, FailureDTO | ErrorDTO, void, SecretTextDTO2RequestBody, PutSecretTextPathParams>,
  'path' | 'verb'
> &
  PutSecretTextPathParams

/**
 * Update a secret text
 */
export const PutSecretText = ({ identifier, ...props }: PutSecretTextProps) => (
  <Mutate<ResponseDTOBoolean, FailureDTO | ErrorDTO, void, SecretTextDTO2RequestBody, PutSecretTextPathParams>
    verb="PUT"
    path={`/secrets/${identifier}`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UsePutSecretTextProps = Omit<
  UseMutateProps<ResponseDTOBoolean, FailureDTO | ErrorDTO, void, SecretTextDTO2RequestBody, PutSecretTextPathParams>,
  'path' | 'verb'
> &
  PutSecretTextPathParams

/**
 * Update a secret text
 */
export const usePutSecretText = ({ identifier, ...props }: UsePutSecretTextProps) =>
  useMutate<ResponseDTOBoolean, FailureDTO | ErrorDTO, void, SecretTextDTO2RequestBody, PutSecretTextPathParams>(
    'PUT',
    (paramsInPath: PutSecretTextPathParams) => `/secrets/${paramsInPath.identifier}`,
    { base: getConfig('ng/api'), pathParams: { identifier }, ...props }
  )

/**
 * Update a secret text
 */
export const putSecretTextPromise = (
  {
    identifier,
    ...props
  }: MutateUsingFetchProps<
    ResponseDTOBoolean,
    FailureDTO | ErrorDTO,
    void,
    SecretTextDTO2RequestBody,
    PutSecretTextPathParams
  > & { identifier: string },
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<ResponseDTOBoolean, FailureDTO | ErrorDTO, void, SecretTextDTO2RequestBody, PutSecretTextPathParams>(
    'PUT',
    getConfig('ng/api'),
    `/secrets/${identifier}`,
    props,
    signal
  )

export interface DeleteSecretQueryParams {
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
}

export type DeleteSecretProps = Omit<
  MutateProps<ResponseDTOBoolean, FailureDTO | ErrorDTO, DeleteSecretQueryParams, string, void>,
  'path' | 'verb'
>

/**
 * Delete a secret text
 */
export const DeleteSecret = (props: DeleteSecretProps) => (
  <Mutate<ResponseDTOBoolean, FailureDTO | ErrorDTO, DeleteSecretQueryParams, string, void>
    verb="DELETE"
    path={`/secrets`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseDeleteSecretProps = Omit<
  UseMutateProps<ResponseDTOBoolean, FailureDTO | ErrorDTO, DeleteSecretQueryParams, string, void>,
  'path' | 'verb'
>

/**
 * Delete a secret text
 */
export const useDeleteSecret = (props: UseDeleteSecretProps) =>
  useMutate<ResponseDTOBoolean, FailureDTO | ErrorDTO, DeleteSecretQueryParams, string, void>('DELETE', `/secrets`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * Delete a secret text
 */
export const deleteSecretPromise = (
  props: MutateUsingFetchProps<ResponseDTOBoolean, FailureDTO | ErrorDTO, DeleteSecretQueryParams, string, void>,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<ResponseDTOBoolean, FailureDTO | ErrorDTO, DeleteSecretQueryParams, string, void>(
    'DELETE',
    getConfig('ng/api'),
    `/secrets`,
    props,
    signal
  )

export interface PutSecretTextViaYamlPathParams {
  identifier: string
}

export type PutSecretTextViaYamlProps = Omit<
  MutateProps<
    ResponseDTOBoolean,
    FailureDTO | ErrorDTO,
    void,
    SecretTextDTORequestBody,
    PutSecretTextViaYamlPathParams
  >,
  'path' | 'verb'
> &
  PutSecretTextViaYamlPathParams

/**
 * Update a secret text via yaml
 */
export const PutSecretTextViaYaml = ({ identifier, ...props }: PutSecretTextViaYamlProps) => (
  <Mutate<ResponseDTOBoolean, FailureDTO | ErrorDTO, void, SecretTextDTORequestBody, PutSecretTextViaYamlPathParams>
    verb="PUT"
    path={`/secrets/${identifier}/yaml`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UsePutSecretTextViaYamlProps = Omit<
  UseMutateProps<
    ResponseDTOBoolean,
    FailureDTO | ErrorDTO,
    void,
    SecretTextDTORequestBody,
    PutSecretTextViaYamlPathParams
  >,
  'path' | 'verb'
> &
  PutSecretTextViaYamlPathParams

/**
 * Update a secret text via yaml
 */
export const usePutSecretTextViaYaml = ({ identifier, ...props }: UsePutSecretTextViaYamlProps) =>
  useMutate<ResponseDTOBoolean, FailureDTO | ErrorDTO, void, SecretTextDTORequestBody, PutSecretTextViaYamlPathParams>(
    'PUT',
    (paramsInPath: PutSecretTextViaYamlPathParams) => `/secrets/${paramsInPath.identifier}/yaml`,
    { base: getConfig('ng/api'), pathParams: { identifier }, ...props }
  )

/**
 * Update a secret text via yaml
 */
export const putSecretTextViaYamlPromise = (
  {
    identifier,
    ...props
  }: MutateUsingFetchProps<
    ResponseDTOBoolean,
    FailureDTO | ErrorDTO,
    void,
    SecretTextDTORequestBody,
    PutSecretTextViaYamlPathParams
  > & { identifier: string },
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseDTOBoolean,
    FailureDTO | ErrorDTO,
    void,
    SecretTextDTORequestBody,
    PutSecretTextViaYamlPathParams
  >('PUT', getConfig('ng/api'), `/secrets/${identifier}/yaml`, props, signal)

export interface ListSecretsQueryParams {
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
  type?: 'SecretFile' | 'SecretText' | 'SSHKey'
  searchTerm?: string
  page?: number
  size?: number
}

export type ListSecretsProps = Omit<
  GetProps<ResponseDTONGPageResponseEncryptedDataDTO, FailureDTO | ErrorDTO, ListSecretsQueryParams, void>,
  'path'
>

/**
 * Get secrets for an account
 */
export const ListSecrets = (props: ListSecretsProps) => (
  <Get<ResponseDTONGPageResponseEncryptedDataDTO, FailureDTO | ErrorDTO, ListSecretsQueryParams, void>
    path={`/secrets`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseListSecretsProps = Omit<
  UseGetProps<ResponseDTONGPageResponseEncryptedDataDTO, FailureDTO | ErrorDTO, ListSecretsQueryParams, void>,
  'path'
>

/**
 * Get secrets for an account
 */
export const useListSecrets = (props: UseListSecretsProps) =>
  useGet<ResponseDTONGPageResponseEncryptedDataDTO, FailureDTO | ErrorDTO, ListSecretsQueryParams, void>(`/secrets`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * Get secrets for an account
 */
export const listSecretsPromise = (
  props: GetUsingFetchProps<
    ResponseDTONGPageResponseEncryptedDataDTO,
    FailureDTO | ErrorDTO,
    ListSecretsQueryParams,
    void
  >,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseDTONGPageResponseEncryptedDataDTO, FailureDTO | ErrorDTO, ListSecretsQueryParams, void>(
    getConfig('ng/api'),
    `/secrets`,
    props,
    signal
  )

export type PostSecretTextProps = Omit<
  MutateProps<ResponseDTOEncryptedDataDTO, FailureDTO | ErrorDTO, void, SecretTextDTO2RequestBody, void>,
  'path' | 'verb'
>

/**
 * Create a secret text
 */
export const PostSecretText = (props: PostSecretTextProps) => (
  <Mutate<ResponseDTOEncryptedDataDTO, FailureDTO | ErrorDTO, void, SecretTextDTO2RequestBody, void>
    verb="POST"
    path={`/secrets`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UsePostSecretTextProps = Omit<
  UseMutateProps<ResponseDTOEncryptedDataDTO, FailureDTO | ErrorDTO, void, SecretTextDTO2RequestBody, void>,
  'path' | 'verb'
>

/**
 * Create a secret text
 */
export const usePostSecretText = (props: UsePostSecretTextProps) =>
  useMutate<ResponseDTOEncryptedDataDTO, FailureDTO | ErrorDTO, void, SecretTextDTO2RequestBody, void>(
    'POST',
    `/secrets`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Create a secret text
 */
export const postSecretTextPromise = (
  props: MutateUsingFetchProps<
    ResponseDTOEncryptedDataDTO,
    FailureDTO | ErrorDTO,
    void,
    SecretTextDTO2RequestBody,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<ResponseDTOEncryptedDataDTO, FailureDTO | ErrorDTO, void, SecretTextDTO2RequestBody, void>(
    'POST',
    getConfig('ng/api'),
    `/secrets`,
    props,
    signal
  )

export type PostSecretTextViaYamlProps = Omit<
  MutateProps<ResponseDTOEncryptedDataDTO, FailureDTO | ErrorDTO, void, SecretTextDTORequestBody, void>,
  'path' | 'verb'
>

/**
 * Create a secret text via yaml
 */
export const PostSecretTextViaYaml = (props: PostSecretTextViaYamlProps) => (
  <Mutate<ResponseDTOEncryptedDataDTO, FailureDTO | ErrorDTO, void, SecretTextDTORequestBody, void>
    verb="POST"
    path={`/secrets/yaml`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UsePostSecretTextViaYamlProps = Omit<
  UseMutateProps<ResponseDTOEncryptedDataDTO, FailureDTO | ErrorDTO, void, SecretTextDTORequestBody, void>,
  'path' | 'verb'
>

/**
 * Create a secret text via yaml
 */
export const usePostSecretTextViaYaml = (props: UsePostSecretTextViaYamlProps) =>
  useMutate<ResponseDTOEncryptedDataDTO, FailureDTO | ErrorDTO, void, SecretTextDTORequestBody, void>(
    'POST',
    `/secrets/yaml`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Create a secret text via yaml
 */
export const postSecretTextViaYamlPromise = (
  props: MutateUsingFetchProps<
    ResponseDTOEncryptedDataDTO,
    FailureDTO | ErrorDTO,
    void,
    SecretTextDTORequestBody,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<ResponseDTOEncryptedDataDTO, FailureDTO | ErrorDTO, void, SecretTextDTORequestBody, void>(
    'POST',
    getConfig('ng/api'),
    `/secrets/yaml`,
    props,
    signal
  )

export interface GetSecretV2QueryParams {
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
}

export interface GetSecretV2PathParams {
  identifier: string
}

export type GetSecretV2Props = Omit<
  GetProps<ResponseDTOSecretResponseWrapper, FailureDTO | ErrorDTO, GetSecretV2QueryParams, GetSecretV2PathParams>,
  'path'
> &
  GetSecretV2PathParams

/**
 * Gets secret
 */
export const GetSecretV2 = ({ identifier, ...props }: GetSecretV2Props) => (
  <Get<ResponseDTOSecretResponseWrapper, FailureDTO | ErrorDTO, GetSecretV2QueryParams, GetSecretV2PathParams>
    path={`/v2/secrets/${identifier}`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetSecretV2Props = Omit<
  UseGetProps<ResponseDTOSecretResponseWrapper, FailureDTO | ErrorDTO, GetSecretV2QueryParams, GetSecretV2PathParams>,
  'path'
> &
  GetSecretV2PathParams

/**
 * Gets secret
 */
export const useGetSecretV2 = ({ identifier, ...props }: UseGetSecretV2Props) =>
  useGet<ResponseDTOSecretResponseWrapper, FailureDTO | ErrorDTO, GetSecretV2QueryParams, GetSecretV2PathParams>(
    (paramsInPath: GetSecretV2PathParams) => `/v2/secrets/${paramsInPath.identifier}`,
    { base: getConfig('ng/api'), pathParams: { identifier }, ...props }
  )

/**
 * Gets secret
 */
export const getSecretV2Promise = (
  {
    identifier,
    ...props
  }: GetUsingFetchProps<
    ResponseDTOSecretResponseWrapper,
    FailureDTO | ErrorDTO,
    GetSecretV2QueryParams,
    GetSecretV2PathParams
  > & { identifier: string },
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseDTOSecretResponseWrapper, FailureDTO | ErrorDTO, GetSecretV2QueryParams, GetSecretV2PathParams>(
    getConfig('ng/api'),
    `/v2/secrets/${identifier}`,
    props,
    signal
  )

export interface PutSecretQueryParams {
  accountIdentifier: string
}

export interface PutSecretPathParams {
  identifier: string
}

export type PutSecretProps = Omit<
  MutateProps<
    ResponseDTOBoolean,
    FailureDTO | ErrorDTO,
    PutSecretQueryParams,
    SecretRequestWrapperRequestBody,
    PutSecretPathParams
  >,
  'path' | 'verb'
> &
  PutSecretPathParams

/**
 * Update a secret
 */
export const PutSecret = ({ identifier, ...props }: PutSecretProps) => (
  <Mutate<
    ResponseDTOBoolean,
    FailureDTO | ErrorDTO,
    PutSecretQueryParams,
    SecretRequestWrapperRequestBody,
    PutSecretPathParams
  >
    verb="PUT"
    path={`/v2/secrets/${identifier}`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UsePutSecretProps = Omit<
  UseMutateProps<
    ResponseDTOBoolean,
    FailureDTO | ErrorDTO,
    PutSecretQueryParams,
    SecretRequestWrapperRequestBody,
    PutSecretPathParams
  >,
  'path' | 'verb'
> &
  PutSecretPathParams

/**
 * Update a secret
 */
export const usePutSecret = ({ identifier, ...props }: UsePutSecretProps) =>
  useMutate<
    ResponseDTOBoolean,
    FailureDTO | ErrorDTO,
    PutSecretQueryParams,
    SecretRequestWrapperRequestBody,
    PutSecretPathParams
  >('PUT', (paramsInPath: PutSecretPathParams) => `/v2/secrets/${paramsInPath.identifier}`, {
    base: getConfig('ng/api'),
    pathParams: { identifier },
    ...props
  })

/**
 * Update a secret
 */
export const putSecretPromise = (
  {
    identifier,
    ...props
  }: MutateUsingFetchProps<
    ResponseDTOBoolean,
    FailureDTO | ErrorDTO,
    PutSecretQueryParams,
    SecretRequestWrapperRequestBody,
    PutSecretPathParams
  > & { identifier: string },
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseDTOBoolean,
    FailureDTO | ErrorDTO,
    PutSecretQueryParams,
    SecretRequestWrapperRequestBody,
    PutSecretPathParams
  >('PUT', getConfig('ng/api'), `/v2/secrets/${identifier}`, props, signal)

export interface DeleteSecretV2QueryParams {
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
}

export type DeleteSecretV2Props = Omit<
  MutateProps<ResponseDTOBoolean, FailureDTO | ErrorDTO, DeleteSecretV2QueryParams, string, void>,
  'path' | 'verb'
>

/**
 * Delete secret
 */
export const DeleteSecretV2 = (props: DeleteSecretV2Props) => (
  <Mutate<ResponseDTOBoolean, FailureDTO | ErrorDTO, DeleteSecretV2QueryParams, string, void>
    verb="DELETE"
    path={`/v2/secrets`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseDeleteSecretV2Props = Omit<
  UseMutateProps<ResponseDTOBoolean, FailureDTO | ErrorDTO, DeleteSecretV2QueryParams, string, void>,
  'path' | 'verb'
>

/**
 * Delete secret
 */
export const useDeleteSecretV2 = (props: UseDeleteSecretV2Props) =>
  useMutate<ResponseDTOBoolean, FailureDTO | ErrorDTO, DeleteSecretV2QueryParams, string, void>(
    'DELETE',
    `/v2/secrets`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Delete secret
 */
export const deleteSecretV2Promise = (
  props: MutateUsingFetchProps<ResponseDTOBoolean, FailureDTO | ErrorDTO, DeleteSecretV2QueryParams, string, void>,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<ResponseDTOBoolean, FailureDTO | ErrorDTO, DeleteSecretV2QueryParams, string, void>(
    'DELETE',
    getConfig('ng/api'),
    `/v2/secrets`,
    props,
    signal
  )

export interface PutSecretViaYamlQueryParams {
  accountIdentifier: string
}

export interface PutSecretViaYamlPathParams {
  identifier: string
}

export type PutSecretViaYamlProps = Omit<
  MutateProps<
    ResponseDTOBoolean,
    FailureDTO | ErrorDTO,
    PutSecretViaYamlQueryParams,
    SecretRequestWrapper2RequestBody,
    PutSecretViaYamlPathParams
  >,
  'path' | 'verb'
> &
  PutSecretViaYamlPathParams

/**
 * Update a secret via yaml
 */
export const PutSecretViaYaml = ({ identifier, ...props }: PutSecretViaYamlProps) => (
  <Mutate<
    ResponseDTOBoolean,
    FailureDTO | ErrorDTO,
    PutSecretViaYamlQueryParams,
    SecretRequestWrapper2RequestBody,
    PutSecretViaYamlPathParams
  >
    verb="PUT"
    path={`/v2/secrets/${identifier}/yaml`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UsePutSecretViaYamlProps = Omit<
  UseMutateProps<
    ResponseDTOBoolean,
    FailureDTO | ErrorDTO,
    PutSecretViaYamlQueryParams,
    SecretRequestWrapper2RequestBody,
    PutSecretViaYamlPathParams
  >,
  'path' | 'verb'
> &
  PutSecretViaYamlPathParams

/**
 * Update a secret via yaml
 */
export const usePutSecretViaYaml = ({ identifier, ...props }: UsePutSecretViaYamlProps) =>
  useMutate<
    ResponseDTOBoolean,
    FailureDTO | ErrorDTO,
    PutSecretViaYamlQueryParams,
    SecretRequestWrapper2RequestBody,
    PutSecretViaYamlPathParams
  >('PUT', (paramsInPath: PutSecretViaYamlPathParams) => `/v2/secrets/${paramsInPath.identifier}/yaml`, {
    base: getConfig('ng/api'),
    pathParams: { identifier },
    ...props
  })

/**
 * Update a secret via yaml
 */
export const putSecretViaYamlPromise = (
  {
    identifier,
    ...props
  }: MutateUsingFetchProps<
    ResponseDTOBoolean,
    FailureDTO | ErrorDTO,
    PutSecretViaYamlQueryParams,
    SecretRequestWrapper2RequestBody,
    PutSecretViaYamlPathParams
  > & { identifier: string },
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseDTOBoolean,
    FailureDTO | ErrorDTO,
    PutSecretViaYamlQueryParams,
    SecretRequestWrapper2RequestBody,
    PutSecretViaYamlPathParams
  >('PUT', getConfig('ng/api'), `/v2/secrets/${identifier}/yaml`, props, signal)

export interface PutSecretFileV2QueryParams {
  accountIdentifier: string
}

export interface PutSecretFileV2PathParams {
  identifier: string
}

export type PutSecretFileV2Props = Omit<
  MutateProps<
    ResponseDTOBoolean,
    FailureDTO | ErrorDTO,
    PutSecretFileV2QueryParams,
    PutSecretFileV2RequestBody,
    PutSecretFileV2PathParams
  >,
  'path' | 'verb'
> &
  PutSecretFileV2PathParams

/**
 * Update a secret file
 */
export const PutSecretFileV2 = ({ identifier, ...props }: PutSecretFileV2Props) => (
  <Mutate<
    ResponseDTOBoolean,
    FailureDTO | ErrorDTO,
    PutSecretFileV2QueryParams,
    PutSecretFileV2RequestBody,
    PutSecretFileV2PathParams
  >
    verb="PUT"
    path={`/v2/secrets/files/${identifier}`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UsePutSecretFileV2Props = Omit<
  UseMutateProps<
    ResponseDTOBoolean,
    FailureDTO | ErrorDTO,
    PutSecretFileV2QueryParams,
    PutSecretFileV2RequestBody,
    PutSecretFileV2PathParams
  >,
  'path' | 'verb'
> &
  PutSecretFileV2PathParams

/**
 * Update a secret file
 */
export const usePutSecretFileV2 = ({ identifier, ...props }: UsePutSecretFileV2Props) =>
  useMutate<
    ResponseDTOBoolean,
    FailureDTO | ErrorDTO,
    PutSecretFileV2QueryParams,
    PutSecretFileV2RequestBody,
    PutSecretFileV2PathParams
  >('PUT', (paramsInPath: PutSecretFileV2PathParams) => `/v2/secrets/files/${paramsInPath.identifier}`, {
    base: getConfig('ng/api'),
    pathParams: { identifier },
    ...props
  })

/**
 * Update a secret file
 */
export const putSecretFileV2Promise = (
  {
    identifier,
    ...props
  }: MutateUsingFetchProps<
    ResponseDTOBoolean,
    FailureDTO | ErrorDTO,
    PutSecretFileV2QueryParams,
    PutSecretFileV2RequestBody,
    PutSecretFileV2PathParams
  > & { identifier: string },
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseDTOBoolean,
    FailureDTO | ErrorDTO,
    PutSecretFileV2QueryParams,
    PutSecretFileV2RequestBody,
    PutSecretFileV2PathParams
  >('PUT', getConfig('ng/api'), `/v2/secrets/files/${identifier}`, props, signal)

export interface PostSecretFileV2QueryParams {
  accountIdentifier: string
}

export type PostSecretFileV2Props = Omit<
  MutateProps<
    ResponseDTOSecretResponseWrapper,
    FailureDTO | ErrorDTO,
    PostSecretFileV2QueryParams,
    PutSecretFileV2RequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Create a secret file
 */
export const PostSecretFileV2 = (props: PostSecretFileV2Props) => (
  <Mutate<
    ResponseDTOSecretResponseWrapper,
    FailureDTO | ErrorDTO,
    PostSecretFileV2QueryParams,
    PutSecretFileV2RequestBody,
    void
  >
    verb="POST"
    path={`/v2/secrets/files`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UsePostSecretFileV2Props = Omit<
  UseMutateProps<
    ResponseDTOSecretResponseWrapper,
    FailureDTO | ErrorDTO,
    PostSecretFileV2QueryParams,
    PutSecretFileV2RequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Create a secret file
 */
export const usePostSecretFileV2 = (props: UsePostSecretFileV2Props) =>
  useMutate<
    ResponseDTOSecretResponseWrapper,
    FailureDTO | ErrorDTO,
    PostSecretFileV2QueryParams,
    PutSecretFileV2RequestBody,
    void
  >('POST', `/v2/secrets/files`, { base: getConfig('ng/api'), ...props })

/**
 * Create a secret file
 */
export const postSecretFileV2Promise = (
  props: MutateUsingFetchProps<
    ResponseDTOSecretResponseWrapper,
    FailureDTO | ErrorDTO,
    PostSecretFileV2QueryParams,
    PutSecretFileV2RequestBody,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseDTOSecretResponseWrapper,
    FailureDTO | ErrorDTO,
    PostSecretFileV2QueryParams,
    PutSecretFileV2RequestBody,
    void
  >('POST', getConfig('ng/api'), `/v2/secrets/files`, props, signal)

export interface ListSecretsV2QueryParams {
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
  type?: 'SecretFile' | 'SecretText' | 'SSHKey'
  searchTerm?: string
  page?: number
  size?: number
}

export type ListSecretsV2Props = Omit<
  GetProps<ResponseDTONGPageResponseSecretResponseWrapper, FailureDTO | ErrorDTO, ListSecretsV2QueryParams, void>,
  'path'
>

/**
 * Get secrets
 */
export const ListSecretsV2 = (props: ListSecretsV2Props) => (
  <Get<ResponseDTONGPageResponseSecretResponseWrapper, FailureDTO | ErrorDTO, ListSecretsV2QueryParams, void>
    path={`/v2/secrets`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseListSecretsV2Props = Omit<
  UseGetProps<ResponseDTONGPageResponseSecretResponseWrapper, FailureDTO | ErrorDTO, ListSecretsV2QueryParams, void>,
  'path'
>

/**
 * Get secrets
 */
export const useListSecretsV2 = (props: UseListSecretsV2Props) =>
  useGet<ResponseDTONGPageResponseSecretResponseWrapper, FailureDTO | ErrorDTO, ListSecretsV2QueryParams, void>(
    `/v2/secrets`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Get secrets
 */
export const listSecretsV2Promise = (
  props: GetUsingFetchProps<
    ResponseDTONGPageResponseSecretResponseWrapper,
    FailureDTO | ErrorDTO,
    ListSecretsV2QueryParams,
    void
  >,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseDTONGPageResponseSecretResponseWrapper, FailureDTO | ErrorDTO, ListSecretsV2QueryParams, void>(
    getConfig('ng/api'),
    `/v2/secrets`,
    props,
    signal
  )

export interface PostSecretQueryParams {
  accountIdentifier: string
}

export type PostSecretProps = Omit<
  MutateProps<
    ResponseDTOSecretResponseWrapper,
    FailureDTO | ErrorDTO,
    PostSecretQueryParams,
    SecretRequestWrapperRequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Create a secret
 */
export const PostSecret = (props: PostSecretProps) => (
  <Mutate<
    ResponseDTOSecretResponseWrapper,
    FailureDTO | ErrorDTO,
    PostSecretQueryParams,
    SecretRequestWrapperRequestBody,
    void
  >
    verb="POST"
    path={`/v2/secrets`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UsePostSecretProps = Omit<
  UseMutateProps<
    ResponseDTOSecretResponseWrapper,
    FailureDTO | ErrorDTO,
    PostSecretQueryParams,
    SecretRequestWrapperRequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Create a secret
 */
export const usePostSecret = (props: UsePostSecretProps) =>
  useMutate<
    ResponseDTOSecretResponseWrapper,
    FailureDTO | ErrorDTO,
    PostSecretQueryParams,
    SecretRequestWrapperRequestBody,
    void
  >('POST', `/v2/secrets`, { base: getConfig('ng/api'), ...props })

/**
 * Create a secret
 */
export const postSecretPromise = (
  props: MutateUsingFetchProps<
    ResponseDTOSecretResponseWrapper,
    FailureDTO | ErrorDTO,
    PostSecretQueryParams,
    SecretRequestWrapperRequestBody,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseDTOSecretResponseWrapper,
    FailureDTO | ErrorDTO,
    PostSecretQueryParams,
    SecretRequestWrapperRequestBody,
    void
  >('POST', getConfig('ng/api'), `/v2/secrets`, props, signal)

export interface PostSecretViaYamlQueryParams {
  accountIdentifier: string
}

export type PostSecretViaYamlProps = Omit<
  MutateProps<
    ResponseDTOSecretResponseWrapper,
    FailureDTO | ErrorDTO,
    PostSecretViaYamlQueryParams,
    SecretRequestWrapper2RequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Create a secret via yaml
 */
export const PostSecretViaYaml = (props: PostSecretViaYamlProps) => (
  <Mutate<
    ResponseDTOSecretResponseWrapper,
    FailureDTO | ErrorDTO,
    PostSecretViaYamlQueryParams,
    SecretRequestWrapper2RequestBody,
    void
  >
    verb="POST"
    path={`/v2/secrets/yaml`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UsePostSecretViaYamlProps = Omit<
  UseMutateProps<
    ResponseDTOSecretResponseWrapper,
    FailureDTO | ErrorDTO,
    PostSecretViaYamlQueryParams,
    SecretRequestWrapper2RequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Create a secret via yaml
 */
export const usePostSecretViaYaml = (props: UsePostSecretViaYamlProps) =>
  useMutate<
    ResponseDTOSecretResponseWrapper,
    FailureDTO | ErrorDTO,
    PostSecretViaYamlQueryParams,
    SecretRequestWrapper2RequestBody,
    void
  >('POST', `/v2/secrets/yaml`, { base: getConfig('ng/api'), ...props })

/**
 * Create a secret via yaml
 */
export const postSecretViaYamlPromise = (
  props: MutateUsingFetchProps<
    ResponseDTOSecretResponseWrapper,
    FailureDTO | ErrorDTO,
    PostSecretViaYamlQueryParams,
    SecretRequestWrapper2RequestBody,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseDTOSecretResponseWrapper,
    FailureDTO | ErrorDTO,
    PostSecretViaYamlQueryParams,
    SecretRequestWrapper2RequestBody,
    void
  >('POST', getConfig('ng/api'), `/v2/secrets/yaml`, props, signal)

export interface ValidateSecretQueryParams {
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
  identifier?: string
}

export type ValidateSecretProps = Omit<
  MutateProps<
    ResponseDTOSecretValidationResultDTO,
    FailureDTO | ErrorDTO,
    ValidateSecretQueryParams,
    SecretValidationMetaData,
    void
  >,
  'path' | 'verb'
>

/**
 * Validate a secret
 */
export const ValidateSecret = (props: ValidateSecretProps) => (
  <Mutate<
    ResponseDTOSecretValidationResultDTO,
    FailureDTO | ErrorDTO,
    ValidateSecretQueryParams,
    SecretValidationMetaData,
    void
  >
    verb="POST"
    path={`/v2/secrets/validate`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseValidateSecretProps = Omit<
  UseMutateProps<
    ResponseDTOSecretValidationResultDTO,
    FailureDTO | ErrorDTO,
    ValidateSecretQueryParams,
    SecretValidationMetaData,
    void
  >,
  'path' | 'verb'
>

/**
 * Validate a secret
 */
export const useValidateSecret = (props: UseValidateSecretProps) =>
  useMutate<
    ResponseDTOSecretValidationResultDTO,
    FailureDTO | ErrorDTO,
    ValidateSecretQueryParams,
    SecretValidationMetaData,
    void
  >('POST', `/v2/secrets/validate`, { base: getConfig('ng/api'), ...props })

/**
 * Validate a secret
 */
export const validateSecretPromise = (
  props: MutateUsingFetchProps<
    ResponseDTOSecretValidationResultDTO,
    FailureDTO | ErrorDTO,
    ValidateSecretQueryParams,
    SecretValidationMetaData,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseDTOSecretValidationResultDTO,
    FailureDTO | ErrorDTO,
    ValidateSecretQueryParams,
    SecretValidationMetaData,
    void
  >('POST', getConfig('ng/api'), `/v2/secrets/validate`, props, signal)

export interface GetOrganizationQueryParams {
  accountIdentifier: string
}

export interface GetOrganizationPathParams {
  identifier: string
}

export type GetOrganizationProps = Omit<
  GetProps<ResponseDTOOrganization, FailureDTO | ErrorDTO, GetOrganizationQueryParams, GetOrganizationPathParams>,
  'path'
> &
  GetOrganizationPathParams

/**
 * Get an Organization by identifier
 */
export const GetOrganization = ({ identifier, ...props }: GetOrganizationProps) => (
  <Get<ResponseDTOOrganization, FailureDTO | ErrorDTO, GetOrganizationQueryParams, GetOrganizationPathParams>
    path={`/organizations/${identifier}`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetOrganizationProps = Omit<
  UseGetProps<ResponseDTOOrganization, FailureDTO | ErrorDTO, GetOrganizationQueryParams, GetOrganizationPathParams>,
  'path'
> &
  GetOrganizationPathParams

/**
 * Get an Organization by identifier
 */
export const useGetOrganization = ({ identifier, ...props }: UseGetOrganizationProps) =>
  useGet<ResponseDTOOrganization, FailureDTO | ErrorDTO, GetOrganizationQueryParams, GetOrganizationPathParams>(
    (paramsInPath: GetOrganizationPathParams) => `/organizations/${paramsInPath.identifier}`,
    { base: getConfig('ng/api'), pathParams: { identifier }, ...props }
  )

/**
 * Get an Organization by identifier
 */
export const getOrganizationPromise = (
  {
    identifier,
    ...props
  }: GetUsingFetchProps<
    ResponseDTOOrganization,
    FailureDTO | ErrorDTO,
    GetOrganizationQueryParams,
    GetOrganizationPathParams
  > & { identifier: string },
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseDTOOrganization, FailureDTO | ErrorDTO, GetOrganizationQueryParams, GetOrganizationPathParams>(
    getConfig('ng/api'),
    `/organizations/${identifier}`,
    props,
    signal
  )

export interface PutOrganizationQueryParams {
  accountIdentifier: string
}

export interface PutOrganizationPathParams {
  identifier: string
}

export type PutOrganizationProps = Omit<
  MutateProps<
    ResponseDTOOrganization,
    FailureDTO | ErrorDTO,
    PutOrganizationQueryParams,
    OrganizationRequestBody,
    PutOrganizationPathParams
  >,
  'path' | 'verb'
> &
  PutOrganizationPathParams

/**
 * Update an Organization by identifier
 */
export const PutOrganization = ({ identifier, ...props }: PutOrganizationProps) => (
  <Mutate<
    ResponseDTOOrganization,
    FailureDTO | ErrorDTO,
    PutOrganizationQueryParams,
    OrganizationRequestBody,
    PutOrganizationPathParams
  >
    verb="PUT"
    path={`/organizations/${identifier}`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UsePutOrganizationProps = Omit<
  UseMutateProps<
    ResponseDTOOrganization,
    FailureDTO | ErrorDTO,
    PutOrganizationQueryParams,
    OrganizationRequestBody,
    PutOrganizationPathParams
  >,
  'path' | 'verb'
> &
  PutOrganizationPathParams

/**
 * Update an Organization by identifier
 */
export const usePutOrganization = ({ identifier, ...props }: UsePutOrganizationProps) =>
  useMutate<
    ResponseDTOOrganization,
    FailureDTO | ErrorDTO,
    PutOrganizationQueryParams,
    OrganizationRequestBody,
    PutOrganizationPathParams
  >('PUT', (paramsInPath: PutOrganizationPathParams) => `/organizations/${paramsInPath.identifier}`, {
    base: getConfig('ng/api'),
    pathParams: { identifier },
    ...props
  })

/**
 * Update an Organization by identifier
 */
export const putOrganizationPromise = (
  {
    identifier,
    ...props
  }: MutateUsingFetchProps<
    ResponseDTOOrganization,
    FailureDTO | ErrorDTO,
    PutOrganizationQueryParams,
    OrganizationRequestBody,
    PutOrganizationPathParams
  > & { identifier: string },
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseDTOOrganization,
    FailureDTO | ErrorDTO,
    PutOrganizationQueryParams,
    OrganizationRequestBody,
    PutOrganizationPathParams
  >('PUT', getConfig('ng/api'), `/organizations/${identifier}`, props, signal)

export interface DeleteOrganizationQueryParams {
  accountIdentifier: string
}

export type DeleteOrganizationProps = Omit<
  MutateProps<ResponseDTOBoolean, FailureDTO | ErrorDTO, DeleteOrganizationQueryParams, string, void>,
  'path' | 'verb'
>

/**
 * Delete an Organization by identifier
 */
export const DeleteOrganization = (props: DeleteOrganizationProps) => (
  <Mutate<ResponseDTOBoolean, FailureDTO | ErrorDTO, DeleteOrganizationQueryParams, string, void>
    verb="DELETE"
    path={`/organizations`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseDeleteOrganizationProps = Omit<
  UseMutateProps<ResponseDTOBoolean, FailureDTO | ErrorDTO, DeleteOrganizationQueryParams, string, void>,
  'path' | 'verb'
>

/**
 * Delete an Organization by identifier
 */
export const useDeleteOrganization = (props: UseDeleteOrganizationProps) =>
  useMutate<ResponseDTOBoolean, FailureDTO | ErrorDTO, DeleteOrganizationQueryParams, string, void>(
    'DELETE',
    `/organizations`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Delete an Organization by identifier
 */
export const deleteOrganizationPromise = (
  props: MutateUsingFetchProps<ResponseDTOBoolean, FailureDTO | ErrorDTO, DeleteOrganizationQueryParams, string, void>,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<ResponseDTOBoolean, FailureDTO | ErrorDTO, DeleteOrganizationQueryParams, string, void>(
    'DELETE',
    getConfig('ng/api'),
    `/organizations`,
    props,
    signal
  )

export interface GetOrganizationListQueryParams {
  accountIdentifier: string
  searchTerm?: string
  page?: number
  size?: number
  sort?: string[]
}

export type GetOrganizationListProps = Omit<
  GetProps<ResponseDTONGPageResponseOrganization, FailureDTO | ErrorDTO, GetOrganizationListQueryParams, void>,
  'path'
>

/**
 * Get Organization list
 */
export const GetOrganizationList = (props: GetOrganizationListProps) => (
  <Get<ResponseDTONGPageResponseOrganization, FailureDTO | ErrorDTO, GetOrganizationListQueryParams, void>
    path={`/organizations`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetOrganizationListProps = Omit<
  UseGetProps<ResponseDTONGPageResponseOrganization, FailureDTO | ErrorDTO, GetOrganizationListQueryParams, void>,
  'path'
>

/**
 * Get Organization list
 */
export const useGetOrganizationList = (props: UseGetOrganizationListProps) =>
  useGet<ResponseDTONGPageResponseOrganization, FailureDTO | ErrorDTO, GetOrganizationListQueryParams, void>(
    `/organizations`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Get Organization list
 */
export const getOrganizationListPromise = (
  props: GetUsingFetchProps<
    ResponseDTONGPageResponseOrganization,
    FailureDTO | ErrorDTO,
    GetOrganizationListQueryParams,
    void
  >,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseDTONGPageResponseOrganization, FailureDTO | ErrorDTO, GetOrganizationListQueryParams, void>(
    getConfig('ng/api'),
    `/organizations`,
    props,
    signal
  )

export interface PostOrganizationQueryParams {
  accountIdentifier: string
}

export type PostOrganizationProps = Omit<
  MutateProps<
    ResponseDTOOrganization,
    FailureDTO | ErrorDTO,
    PostOrganizationQueryParams,
    OrganizationRequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Create an Organization
 */
export const PostOrganization = (props: PostOrganizationProps) => (
  <Mutate<ResponseDTOOrganization, FailureDTO | ErrorDTO, PostOrganizationQueryParams, OrganizationRequestBody, void>
    verb="POST"
    path={`/organizations`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UsePostOrganizationProps = Omit<
  UseMutateProps<
    ResponseDTOOrganization,
    FailureDTO | ErrorDTO,
    PostOrganizationQueryParams,
    OrganizationRequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Create an Organization
 */
export const usePostOrganization = (props: UsePostOrganizationProps) =>
  useMutate<ResponseDTOOrganization, FailureDTO | ErrorDTO, PostOrganizationQueryParams, OrganizationRequestBody, void>(
    'POST',
    `/organizations`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Create an Organization
 */
export const postOrganizationPromise = (
  props: MutateUsingFetchProps<
    ResponseDTOOrganization,
    FailureDTO | ErrorDTO,
    PostOrganizationQueryParams,
    OrganizationRequestBody,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseDTOOrganization,
    FailureDTO | ErrorDTO,
    PostOrganizationQueryParams,
    OrganizationRequestBody,
    void
  >('POST', getConfig('ng/api'), `/organizations`, props, signal)

export interface GetProjectQueryParams {
  accountIdentifier: string
  orgIdentifier: string
}

export interface GetProjectPathParams {
  identifier: string
}

export type GetProjectProps = Omit<
  GetProps<ResponseDTOProject, FailureDTO | ErrorDTO, GetProjectQueryParams, GetProjectPathParams>,
  'path'
> &
  GetProjectPathParams

/**
 * Gets a Project by identifier
 */
export const GetProject = ({ identifier, ...props }: GetProjectProps) => (
  <Get<ResponseDTOProject, FailureDTO | ErrorDTO, GetProjectQueryParams, GetProjectPathParams>
    path={`/projects/${identifier}`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetProjectProps = Omit<
  UseGetProps<ResponseDTOProject, FailureDTO | ErrorDTO, GetProjectQueryParams, GetProjectPathParams>,
  'path'
> &
  GetProjectPathParams

/**
 * Gets a Project by identifier
 */
export const useGetProject = ({ identifier, ...props }: UseGetProjectProps) =>
  useGet<ResponseDTOProject, FailureDTO | ErrorDTO, GetProjectQueryParams, GetProjectPathParams>(
    (paramsInPath: GetProjectPathParams) => `/projects/${paramsInPath.identifier}`,
    { base: getConfig('ng/api'), pathParams: { identifier }, ...props }
  )

/**
 * Gets a Project by identifier
 */
export const getProjectPromise = (
  {
    identifier,
    ...props
  }: GetUsingFetchProps<ResponseDTOProject, FailureDTO | ErrorDTO, GetProjectQueryParams, GetProjectPathParams> & {
    identifier: string
  },
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseDTOProject, FailureDTO | ErrorDTO, GetProjectQueryParams, GetProjectPathParams>(
    getConfig('ng/api'),
    `/projects/${identifier}`,
    props,
    signal
  )

export interface PutProjectQueryParams {
  accountIdentifier: string
  orgIdentifier: string
}

export interface PutProjectPathParams {
  identifier: string
}

export type PutProjectProps = Omit<
  MutateProps<
    ResponseDTOProject,
    FailureDTO | ErrorDTO,
    PutProjectQueryParams,
    ProjectRequestBody,
    PutProjectPathParams
  >,
  'path' | 'verb'
> &
  PutProjectPathParams

/**
 * Update a project by identifier
 */
export const PutProject = ({ identifier, ...props }: PutProjectProps) => (
  <Mutate<ResponseDTOProject, FailureDTO | ErrorDTO, PutProjectQueryParams, ProjectRequestBody, PutProjectPathParams>
    verb="PUT"
    path={`/projects/${identifier}`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UsePutProjectProps = Omit<
  UseMutateProps<
    ResponseDTOProject,
    FailureDTO | ErrorDTO,
    PutProjectQueryParams,
    ProjectRequestBody,
    PutProjectPathParams
  >,
  'path' | 'verb'
> &
  PutProjectPathParams

/**
 * Update a project by identifier
 */
export const usePutProject = ({ identifier, ...props }: UsePutProjectProps) =>
  useMutate<ResponseDTOProject, FailureDTO | ErrorDTO, PutProjectQueryParams, ProjectRequestBody, PutProjectPathParams>(
    'PUT',
    (paramsInPath: PutProjectPathParams) => `/projects/${paramsInPath.identifier}`,
    { base: getConfig('ng/api'), pathParams: { identifier }, ...props }
  )

/**
 * Update a project by identifier
 */
export const putProjectPromise = (
  {
    identifier,
    ...props
  }: MutateUsingFetchProps<
    ResponseDTOProject,
    FailureDTO | ErrorDTO,
    PutProjectQueryParams,
    ProjectRequestBody,
    PutProjectPathParams
  > & { identifier: string },
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseDTOProject,
    FailureDTO | ErrorDTO,
    PutProjectQueryParams,
    ProjectRequestBody,
    PutProjectPathParams
  >('PUT', getConfig('ng/api'), `/projects/${identifier}`, props, signal)

export interface DeleteProjectQueryParams {
  accountIdentifier: string
  orgIdentifier: string
}

export type DeleteProjectProps = Omit<
  MutateProps<ResponseDTOBoolean, FailureDTO | ErrorDTO, DeleteProjectQueryParams, string, void>,
  'path' | 'verb'
>

/**
 * Delete a project by identifier
 */
export const DeleteProject = (props: DeleteProjectProps) => (
  <Mutate<ResponseDTOBoolean, FailureDTO | ErrorDTO, DeleteProjectQueryParams, string, void>
    verb="DELETE"
    path={`/projects`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseDeleteProjectProps = Omit<
  UseMutateProps<ResponseDTOBoolean, FailureDTO | ErrorDTO, DeleteProjectQueryParams, string, void>,
  'path' | 'verb'
>

/**
 * Delete a project by identifier
 */
export const useDeleteProject = (props: UseDeleteProjectProps) =>
  useMutate<ResponseDTOBoolean, FailureDTO | ErrorDTO, DeleteProjectQueryParams, string, void>('DELETE', `/projects`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * Delete a project by identifier
 */
export const deleteProjectPromise = (
  props: MutateUsingFetchProps<ResponseDTOBoolean, FailureDTO | ErrorDTO, DeleteProjectQueryParams, string, void>,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<ResponseDTOBoolean, FailureDTO | ErrorDTO, DeleteProjectQueryParams, string, void>(
    'DELETE',
    getConfig('ng/api'),
    `/projects`,
    props,
    signal
  )

export interface GetProjectListQueryParams {
  accountIdentifier: string
  orgIdentifier?: string
  hasModule?: boolean
  moduleType?: 'CD' | 'CI' | 'CORE' | 'CV' | 'CF' | 'CE'
  searchTerm?: string
  page?: number
  size?: number
  sort?: string[]
}

export type GetProjectListProps = Omit<
  GetProps<ResponseDTONGPageResponseProject, FailureDTO | ErrorDTO, GetProjectListQueryParams, void>,
  'path'
>

/**
 * Get Project list
 */
export const GetProjectList = (props: GetProjectListProps) => (
  <Get<ResponseDTONGPageResponseProject, FailureDTO | ErrorDTO, GetProjectListQueryParams, void>
    path={`/projects`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetProjectListProps = Omit<
  UseGetProps<ResponseDTONGPageResponseProject, FailureDTO | ErrorDTO, GetProjectListQueryParams, void>,
  'path'
>

/**
 * Get Project list
 */
export const useGetProjectList = (props: UseGetProjectListProps) =>
  useGet<ResponseDTONGPageResponseProject, FailureDTO | ErrorDTO, GetProjectListQueryParams, void>(`/projects`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * Get Project list
 */
export const getProjectListPromise = (
  props: GetUsingFetchProps<ResponseDTONGPageResponseProject, FailureDTO | ErrorDTO, GetProjectListQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseDTONGPageResponseProject, FailureDTO | ErrorDTO, GetProjectListQueryParams, void>(
    getConfig('ng/api'),
    `/projects`,
    props,
    signal
  )

export interface PostProjectQueryParams {
  accountIdentifier: string
  orgIdentifier: string
}

export type PostProjectProps = Omit<
  MutateProps<ResponseDTOProject, FailureDTO | ErrorDTO, PostProjectQueryParams, ProjectRequestBody, void>,
  'path' | 'verb'
>

/**
 * Create a Project
 */
export const PostProject = (props: PostProjectProps) => (
  <Mutate<ResponseDTOProject, FailureDTO | ErrorDTO, PostProjectQueryParams, ProjectRequestBody, void>
    verb="POST"
    path={`/projects`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UsePostProjectProps = Omit<
  UseMutateProps<ResponseDTOProject, FailureDTO | ErrorDTO, PostProjectQueryParams, ProjectRequestBody, void>,
  'path' | 'verb'
>

/**
 * Create a Project
 */
export const usePostProject = (props: UsePostProjectProps) =>
  useMutate<ResponseDTOProject, FailureDTO | ErrorDTO, PostProjectQueryParams, ProjectRequestBody, void>(
    'POST',
    `/projects`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Create a Project
 */
export const postProjectPromise = (
  props: MutateUsingFetchProps<
    ResponseDTOProject,
    FailureDTO | ErrorDTO,
    PostProjectQueryParams,
    ProjectRequestBody,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<ResponseDTOProject, FailureDTO | ErrorDTO, PostProjectQueryParams, ProjectRequestBody, void>(
    'POST',
    getConfig('ng/api'),
    `/projects`,
    props,
    signal
  )

export interface GetServiceQueryParams {
  accountId?: string
  orgIdentifier?: string
  projectIdentifier?: string
  deleted?: boolean
}

export interface GetServicePathParams {
  serviceIdentifier: string
}

export type GetServiceProps = Omit<
  GetProps<ResponseDTOServiceResponseDTO, FailureDTO | ErrorDTO, GetServiceQueryParams, GetServicePathParams>,
  'path'
> &
  GetServicePathParams

/**
 * Gets a Service by identifier
 */
export const GetService = ({ serviceIdentifier, ...props }: GetServiceProps) => (
  <Get<ResponseDTOServiceResponseDTO, FailureDTO | ErrorDTO, GetServiceQueryParams, GetServicePathParams>
    path={`/services/${serviceIdentifier}`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetServiceProps = Omit<
  UseGetProps<ResponseDTOServiceResponseDTO, FailureDTO | ErrorDTO, GetServiceQueryParams, GetServicePathParams>,
  'path'
> &
  GetServicePathParams

/**
 * Gets a Service by identifier
 */
export const useGetService = ({ serviceIdentifier, ...props }: UseGetServiceProps) =>
  useGet<ResponseDTOServiceResponseDTO, FailureDTO | ErrorDTO, GetServiceQueryParams, GetServicePathParams>(
    (paramsInPath: GetServicePathParams) => `/services/${paramsInPath.serviceIdentifier}`,
    { base: getConfig('ng/api'), pathParams: { serviceIdentifier }, ...props }
  )

/**
 * Gets a Service by identifier
 */
export const getServicePromise = (
  {
    serviceIdentifier,
    ...props
  }: GetUsingFetchProps<
    ResponseDTOServiceResponseDTO,
    FailureDTO | ErrorDTO,
    GetServiceQueryParams,
    GetServicePathParams
  > & { serviceIdentifier: string },
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseDTOServiceResponseDTO, FailureDTO | ErrorDTO, GetServiceQueryParams, GetServicePathParams>(
    getConfig('ng/api'),
    `/services/${serviceIdentifier}`,
    props,
    signal
  )

export interface DeleteServiceQueryParams {
  accountId?: string
  orgIdentifier?: string
  projectIdentifier?: string
}

export type DeleteServiceProps = Omit<
  MutateProps<ResponseDTOBoolean, FailureDTO | ErrorDTO, DeleteServiceQueryParams, string, void>,
  'path' | 'verb'
>

/**
 * Delete a service by identifier
 */
export const DeleteService = (props: DeleteServiceProps) => (
  <Mutate<ResponseDTOBoolean, FailureDTO | ErrorDTO, DeleteServiceQueryParams, string, void>
    verb="DELETE"
    path={`/services`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseDeleteServiceProps = Omit<
  UseMutateProps<ResponseDTOBoolean, FailureDTO | ErrorDTO, DeleteServiceQueryParams, string, void>,
  'path' | 'verb'
>

/**
 * Delete a service by identifier
 */
export const useDeleteService = (props: UseDeleteServiceProps) =>
  useMutate<ResponseDTOBoolean, FailureDTO | ErrorDTO, DeleteServiceQueryParams, string, void>('DELETE', `/services`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * Delete a service by identifier
 */
export const deleteServicePromise = (
  props: MutateUsingFetchProps<ResponseDTOBoolean, FailureDTO | ErrorDTO, DeleteServiceQueryParams, string, void>,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<ResponseDTOBoolean, FailureDTO | ErrorDTO, DeleteServiceQueryParams, string, void>(
    'DELETE',
    getConfig('ng/api'),
    `/services`,
    props,
    signal
  )

export interface GetServiceListForProjectQueryParams {
  page?: number
  size?: number
  accountId?: string
  orgIdentifier?: string
  projectIdentifier?: string
  sort?: string[]
}

export type GetServiceListForProjectProps = Omit<
  GetProps<
    ResponseDTONGPageResponseServiceResponseDTO,
    FailureDTO | ErrorDTO,
    GetServiceListForProjectQueryParams,
    void
  >,
  'path'
>

/**
 * Gets Service list for a project
 */
export const GetServiceListForProject = (props: GetServiceListForProjectProps) => (
  <Get<ResponseDTONGPageResponseServiceResponseDTO, FailureDTO | ErrorDTO, GetServiceListForProjectQueryParams, void>
    path={`/services`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetServiceListForProjectProps = Omit<
  UseGetProps<
    ResponseDTONGPageResponseServiceResponseDTO,
    FailureDTO | ErrorDTO,
    GetServiceListForProjectQueryParams,
    void
  >,
  'path'
>

/**
 * Gets Service list for a project
 */
export const useGetServiceListForProject = (props: UseGetServiceListForProjectProps) =>
  useGet<ResponseDTONGPageResponseServiceResponseDTO, FailureDTO | ErrorDTO, GetServiceListForProjectQueryParams, void>(
    `/services`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Gets Service list for a project
 */
export const getServiceListForProjectPromise = (
  props: GetUsingFetchProps<
    ResponseDTONGPageResponseServiceResponseDTO,
    FailureDTO | ErrorDTO,
    GetServiceListForProjectQueryParams,
    void
  >,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<
    ResponseDTONGPageResponseServiceResponseDTO,
    FailureDTO | ErrorDTO,
    GetServiceListForProjectQueryParams,
    void
  >(getConfig('ng/api'), `/services`, props, signal)

export interface CreateServiceQueryParams {
  accountId?: string
}

export type CreateServiceProps = Omit<
  MutateProps<
    ResponseDTOServiceResponseDTO,
    FailureDTO | ErrorDTO,
    CreateServiceQueryParams,
    ServiceRequestDTORequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Create a Service
 */
export const CreateService = (props: CreateServiceProps) => (
  <Mutate<
    ResponseDTOServiceResponseDTO,
    FailureDTO | ErrorDTO,
    CreateServiceQueryParams,
    ServiceRequestDTORequestBody,
    void
  >
    verb="POST"
    path={`/services`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseCreateServiceProps = Omit<
  UseMutateProps<
    ResponseDTOServiceResponseDTO,
    FailureDTO | ErrorDTO,
    CreateServiceQueryParams,
    ServiceRequestDTORequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Create a Service
 */
export const useCreateService = (props: UseCreateServiceProps) =>
  useMutate<
    ResponseDTOServiceResponseDTO,
    FailureDTO | ErrorDTO,
    CreateServiceQueryParams,
    ServiceRequestDTORequestBody,
    void
  >('POST', `/services`, { base: getConfig('ng/api'), ...props })

/**
 * Create a Service
 */
export const createServicePromise = (
  props: MutateUsingFetchProps<
    ResponseDTOServiceResponseDTO,
    FailureDTO | ErrorDTO,
    CreateServiceQueryParams,
    ServiceRequestDTORequestBody,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseDTOServiceResponseDTO,
    FailureDTO | ErrorDTO,
    CreateServiceQueryParams,
    ServiceRequestDTORequestBody,
    void
  >('POST', getConfig('ng/api'), `/services`, props, signal)

export interface UpdateServiceQueryParams {
  accountId?: string
}

export type UpdateServiceProps = Omit<
  MutateProps<
    ResponseDTOServiceResponseDTO,
    FailureDTO | ErrorDTO,
    UpdateServiceQueryParams,
    ServiceRequestDTORequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Update a service by identifier
 */
export const UpdateService = (props: UpdateServiceProps) => (
  <Mutate<
    ResponseDTOServiceResponseDTO,
    FailureDTO | ErrorDTO,
    UpdateServiceQueryParams,
    ServiceRequestDTORequestBody,
    void
  >
    verb="PUT"
    path={`/services`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseUpdateServiceProps = Omit<
  UseMutateProps<
    ResponseDTOServiceResponseDTO,
    FailureDTO | ErrorDTO,
    UpdateServiceQueryParams,
    ServiceRequestDTORequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Update a service by identifier
 */
export const useUpdateService = (props: UseUpdateServiceProps) =>
  useMutate<
    ResponseDTOServiceResponseDTO,
    FailureDTO | ErrorDTO,
    UpdateServiceQueryParams,
    ServiceRequestDTORequestBody,
    void
  >('PUT', `/services`, { base: getConfig('ng/api'), ...props })

/**
 * Update a service by identifier
 */
export const updateServicePromise = (
  props: MutateUsingFetchProps<
    ResponseDTOServiceResponseDTO,
    FailureDTO | ErrorDTO,
    UpdateServiceQueryParams,
    ServiceRequestDTORequestBody,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseDTOServiceResponseDTO,
    FailureDTO | ErrorDTO,
    UpdateServiceQueryParams,
    ServiceRequestDTORequestBody,
    void
  >('PUT', getConfig('ng/api'), `/services`, props, signal)

export interface UpsertServiceQueryParams {
  accountId?: string
}

export type UpsertServiceProps = Omit<
  MutateProps<
    ResponseDTOServiceResponseDTO,
    FailureDTO | ErrorDTO,
    UpsertServiceQueryParams,
    ServiceRequestDTORequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Upsert a service by identifier
 */
export const UpsertService = (props: UpsertServiceProps) => (
  <Mutate<
    ResponseDTOServiceResponseDTO,
    FailureDTO | ErrorDTO,
    UpsertServiceQueryParams,
    ServiceRequestDTORequestBody,
    void
  >
    verb="PUT"
    path={`/services/upsert`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseUpsertServiceProps = Omit<
  UseMutateProps<
    ResponseDTOServiceResponseDTO,
    FailureDTO | ErrorDTO,
    UpsertServiceQueryParams,
    ServiceRequestDTORequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Upsert a service by identifier
 */
export const useUpsertService = (props: UseUpsertServiceProps) =>
  useMutate<
    ResponseDTOServiceResponseDTO,
    FailureDTO | ErrorDTO,
    UpsertServiceQueryParams,
    ServiceRequestDTORequestBody,
    void
  >('PUT', `/services/upsert`, { base: getConfig('ng/api'), ...props })

/**
 * Upsert a service by identifier
 */
export const upsertServicePromise = (
  props: MutateUsingFetchProps<
    ResponseDTOServiceResponseDTO,
    FailureDTO | ErrorDTO,
    UpsertServiceQueryParams,
    ServiceRequestDTORequestBody,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseDTOServiceResponseDTO,
    FailureDTO | ErrorDTO,
    UpsertServiceQueryParams,
    ServiceRequestDTORequestBody,
    void
  >('PUT', getConfig('ng/api'), `/services/upsert`, props, signal)

export interface GetUsersQueryParams {
  accountIdentifier: string
  searchString?: string
  page?: number
  size?: number
  sort?: string[]
}

export type GetUsersProps = Omit<
  GetProps<ResponseDTONGPageResponseUserSearchDTO, FailureDTO | ErrorDTO, GetUsersQueryParams, void>,
  'path'
>

/**
 * Get users for an account
 */
export const GetUsers = (props: GetUsersProps) => (
  <Get<ResponseDTONGPageResponseUserSearchDTO, FailureDTO | ErrorDTO, GetUsersQueryParams, void>
    path={`/users`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetUsersProps = Omit<
  UseGetProps<ResponseDTONGPageResponseUserSearchDTO, FailureDTO | ErrorDTO, GetUsersQueryParams, void>,
  'path'
>

/**
 * Get users for an account
 */
export const useGetUsers = (props: UseGetUsersProps) =>
  useGet<ResponseDTONGPageResponseUserSearchDTO, FailureDTO | ErrorDTO, GetUsersQueryParams, void>(`/users`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * Get users for an account
 */
export const getUsersPromise = (
  props: GetUsingFetchProps<ResponseDTONGPageResponseUserSearchDTO, FailureDTO | ErrorDTO, GetUsersQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseDTONGPageResponseUserSearchDTO, FailureDTO | ErrorDTO, GetUsersQueryParams, void>(
    getConfig('ng/api'),
    `/users`,
    props,
    signal
  )

export interface GetListOfExecutionsQueryParams {
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier: string
  filter?: string
  page?: number
  size?: number
  sort?: string[]
}

export type GetListOfExecutionsProps = Omit<
  GetProps<ResponseDTOListPipelineExecutionDTO, FailureDTO | ErrorDTO, GetListOfExecutionsQueryParams, void>,
  'path'
>

/**
 * Gets Executions list
 */
export const GetListOfExecutions = (props: GetListOfExecutionsProps) => (
  <Get<ResponseDTOListPipelineExecutionDTO, FailureDTO | ErrorDTO, GetListOfExecutionsQueryParams, void>
    path={`/executions`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetListOfExecutionsProps = Omit<
  UseGetProps<ResponseDTOListPipelineExecutionDTO, FailureDTO | ErrorDTO, GetListOfExecutionsQueryParams, void>,
  'path'
>

/**
 * Gets Executions list
 */
export const useGetListOfExecutions = (props: UseGetListOfExecutionsProps) =>
  useGet<ResponseDTOListPipelineExecutionDTO, FailureDTO | ErrorDTO, GetListOfExecutionsQueryParams, void>(
    `/executions`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Gets Executions list
 */
export const getListOfExecutionsPromise = (
  props: GetUsingFetchProps<
    ResponseDTOListPipelineExecutionDTO,
    FailureDTO | ErrorDTO,
    GetListOfExecutionsQueryParams,
    void
  >,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseDTOListPipelineExecutionDTO, FailureDTO | ErrorDTO, GetListOfExecutionsQueryParams, void>(
    getConfig('ng/api'),
    `/executions`,
    props,
    signal
  )

export interface GetPipelineExecutionDetailQueryParams {
  accountIdentifier: string
  orgIdentifier: string
  projectIdentifier: string
  stageIdentifier: string
}

export interface GetPipelineExecutionDetailPathParams {
  planExecutionId: string
}

export type GetPipelineExecutionDetailProps = Omit<
  GetProps<
    ResponseDTOPipelineExecutionDetail,
    FailureDTO | ErrorDTO,
    GetPipelineExecutionDetailQueryParams,
    GetPipelineExecutionDetailPathParams
  >,
  'path'
> &
  GetPipelineExecutionDetailPathParams

/**
 * Gets Executions list
 */
export const GetPipelineExecutionDetail = ({ planExecutionId, ...props }: GetPipelineExecutionDetailProps) => (
  <Get<
    ResponseDTOPipelineExecutionDetail,
    FailureDTO | ErrorDTO,
    GetPipelineExecutionDetailQueryParams,
    GetPipelineExecutionDetailPathParams
  >
    path={`/executions/${planExecutionId}`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetPipelineExecutionDetailProps = Omit<
  UseGetProps<
    ResponseDTOPipelineExecutionDetail,
    FailureDTO | ErrorDTO,
    GetPipelineExecutionDetailQueryParams,
    GetPipelineExecutionDetailPathParams
  >,
  'path'
> &
  GetPipelineExecutionDetailPathParams

/**
 * Gets Executions list
 */
export const useGetPipelineExecutionDetail = ({ planExecutionId, ...props }: UseGetPipelineExecutionDetailProps) =>
  useGet<
    ResponseDTOPipelineExecutionDetail,
    FailureDTO | ErrorDTO,
    GetPipelineExecutionDetailQueryParams,
    GetPipelineExecutionDetailPathParams
  >((paramsInPath: GetPipelineExecutionDetailPathParams) => `/executions/${paramsInPath.planExecutionId}`, {
    base: getConfig('ng/api'),
    pathParams: { planExecutionId },
    ...props
  })

/**
 * Gets Executions list
 */
export const getPipelineExecutionDetailPromise = (
  {
    planExecutionId,
    ...props
  }: GetUsingFetchProps<
    ResponseDTOPipelineExecutionDetail,
    FailureDTO | ErrorDTO,
    GetPipelineExecutionDetailQueryParams,
    GetPipelineExecutionDetailPathParams
  > & { planExecutionId: string },
  signal?: RequestInit['signal']
) =>
  getUsingFetch<
    ResponseDTOPipelineExecutionDetail,
    FailureDTO | ErrorDTO,
    GetPipelineExecutionDetailQueryParams,
    GetPipelineExecutionDetailPathParams
  >(getConfig('ng/api'), `/executions/${planExecutionId}`, props, signal)

export interface GetGraphQueryParams {
  planExecutionId?: string
}

export type GetGraphProps = Omit<GetProps<RestResponseGraph, unknown, GetGraphQueryParams, void>, 'path'>

/**
 * generate graph for plan execution
 */
export const GetGraph = (props: GetGraphProps) => (
  <Get<RestResponseGraph, unknown, GetGraphQueryParams, void>
    path={`/orchestration/get-graph`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetGraphProps = Omit<UseGetProps<RestResponseGraph, unknown, GetGraphQueryParams, void>, 'path'>

/**
 * generate graph for plan execution
 */
export const useGetGraph = (props: UseGetGraphProps) =>
  useGet<RestResponseGraph, unknown, GetGraphQueryParams, void>(`/orchestration/get-graph`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * generate graph for plan execution
 */
export const getGraphPromise = (
  props: GetUsingFetchProps<RestResponseGraph, unknown, GetGraphQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<RestResponseGraph, unknown, GetGraphQueryParams, void>(
    getConfig('ng/api'),
    `/orchestration/get-graph`,
    props,
    signal
  )

export interface GetGraphVisualizationQueryParams {
  planExecutionId?: string
}

export type GetGraphVisualizationProps = Omit<GetProps<void, unknown, GetGraphVisualizationQueryParams, void>, 'path'>

/**
 * generate graph execution visualization
 */
export const GetGraphVisualization = (props: GetGraphVisualizationProps) => (
  <Get<void, unknown, GetGraphVisualizationQueryParams, void>
    path={`/orchestration/get-graph-visualization`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetGraphVisualizationProps = Omit<
  UseGetProps<void, unknown, GetGraphVisualizationQueryParams, void>,
  'path'
>

/**
 * generate graph execution visualization
 */
export const useGetGraphVisualization = (props: UseGetGraphVisualizationProps) =>
  useGet<void, unknown, GetGraphVisualizationQueryParams, void>(`/orchestration/get-graph-visualization`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * generate graph execution visualization
 */
export const getGraphVisualizationPromise = (
  props: GetUsingFetchProps<void, unknown, GetGraphVisualizationQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<void, unknown, GetGraphVisualizationQueryParams, void>(
    getConfig('ng/api'),
    `/orchestration/get-graph-visualization`,
    props,
    signal
  )

export interface HttpV2QueryParams {
  accountId: string
  appId: string
}

export type HttpV2Props = Omit<GetProps<RestResponsePlanExecution, unknown, HttpV2QueryParams, void>, 'path'>

/**
 * Triggers a task v2 Plan
 */
export const HttpV2 = (props: HttpV2Props) => (
  <Get<RestResponsePlanExecution, unknown, HttpV2QueryParams, void>
    path={`/orchestration/http-v2`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseHttpV2Props = Omit<UseGetProps<RestResponsePlanExecution, unknown, HttpV2QueryParams, void>, 'path'>

/**
 * Triggers a task v2 Plan
 */
export const useHttpV2 = (props: UseHttpV2Props) =>
  useGet<RestResponsePlanExecution, unknown, HttpV2QueryParams, void>(`/orchestration/http-v2`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * Triggers a task v2 Plan
 */
export const httpV2Promise = (
  props: GetUsingFetchProps<RestResponsePlanExecution, unknown, HttpV2QueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<RestResponsePlanExecution, unknown, HttpV2QueryParams, void>(
    getConfig('ng/api'),
    `/orchestration/http-v2`,
    props,
    signal
  )

export interface HttpV3QueryParams {
  accountId: string
  appId: string
}

export type HttpV3Props = Omit<GetProps<RestResponsePlanExecution, unknown, HttpV3QueryParams, void>, 'path'>

/**
 * Triggers a task v3 Plan
 */
export const HttpV3 = (props: HttpV3Props) => (
  <Get<RestResponsePlanExecution, unknown, HttpV3QueryParams, void>
    path={`/orchestration/http-v3`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseHttpV3Props = Omit<UseGetProps<RestResponsePlanExecution, unknown, HttpV3QueryParams, void>, 'path'>

/**
 * Triggers a task v3 Plan
 */
export const useHttpV3 = (props: UseHttpV3Props) =>
  useGet<RestResponsePlanExecution, unknown, HttpV3QueryParams, void>(`/orchestration/http-v3`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * Triggers a task v3 Plan
 */
export const httpV3Promise = (
  props: GetUsingFetchProps<RestResponsePlanExecution, unknown, HttpV3QueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<RestResponsePlanExecution, unknown, HttpV3QueryParams, void>(
    getConfig('ng/api'),
    `/orchestration/http-v3`,
    props,
    signal
  )

export interface HttpChainV2QueryParams {
  accountId: string
  appId: string
}

export type HttpChainV2Props = Omit<GetProps<RestResponsePlanExecution, unknown, HttpChainV2QueryParams, void>, 'path'>

/**
 * Triggers a task chain v2 Plan
 */
export const HttpChainV2 = (props: HttpChainV2Props) => (
  <Get<RestResponsePlanExecution, unknown, HttpChainV2QueryParams, void>
    path={`/orchestration/http-chain-v2`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseHttpChainV2Props = Omit<
  UseGetProps<RestResponsePlanExecution, unknown, HttpChainV2QueryParams, void>,
  'path'
>

/**
 * Triggers a task chain v2 Plan
 */
export const useHttpChainV2 = (props: UseHttpChainV2Props) =>
  useGet<RestResponsePlanExecution, unknown, HttpChainV2QueryParams, void>(`/orchestration/http-chain-v2`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * Triggers a task chain v2 Plan
 */
export const httpChainV2Promise = (
  props: GetUsingFetchProps<RestResponsePlanExecution, unknown, HttpChainV2QueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<RestResponsePlanExecution, unknown, HttpChainV2QueryParams, void>(
    getConfig('ng/api'),
    `/orchestration/http-chain-v2`,
    props,
    signal
  )

export interface HttpChainV3QueryParams {
  accountId: string
  appId: string
}

export type HttpChainV3Props = Omit<GetProps<RestResponsePlanExecution, unknown, HttpChainV3QueryParams, void>, 'path'>

/**
 * Triggers a task chain v3 Plan
 */
export const HttpChainV3 = (props: HttpChainV3Props) => (
  <Get<RestResponsePlanExecution, unknown, HttpChainV3QueryParams, void>
    path={`/orchestration/http-chain-v3`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseHttpChainV3Props = Omit<
  UseGetProps<RestResponsePlanExecution, unknown, HttpChainV3QueryParams, void>,
  'path'
>

/**
 * Triggers a task chain v3 Plan
 */
export const useHttpChainV3 = (props: UseHttpChainV3Props) =>
  useGet<RestResponsePlanExecution, unknown, HttpChainV3QueryParams, void>(`/orchestration/http-chain-v3`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * Triggers a task chain v3 Plan
 */
export const httpChainV3Promise = (
  props: GetUsingFetchProps<RestResponsePlanExecution, unknown, HttpChainV3QueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<RestResponsePlanExecution, unknown, HttpChainV3QueryParams, void>(
    getConfig('ng/api'),
    `/orchestration/http-chain-v3`,
    props,
    signal
  )

export interface TestExecutionPlanQueryParams {
  accountId?: string
}

export type TestExecutionPlanProps = Omit<
  MutateProps<RestResponsePlanExecution, unknown, TestExecutionPlanQueryParams, void, void>,
  'path' | 'verb'
>

/**
 * create and run an execution plan
 */
export const TestExecutionPlan = (props: TestExecutionPlanProps) => (
  <Mutate<RestResponsePlanExecution, unknown, TestExecutionPlanQueryParams, void, void>
    verb="POST"
    path={`/orchestration/test-execution-plan`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseTestExecutionPlanProps = Omit<
  UseMutateProps<RestResponsePlanExecution, unknown, TestExecutionPlanQueryParams, void, void>,
  'path' | 'verb'
>

/**
 * create and run an execution plan
 */
export const useTestExecutionPlan = (props: UseTestExecutionPlanProps) =>
  useMutate<RestResponsePlanExecution, unknown, TestExecutionPlanQueryParams, void, void>(
    'POST',
    `/orchestration/test-execution-plan`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * create and run an execution plan
 */
export const testExecutionPlanPromise = (
  props: MutateUsingFetchProps<RestResponsePlanExecution, unknown, TestExecutionPlanQueryParams, void, void>,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<RestResponsePlanExecution, unknown, TestExecutionPlanQueryParams, void, void>(
    'POST',
    getConfig('ng/api'),
    `/orchestration/test-execution-plan`,
    props,
    signal
  )

export interface GetStepsQueryParams {
  serviceDefinitionType: 'Ssh' | 'Kubernetes' | 'Ecs' | 'Helm' | 'Pcf'
}

export type GetStepsProps = Omit<
  GetProps<ResponseDTOStepCategory, FailureDTO | ErrorDTO, GetStepsQueryParams, void>,
  'path'
>

/**
 * get steps for given service definition type
 */
export const GetSteps = (props: GetStepsProps) => (
  <Get<ResponseDTOStepCategory, FailureDTO | ErrorDTO, GetStepsQueryParams, void>
    path={`/pipelines/steps`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetStepsProps = Omit<
  UseGetProps<ResponseDTOStepCategory, FailureDTO | ErrorDTO, GetStepsQueryParams, void>,
  'path'
>

/**
 * get steps for given service definition type
 */
export const useGetSteps = (props: UseGetStepsProps) =>
  useGet<ResponseDTOStepCategory, FailureDTO | ErrorDTO, GetStepsQueryParams, void>(`/pipelines/steps`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * get steps for given service definition type
 */
export const getStepsPromise = (
  props: GetUsingFetchProps<ResponseDTOStepCategory, FailureDTO | ErrorDTO, GetStepsQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseDTOStepCategory, FailureDTO | ErrorDTO, GetStepsQueryParams, void>(
    getConfig('ng/api'),
    `/pipelines/steps`,
    props,
    signal
  )

export interface GetPipelineListQueryParams {
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier: string
  filter?: string
  page?: number
  size?: number
  sort?: string[]
}

export type GetPipelineListProps = Omit<
  GetProps<ResponseDTOPageCDPipelineSummaryResponseDTO, FailureDTO | ErrorDTO, GetPipelineListQueryParams, void>,
  'path'
>

/**
 * Gets Pipeline list
 */
export const GetPipelineList = (props: GetPipelineListProps) => (
  <Get<ResponseDTOPageCDPipelineSummaryResponseDTO, FailureDTO | ErrorDTO, GetPipelineListQueryParams, void>
    path={`/pipelines`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetPipelineListProps = Omit<
  UseGetProps<ResponseDTOPageCDPipelineSummaryResponseDTO, FailureDTO | ErrorDTO, GetPipelineListQueryParams, void>,
  'path'
>

/**
 * Gets Pipeline list
 */
export const useGetPipelineList = (props: UseGetPipelineListProps) =>
  useGet<ResponseDTOPageCDPipelineSummaryResponseDTO, FailureDTO | ErrorDTO, GetPipelineListQueryParams, void>(
    `/pipelines`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Gets Pipeline list
 */
export const getPipelineListPromise = (
  props: GetUsingFetchProps<
    ResponseDTOPageCDPipelineSummaryResponseDTO,
    FailureDTO | ErrorDTO,
    GetPipelineListQueryParams,
    void
  >,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseDTOPageCDPipelineSummaryResponseDTO, FailureDTO | ErrorDTO, GetPipelineListQueryParams, void>(
    getConfig('ng/api'),
    `/pipelines`,
    props,
    signal
  )

export interface PostPipelineQueryParams {
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier: string
}

export type PostPipelineProps = Omit<
  MutateProps<ResponseDTOString, FailureDTO | ErrorDTO, PostPipelineQueryParams, PostPipelineBodyRequestBody, void>,
  'path' | 'verb'
>

/**
 * Create a Pipeline
 */
export const PostPipeline = (props: PostPipelineProps) => (
  <Mutate<ResponseDTOString, FailureDTO | ErrorDTO, PostPipelineQueryParams, PostPipelineBodyRequestBody, void>
    verb="POST"
    path={`/pipelines`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UsePostPipelineProps = Omit<
  UseMutateProps<ResponseDTOString, FailureDTO | ErrorDTO, PostPipelineQueryParams, PostPipelineBodyRequestBody, void>,
  'path' | 'verb'
>

/**
 * Create a Pipeline
 */
export const usePostPipeline = (props: UsePostPipelineProps) =>
  useMutate<ResponseDTOString, FailureDTO | ErrorDTO, PostPipelineQueryParams, PostPipelineBodyRequestBody, void>(
    'POST',
    `/pipelines`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Create a Pipeline
 */
export const postPipelinePromise = (
  props: MutateUsingFetchProps<
    ResponseDTOString,
    FailureDTO | ErrorDTO,
    PostPipelineQueryParams,
    PostPipelineBodyRequestBody,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseDTOString,
    FailureDTO | ErrorDTO,
    PostPipelineQueryParams,
    PostPipelineBodyRequestBody,
    void
  >('POST', getConfig('ng/api'), `/pipelines`, props, signal)

export type GetExecutionStrategyListProps = Omit<
  GetProps<ResponseDTOMapServiceDefinitionTypeListExecutionStrategyType, FailureDTO | ErrorDTO, void, void>,
  'path'
>

/**
 * Gets Execution Strategy list
 */
export const GetExecutionStrategyList = (props: GetExecutionStrategyListProps) => (
  <Get<ResponseDTOMapServiceDefinitionTypeListExecutionStrategyType, FailureDTO | ErrorDTO, void, void>
    path={`/pipelines/strategies`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetExecutionStrategyListProps = Omit<
  UseGetProps<ResponseDTOMapServiceDefinitionTypeListExecutionStrategyType, FailureDTO | ErrorDTO, void, void>,
  'path'
>

/**
 * Gets Execution Strategy list
 */
export const useGetExecutionStrategyList = (props: UseGetExecutionStrategyListProps) =>
  useGet<ResponseDTOMapServiceDefinitionTypeListExecutionStrategyType, FailureDTO | ErrorDTO, void, void>(
    `/pipelines/strategies`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Gets Execution Strategy list
 */
export const getExecutionStrategyListPromise = (
  props: GetUsingFetchProps<
    ResponseDTOMapServiceDefinitionTypeListExecutionStrategyType,
    FailureDTO | ErrorDTO,
    void,
    void
  >,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseDTOMapServiceDefinitionTypeListExecutionStrategyType, FailureDTO | ErrorDTO, void, void>(
    getConfig('ng/api'),
    `/pipelines/strategies`,
    props,
    signal
  )

export interface GetExecutionStrategyYamlQueryParams {
  serviceDefinitionType: 'Ssh' | 'Kubernetes' | 'Ecs' | 'Helm' | 'Pcf'
  strategyType: 'Basic' | 'Canary' | 'BlueGreen' | 'Rolling'
}

export type GetExecutionStrategyYamlProps = Omit<
  GetProps<ResponseDTOString, FailureDTO | ErrorDTO, GetExecutionStrategyYamlQueryParams, void>,
  'path'
>

/**
 * Gets Yaml for Execution Strategy based on deployment type and selected strategy
 */
export const GetExecutionStrategyYaml = (props: GetExecutionStrategyYamlProps) => (
  <Get<ResponseDTOString, FailureDTO | ErrorDTO, GetExecutionStrategyYamlQueryParams, void>
    path={`/pipelines/strategies/yaml-snippets`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetExecutionStrategyYamlProps = Omit<
  UseGetProps<ResponseDTOString, FailureDTO | ErrorDTO, GetExecutionStrategyYamlQueryParams, void>,
  'path'
>

/**
 * Gets Yaml for Execution Strategy based on deployment type and selected strategy
 */
export const useGetExecutionStrategyYaml = (props: UseGetExecutionStrategyYamlProps) =>
  useGet<ResponseDTOString, FailureDTO | ErrorDTO, GetExecutionStrategyYamlQueryParams, void>(
    `/pipelines/strategies/yaml-snippets`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Gets Yaml for Execution Strategy based on deployment type and selected strategy
 */
export const getExecutionStrategyYamlPromise = (
  props: GetUsingFetchProps<ResponseDTOString, FailureDTO | ErrorDTO, GetExecutionStrategyYamlQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseDTOString, FailureDTO | ErrorDTO, GetExecutionStrategyYamlQueryParams, void>(
    getConfig('ng/api'),
    `/pipelines/strategies/yaml-snippets`,
    props,
    signal
  )

export interface GetPipelineQueryParams {
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
}

export interface GetPipelinePathParams {
  pipelineIdentifier: string
}

export type GetPipelineProps = Omit<
  GetProps<ResponseDTOCDPipelineResponseDTO, FailureDTO | ErrorDTO, GetPipelineQueryParams, GetPipelinePathParams>,
  'path'
> &
  GetPipelinePathParams

/**
 * Gets a pipeline by identifier
 */
export const GetPipeline = ({ pipelineIdentifier, ...props }: GetPipelineProps) => (
  <Get<ResponseDTOCDPipelineResponseDTO, FailureDTO | ErrorDTO, GetPipelineQueryParams, GetPipelinePathParams>
    path={`/pipelines/${pipelineIdentifier}`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetPipelineProps = Omit<
  UseGetProps<ResponseDTOCDPipelineResponseDTO, FailureDTO | ErrorDTO, GetPipelineQueryParams, GetPipelinePathParams>,
  'path'
> &
  GetPipelinePathParams

/**
 * Gets a pipeline by identifier
 */
export const useGetPipeline = ({ pipelineIdentifier, ...props }: UseGetPipelineProps) =>
  useGet<ResponseDTOCDPipelineResponseDTO, FailureDTO | ErrorDTO, GetPipelineQueryParams, GetPipelinePathParams>(
    (paramsInPath: GetPipelinePathParams) => `/pipelines/${paramsInPath.pipelineIdentifier}`,
    { base: getConfig('ng/api'), pathParams: { pipelineIdentifier }, ...props }
  )

/**
 * Gets a pipeline by identifier
 */
export const getPipelinePromise = (
  {
    pipelineIdentifier,
    ...props
  }: GetUsingFetchProps<
    ResponseDTOCDPipelineResponseDTO,
    FailureDTO | ErrorDTO,
    GetPipelineQueryParams,
    GetPipelinePathParams
  > & { pipelineIdentifier: string },
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseDTOCDPipelineResponseDTO, FailureDTO | ErrorDTO, GetPipelineQueryParams, GetPipelinePathParams>(
    getConfig('ng/api'),
    `/pipelines/${pipelineIdentifier}`,
    props,
    signal
  )

export interface PutPipelineQueryParams {
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier: string
}

export interface PutPipelinePathParams {
  pipelineIdentifier: string
}

export type PutPipelineProps = Omit<
  MutateProps<
    ResponseDTOString,
    FailureDTO | ErrorDTO,
    PutPipelineQueryParams,
    PostPipelineBodyRequestBody,
    PutPipelinePathParams
  >,
  'path' | 'verb'
> &
  PutPipelinePathParams

/**
 * Update a Pipeline
 */
export const PutPipeline = ({ pipelineIdentifier, ...props }: PutPipelineProps) => (
  <Mutate<
    ResponseDTOString,
    FailureDTO | ErrorDTO,
    PutPipelineQueryParams,
    PostPipelineBodyRequestBody,
    PutPipelinePathParams
  >
    verb="PUT"
    path={`/pipelines/${pipelineIdentifier}`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UsePutPipelineProps = Omit<
  UseMutateProps<
    ResponseDTOString,
    FailureDTO | ErrorDTO,
    PutPipelineQueryParams,
    PostPipelineBodyRequestBody,
    PutPipelinePathParams
  >,
  'path' | 'verb'
> &
  PutPipelinePathParams

/**
 * Update a Pipeline
 */
export const usePutPipeline = ({ pipelineIdentifier, ...props }: UsePutPipelineProps) =>
  useMutate<
    ResponseDTOString,
    FailureDTO | ErrorDTO,
    PutPipelineQueryParams,
    PostPipelineBodyRequestBody,
    PutPipelinePathParams
  >('PUT', (paramsInPath: PutPipelinePathParams) => `/pipelines/${paramsInPath.pipelineIdentifier}`, {
    base: getConfig('ng/api'),
    pathParams: { pipelineIdentifier },
    ...props
  })

/**
 * Update a Pipeline
 */
export const putPipelinePromise = (
  {
    pipelineIdentifier,
    ...props
  }: MutateUsingFetchProps<
    ResponseDTOString,
    FailureDTO | ErrorDTO,
    PutPipelineQueryParams,
    PostPipelineBodyRequestBody,
    PutPipelinePathParams
  > & { pipelineIdentifier: string },
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseDTOString,
    FailureDTO | ErrorDTO,
    PutPipelineQueryParams,
    PostPipelineBodyRequestBody,
    PutPipelinePathParams
  >('PUT', getConfig('ng/api'), `/pipelines/${pipelineIdentifier}`, props, signal)

export interface SoftDeletePipelineQueryParams {
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier: string
}

export type SoftDeletePipelineProps = Omit<
  MutateProps<ResponseDTOBoolean, FailureDTO | ErrorDTO, SoftDeletePipelineQueryParams, string, void>,
  'path' | 'verb'
>

/**
 * Delete a pipeline
 */
export const SoftDeletePipeline = (props: SoftDeletePipelineProps) => (
  <Mutate<ResponseDTOBoolean, FailureDTO | ErrorDTO, SoftDeletePipelineQueryParams, string, void>
    verb="DELETE"
    path={`/pipelines`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseSoftDeletePipelineProps = Omit<
  UseMutateProps<ResponseDTOBoolean, FailureDTO | ErrorDTO, SoftDeletePipelineQueryParams, string, void>,
  'path' | 'verb'
>

/**
 * Delete a pipeline
 */
export const useSoftDeletePipeline = (props: UseSoftDeletePipelineProps) =>
  useMutate<ResponseDTOBoolean, FailureDTO | ErrorDTO, SoftDeletePipelineQueryParams, string, void>(
    'DELETE',
    `/pipelines`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Delete a pipeline
 */
export const softDeletePipelinePromise = (
  props: MutateUsingFetchProps<ResponseDTOBoolean, FailureDTO | ErrorDTO, SoftDeletePipelineQueryParams, string, void>,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<ResponseDTOBoolean, FailureDTO | ErrorDTO, SoftDeletePipelineQueryParams, string, void>(
    'DELETE',
    getConfig('ng/api'),
    `/pipelines`,
    props,
    signal
  )

export type GetServiceDefinitionTypesProps = Omit<
  GetProps<ResponseDTOListServiceDefinitionType, FailureDTO | ErrorDTO, void, void>,
  'path'
>

/**
 * Git list of service definition types
 */
export const GetServiceDefinitionTypes = (props: GetServiceDefinitionTypesProps) => (
  <Get<ResponseDTOListServiceDefinitionType, FailureDTO | ErrorDTO, void, void>
    path={`/pipelines/serviceDefinitionTypes`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetServiceDefinitionTypesProps = Omit<
  UseGetProps<ResponseDTOListServiceDefinitionType, FailureDTO | ErrorDTO, void, void>,
  'path'
>

/**
 * Git list of service definition types
 */
export const useGetServiceDefinitionTypes = (props: UseGetServiceDefinitionTypesProps) =>
  useGet<ResponseDTOListServiceDefinitionType, FailureDTO | ErrorDTO, void, void>(`/pipelines/serviceDefinitionTypes`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * Git list of service definition types
 */
export const getServiceDefinitionTypesPromise = (
  props: GetUsingFetchProps<ResponseDTOListServiceDefinitionType, FailureDTO | ErrorDTO, void, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseDTOListServiceDefinitionType, FailureDTO | ErrorDTO, void, void>(
    getConfig('ng/api'),
    `/pipelines/serviceDefinitionTypes`,
    props,
    signal
  )

export interface ValidatePipelineQueryParams {
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier: string
  pipelineIdentifier?: string
}

export type ValidatePipelineProps = Omit<
  GetProps<ResponseDTOCDPipelineValidationInfoDTO, FailureDTO | ErrorDTO, ValidatePipelineQueryParams, void>,
  'path'
>

/**
 * Validate a Pipeline
 */
export const ValidatePipeline = (props: ValidatePipelineProps) => (
  <Get<ResponseDTOCDPipelineValidationInfoDTO, FailureDTO | ErrorDTO, ValidatePipelineQueryParams, void>
    path={`/pipelines/validate`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseValidatePipelineProps = Omit<
  UseGetProps<ResponseDTOCDPipelineValidationInfoDTO, FailureDTO | ErrorDTO, ValidatePipelineQueryParams, void>,
  'path'
>

/**
 * Validate a Pipeline
 */
export const useValidatePipeline = (props: UseValidatePipelineProps) =>
  useGet<ResponseDTOCDPipelineValidationInfoDTO, FailureDTO | ErrorDTO, ValidatePipelineQueryParams, void>(
    `/pipelines/validate`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Validate a Pipeline
 */
export const validatePipelinePromise = (
  props: GetUsingFetchProps<
    ResponseDTOCDPipelineValidationInfoDTO,
    FailureDTO | ErrorDTO,
    ValidatePipelineQueryParams,
    void
  >,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseDTOCDPipelineValidationInfoDTO, FailureDTO | ErrorDTO, ValidatePipelineQueryParams, void>(
    getConfig('ng/api'),
    `/pipelines/validate`,
    props,
    signal
  )

export interface PostPipelineExecuteQueryParams {
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
  appId?: string
}

export interface PostPipelineExecutePathParams {
  identifier: string
}

export type PostPipelineExecuteProps = Omit<
  MutateProps<
    ResponseDTOPlanExecution,
    FailureDTO | ErrorDTO,
    PostPipelineExecuteQueryParams,
    void,
    PostPipelineExecutePathParams
  >,
  'path' | 'verb'
> &
  PostPipelineExecutePathParams

/**
 * Execute a pipeline
 */
export const PostPipelineExecute = ({ identifier, ...props }: PostPipelineExecuteProps) => (
  <Mutate<
    ResponseDTOPlanExecution,
    FailureDTO | ErrorDTO,
    PostPipelineExecuteQueryParams,
    void,
    PostPipelineExecutePathParams
  >
    verb="POST"
    path={`/pipelines/${identifier}/execute`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UsePostPipelineExecuteProps = Omit<
  UseMutateProps<
    ResponseDTOPlanExecution,
    FailureDTO | ErrorDTO,
    PostPipelineExecuteQueryParams,
    void,
    PostPipelineExecutePathParams
  >,
  'path' | 'verb'
> &
  PostPipelineExecutePathParams

/**
 * Execute a pipeline
 */
export const usePostPipelineExecute = ({ identifier, ...props }: UsePostPipelineExecuteProps) =>
  useMutate<
    ResponseDTOPlanExecution,
    FailureDTO | ErrorDTO,
    PostPipelineExecuteQueryParams,
    void,
    PostPipelineExecutePathParams
  >('POST', (paramsInPath: PostPipelineExecutePathParams) => `/pipelines/${paramsInPath.identifier}/execute`, {
    base: getConfig('ng/api'),
    pathParams: { identifier },
    ...props
  })

/**
 * Execute a pipeline
 */
export const postPipelineExecutePromise = (
  {
    identifier,
    ...props
  }: MutateUsingFetchProps<
    ResponseDTOPlanExecution,
    FailureDTO | ErrorDTO,
    PostPipelineExecuteQueryParams,
    void,
    PostPipelineExecutePathParams
  > & { identifier: string },
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseDTOPlanExecution,
    FailureDTO | ErrorDTO,
    PostPipelineExecuteQueryParams,
    void,
    PostPipelineExecutePathParams
  >('POST', getConfig('ng/api'), `/pipelines/${identifier}/execute`, props, signal)
