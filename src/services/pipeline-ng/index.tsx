/* Generated by restful-react */

import React from 'react'
import { Get, GetProps, useGet, UseGetProps, Mutate, MutateProps, useMutate, UseMutateProps } from 'restful-react'

import { getConfig, getUsingFetch, mutateUsingFetch, GetUsingFetchProps, MutateUsingFetchProps } from '../config'
export type ConnectorFilterProperties = FilterProperties & {
  connectorNames?: string[]
  connectorIdentifiers?: string[]
  description?: string
  types?: (
    | 'K8sCluster'
    | 'Git'
    | 'Splunk'
    | 'AppDynamics'
    | 'Vault'
    | 'DockerRegistry'
    | 'Local'
    | 'AwsKms'
    | 'GcpKms'
    | 'Gcp'
    | 'Aws'
    | 'Artifactory'
    | 'Jira'
    | 'Nexus'
    | 'Github'
    | 'Gitlab'
    | 'Bitbucket'
    | 'Codecommit'
    | 'CEAws'
    | 'CEAzure'
    | 'GcpCloudCost'
    | 'CEK8sCluster'
    | 'HttpHelmRepo'
    | 'NewRelic'
  )[]
  categories?: (
    | 'CLOUD_PROVIDER'
    | 'SECRET_MANAGER'
    | 'CLOUD_COST'
    | 'ARTIFACTORY'
    | 'CODE_REPO'
    | 'MONITORING'
    | 'TICKETING'
  )[]
  connectivityStatuses?: ('SUCCESS' | 'FAILURE' | 'PARTIAL')[]
  inheritingCredentialsFromDelegate?: boolean
}

export interface FilterDTO {
  name: string
  identifier: string
  orgIdentifier?: string
  projectIdentifier?: string
  filterProperties: FilterProperties
  filterVisibility?: 'EveryOne' | 'OnlyCreator'
}

export interface FilterProperties {
  tags?: {
    [key: string]: string
  }
  filterType?: 'Connector' | 'PipelineSetup' | 'PipelineExecution' | 'Deployment' | 'Audit'
}

export interface NGTag {
  key: string
  value: string
}

export type PipelineExecutionFilterProperties = FilterProperties & {
  status?: (
    | 'Running'
    | 'Failed'
    | 'NotStarted'
    | 'Expired'
    | 'Aborted'
    | 'Queued'
    | 'Paused'
    | 'Waiting'
    | 'Success'
    | 'Suspended'
    | 'Skipped'
    | 'Pausing'
  )[]
  pipelineName?: string
  moduleProperties?: {
    [key: string]: { [key: string]: any }
  }
}

export type PipelineFilterProperties = FilterProperties & {
  pipelineTags?: NGTag[]
  pipelineIdentifiers?: string[]
  name?: string
  description?: string
  moduleProperties?: {
    [key: string]: { [key: string]: any }
  }
}

export interface Response {
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
  data?: { [key: string]: any }
  metaData?: { [key: string]: any }
  correlationId?: string
}

export interface ResponseFilterDTO {
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
  data?: FilterDTO
  metaData?: { [key: string]: any }
  correlationId?: string
}

export interface Failure {
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
  code?:
    | 'DEFAULT_ERROR_CODE'
    | 'INVALID_ARGUMENT'
    | 'INVALID_EMAIL'
    | 'DOMAIN_NOT_ALLOWED_TO_REGISTER'
    | 'USER_ALREADY_REGISTERED'
    | 'USER_INVITATION_DOES_NOT_EXIST'
    | 'USER_DOES_NOT_EXIST'
    | 'USER_INVITE_OPERATION_FAILED'
    | 'USER_DISABLED'
    | 'ACCOUNT_DOES_NOT_EXIST'
    | 'INACTIVE_ACCOUNT'
    | 'ACCOUNT_MIGRATED'
    | 'USER_DOMAIN_NOT_ALLOWED'
    | 'MAX_FAILED_ATTEMPT_COUNT_EXCEEDED'
    | 'RESOURCE_NOT_FOUND'
    | 'ROLE_DOES_NOT_EXIST'
    | 'EMAIL_NOT_VERIFIED'
    | 'EMAIL_VERIFICATION_TOKEN_NOT_FOUND'
    | 'INVALID_TOKEN'
    | 'INVALID_CAPTCHA_TOKEN'
    | 'NOT_ACCOUNT_MGR_NOR_HAS_ALL_APP_ACCESS'
    | 'EXPIRED_TOKEN'
    | 'TOKEN_ALREADY_REFRESHED_ONCE'
    | 'ACCESS_DENIED'
    | 'NG_ACCESS_DENIED'
    | 'INVALID_CREDENTIAL'
    | 'INVALID_KEY'
    | 'INVALID_KEYPATH'
    | 'INVALID_VARIABLE'
    | 'UNKNOWN_HOST'
    | 'UNREACHABLE_HOST'
    | 'INVALID_PORT'
    | 'SSH_SESSION_TIMEOUT'
    | 'SOCKET_CONNECTION_ERROR'
    | 'SOCKET_CONNECTION_TIMEOUT'
    | 'CONNECTION_TIMEOUT'
    | 'SSH_CONNECTION_ERROR'
    | 'USER_GROUP_ERROR'
    | 'INVALID_EXECUTION_ID'
    | 'ERROR_IN_GETTING_CHANNEL_STREAMS'
    | 'UNEXPECTED'
    | 'UNKNOWN_ERROR'
    | 'UNKNOWN_EXECUTOR_TYPE_ERROR'
    | 'DUPLICATE_STATE_NAMES'
    | 'TRANSITION_NOT_LINKED'
    | 'TRANSITION_TO_INCORRECT_STATE'
    | 'TRANSITION_TYPE_NULL'
    | 'STATES_WITH_DUP_TRANSITIONS'
    | 'BARRIERS_NOT_RUNNING_CONCURRENTLY'
    | 'NON_FORK_STATES'
    | 'NON_REPEAT_STATES'
    | 'INITIAL_STATE_NOT_DEFINED'
    | 'FILE_INTEGRITY_CHECK_FAILED'
    | 'INVALID_URL'
    | 'FILE_DOWNLOAD_FAILED'
    | 'PLATFORM_SOFTWARE_DELETE_ERROR'
    | 'INVALID_CSV_FILE'
    | 'INVALID_REQUEST'
    | 'INVALID_INFRA_STATE'
    | 'PIPELINE_ALREADY_TRIGGERED'
    | 'NON_EXISTING_PIPELINE'
    | 'DUPLICATE_COMMAND_NAMES'
    | 'INVALID_PIPELINE'
    | 'COMMAND_DOES_NOT_EXIST'
    | 'DUPLICATE_ARTIFACTSTREAM_NAMES'
    | 'DUPLICATE_HOST_NAMES'
    | 'STATE_NOT_FOR_TYPE'
    | 'STATE_MACHINE_ISSUE'
    | 'STATE_DISCONTINUE_FAILED'
    | 'STATE_PAUSE_FAILED'
    | 'PAUSE_ALL_ALREADY'
    | 'RESUME_ALL_ALREADY'
    | 'ROLLBACK_ALREADY'
    | 'ABORT_ALL_ALREADY'
    | 'RETRY_FAILED'
    | 'UNKNOWN_ARTIFACT_TYPE'
    | 'UNKNOWN_STAGE_ELEMENT_WRAPPER_TYPE'
    | 'INIT_TIMEOUT'
    | 'LICENSE_EXPIRED'
    | 'NOT_LICENSED'
    | 'REQUEST_TIMEOUT'
    | 'WORKFLOW_ALREADY_TRIGGERED'
    | 'JENKINS_ERROR'
    | 'INVALID_ARTIFACT_SOURCE'
    | 'INVALID_ARTIFACT_SERVER'
    | 'INVALID_CLOUD_PROVIDER'
    | 'UPDATE_NOT_ALLOWED'
    | 'DELETE_NOT_ALLOWED'
    | 'APPDYNAMICS_CONFIGURATION_ERROR'
    | 'APM_CONFIGURATION_ERROR'
    | 'SPLUNK_CONFIGURATION_ERROR'
    | 'ELK_CONFIGURATION_ERROR'
    | 'LOGZ_CONFIGURATION_ERROR'
    | 'SUMO_CONFIGURATION_ERROR'
    | 'INSTANA_CONFIGURATION_ERROR'
    | 'APPDYNAMICS_ERROR'
    | 'STACKDRIVER_ERROR'
    | 'STACKDRIVER_CONFIGURATION_ERROR'
    | 'NEWRELIC_CONFIGURATION_ERROR'
    | 'NEWRELIC_ERROR'
    | 'DYNA_TRACE_CONFIGURATION_ERROR'
    | 'DYNA_TRACE_ERROR'
    | 'CLOUDWATCH_ERROR'
    | 'CLOUDWATCH_CONFIGURATION_ERROR'
    | 'PROMETHEUS_CONFIGURATION_ERROR'
    | 'DATA_DOG_CONFIGURATION_ERROR'
    | 'SERVICE_GUARD_CONFIGURATION_ERROR'
    | 'ENCRYPTION_NOT_CONFIGURED'
    | 'UNAVAILABLE_DELEGATES'
    | 'WORKFLOW_EXECUTION_IN_PROGRESS'
    | 'PIPELINE_EXECUTION_IN_PROGRESS'
    | 'AWS_ACCESS_DENIED'
    | 'AWS_CLUSTER_NOT_FOUND'
    | 'AWS_SERVICE_NOT_FOUND'
    | 'INVALID_YAML_PAYLOAD'
    | 'UNRECOGNIZED_YAML_FIELDS'
    | 'COULD_NOT_MAP_BEFORE_YAML'
    | 'MISSING_BEFORE_YAML'
    | 'MISSING_YAML'
    | 'NON_EMPTY_DELETIONS'
    | 'GENERAL_YAML_ERROR'
    | 'GENERAL_YAML_INFO'
    | 'YAML_GIT_SYNC_ERROR'
    | 'GIT_CONNECTION_ERROR'
    | 'GIT_ERROR'
    | 'ARTIFACT_SERVER_ERROR'
    | 'ENCRYPT_DECRYPT_ERROR'
    | 'SECRET_MANAGEMENT_ERROR'
    | 'KMS_OPERATION_ERROR'
    | 'GCP_KMS_OPERATION_ERROR'
    | 'VAULT_OPERATION_ERROR'
    | 'AWS_SECRETS_MANAGER_OPERATION_ERROR'
    | 'AZURE_KEY_VAULT_OPERATION_ERROR'
    | 'CYBERARK_OPERATION_ERROR'
    | 'UNSUPPORTED_OPERATION_EXCEPTION'
    | 'FEATURE_UNAVAILABLE'
    | 'GENERAL_ERROR'
    | 'BASELINE_CONFIGURATION_ERROR'
    | 'SAML_IDP_CONFIGURATION_NOT_AVAILABLE'
    | 'INVALID_AUTHENTICATION_MECHANISM'
    | 'INVALID_SAML_CONFIGURATION'
    | 'INVALID_OAUTH_CONFIGURATION'
    | 'INVALID_LDAP_CONFIGURATION'
    | 'USER_GROUP_SYNC_FAILURE'
    | 'USER_GROUP_ALREADY_EXIST'
    | 'INVALID_TWO_FACTOR_AUTHENTICATION_CONFIGURATION'
    | 'EXPLANATION'
    | 'HINT'
    | 'NOT_WHITELISTED_IP'
    | 'INVALID_TOTP_TOKEN'
    | 'EMAIL_FAILED'
    | 'SSL_HANDSHAKE_FAILED'
    | 'NO_APPS_ASSIGNED'
    | 'INVALID_INFRA_CONFIGURATION'
    | 'TEMPLATES_LINKED'
    | 'USER_HAS_NO_PERMISSIONS'
    | 'USER_NOT_AUTHORIZED'
    | 'USER_ALREADY_PRESENT'
    | 'INVALID_USAGE_RESTRICTION'
    | 'USAGE_RESTRICTION_ERROR'
    | 'STATE_EXECUTION_INSTANCE_NOT_FOUND'
    | 'DELEGATE_TASK_RETRY'
    | 'KUBERNETES_YAML_ERROR'
    | 'SAVE_FILE_INTO_GCP_STORAGE_FAILED'
    | 'READ_FILE_FROM_GCP_STORAGE_FAILED'
    | 'USAGE_LIMITS_EXCEEDED'
    | 'EVENT_PUBLISH_FAILED'
    | 'JIRA_ERROR'
    | 'EXPRESSION_EVALUATION_FAILED'
    | 'KUBERNETES_VALUES_ERROR'
    | 'KUBERNETES_CLUSTER_ERROR'
    | 'INCORRECT_SIGN_IN_MECHANISM'
    | 'OAUTH_LOGIN_FAILED'
    | 'INVALID_TERRAFORM_TARGETS_REQUEST'
    | 'TERRAFORM_EXECUTION_ERROR'
    | 'FILE_READ_FAILED'
    | 'FILE_SIZE_EXCEEDS_LIMIT'
    | 'CLUSTER_NOT_FOUND'
    | 'MARKETPLACE_TOKEN_NOT_FOUND'
    | 'INVALID_MARKETPLACE_TOKEN'
    | 'INVALID_TICKETING_SERVER'
    | 'SERVICENOW_ERROR'
    | 'PASSWORD_EXPIRED'
    | 'USER_LOCKED'
    | 'PASSWORD_STRENGTH_CHECK_FAILED'
    | 'ACCOUNT_DISABLED'
    | 'INVALID_ACCOUNT_PERMISSION'
    | 'PAGERDUTY_ERROR'
    | 'HEALTH_ERROR'
    | 'SAML_TEST_SUCCESS_MECHANISM_NOT_ENABLED'
    | 'DOMAIN_WHITELIST_FILTER_CHECK_FAILED'
    | 'INVALID_DASHBOARD_UPDATE_REQUEST'
    | 'DUPLICATE_FIELD'
    | 'INVALID_AZURE_VAULT_CONFIGURATION'
    | 'USER_NOT_AUTHORIZED_DUE_TO_USAGE_RESTRICTIONS'
    | 'INVALID_ROLLBACK'
    | 'SUMO_DATA_COLLECTION_ERROR'
    | 'DEPLOYMENT_GOVERNANCE_ERROR'
    | 'BATCH_PROCESSING_ERROR'
    | 'GRAPHQL_ERROR'
    | 'FILE_CREATE_ERROR'
    | 'ILLEGAL_STATE'
    | 'GIT_DIFF_COMMIT_NOT_IN_ORDER'
    | 'FAILED_TO_ACQUIRE_PERSISTENT_LOCK'
    | 'FAILED_TO_ACQUIRE_NON_PERSISTENT_LOCK'
    | 'POD_NOT_FOUND_ERROR'
    | 'COMMAND_EXECUTION_ERROR'
    | 'REGISTRY_EXCEPTION'
    | 'ENGINE_INTERRUPT_PROCESSING_EXCEPTION'
    | 'ENGINE_IO_EXCEPTION'
    | 'ENGINE_OUTCOME_EXCEPTION'
    | 'ENGINE_SWEEPING_OUTPUT_EXCEPTION'
    | 'CACHE_NOT_FOUND_EXCEPTION'
    | 'ENGINE_ENTITY_UPDATE_EXCEPTION'
    | 'SHELL_EXECUTION_EXCEPTION'
    | 'TEMPLATE_NOT_FOUND'
    | 'AZURE_SERVICE_EXCEPTION'
    | 'AZURE_CLIENT_EXCEPTION'
    | 'GIT_UNSEEN_REMOTE_HEAD_COMMIT'
    | 'TIMEOUT_ENGINE_EXCEPTION'
    | 'NO_AVAILABLE_DELEGATES'
    | 'NO_INSTALLED_DELEGATES'
    | 'DUPLICATE_DELEGATE_EXCEPTION'
    | 'GCP_MARKETPLACE_EXCEPTION'
    | 'MISSING_DEFAULT_GOOGLE_CREDENTIALS'
    | 'INCORRECT_DEFAULT_GOOGLE_CREDENTIALS'
    | 'OPTIMISTIC_LOCKING_EXCEPTION'
    | 'NG_PIPELINE_EXECUTION_EXCEPTION'
    | 'NG_PIPELINE_CREATE_EXCEPTION'
    | 'RESOURCE_NOT_FOUND_EXCEPTION'
    | 'PMS_INITIALIZE_SDK_EXCEPTION'
    | 'UNEXPECTED_SNIPPET_EXCEPTION'
    | 'UNEXPECTED_SCHEMA_EXCEPTION'
    | 'CONNECTOR_VALIDATION_EXCEPTION'
    | 'GCP_SECRET_MANAGER_OPERATION_ERROR'
    | 'GCP_SECRET_OPERATION_ERROR'
    | 'GIT_OPERATION_ERROR'
    | 'TASK_FAILURE_ERROR'
    | 'INSTANCE_STATS_PROCESS_ERROR'
    | 'INSTANCE_STATS_MIGRATION_ERROR'
    | 'DEPLOYMENT_MIGRATION_ERROR'
    | 'INSTANCE_STATS_AGGREGATION_ERROR'
    | 'UNRESOLVED_EXPRESSIONS_ERROR'
    | 'KRYO_HANDLER_NOT_FOUND_ERROR'
    | 'DELEGATE_ERROR_HANDLER_EXCEPTION'
    | 'UNEXPECTED_TYPE_ERROR'
    | 'EXCEPTION_HANDLER_NOT_FOUND'
    | 'CONNECTOR_NOT_FOUND_EXCEPTION'
    | 'GCP_SERVER_ERROR'
    | 'HTTP_RESPONSE_EXCEPTION'
    | 'DATA'
  message?: string
  correlationId?: string
  errors?: ValidationError[]
}

export interface ValidationError {
  fieldId?: string
  error?: string
}

export interface Error {
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
  code?:
    | 'DEFAULT_ERROR_CODE'
    | 'INVALID_ARGUMENT'
    | 'INVALID_EMAIL'
    | 'DOMAIN_NOT_ALLOWED_TO_REGISTER'
    | 'USER_ALREADY_REGISTERED'
    | 'USER_INVITATION_DOES_NOT_EXIST'
    | 'USER_DOES_NOT_EXIST'
    | 'USER_INVITE_OPERATION_FAILED'
    | 'USER_DISABLED'
    | 'ACCOUNT_DOES_NOT_EXIST'
    | 'INACTIVE_ACCOUNT'
    | 'ACCOUNT_MIGRATED'
    | 'USER_DOMAIN_NOT_ALLOWED'
    | 'MAX_FAILED_ATTEMPT_COUNT_EXCEEDED'
    | 'RESOURCE_NOT_FOUND'
    | 'ROLE_DOES_NOT_EXIST'
    | 'EMAIL_NOT_VERIFIED'
    | 'EMAIL_VERIFICATION_TOKEN_NOT_FOUND'
    | 'INVALID_TOKEN'
    | 'INVALID_CAPTCHA_TOKEN'
    | 'NOT_ACCOUNT_MGR_NOR_HAS_ALL_APP_ACCESS'
    | 'EXPIRED_TOKEN'
    | 'TOKEN_ALREADY_REFRESHED_ONCE'
    | 'ACCESS_DENIED'
    | 'NG_ACCESS_DENIED'
    | 'INVALID_CREDENTIAL'
    | 'INVALID_KEY'
    | 'INVALID_KEYPATH'
    | 'INVALID_VARIABLE'
    | 'UNKNOWN_HOST'
    | 'UNREACHABLE_HOST'
    | 'INVALID_PORT'
    | 'SSH_SESSION_TIMEOUT'
    | 'SOCKET_CONNECTION_ERROR'
    | 'SOCKET_CONNECTION_TIMEOUT'
    | 'CONNECTION_TIMEOUT'
    | 'SSH_CONNECTION_ERROR'
    | 'USER_GROUP_ERROR'
    | 'INVALID_EXECUTION_ID'
    | 'ERROR_IN_GETTING_CHANNEL_STREAMS'
    | 'UNEXPECTED'
    | 'UNKNOWN_ERROR'
    | 'UNKNOWN_EXECUTOR_TYPE_ERROR'
    | 'DUPLICATE_STATE_NAMES'
    | 'TRANSITION_NOT_LINKED'
    | 'TRANSITION_TO_INCORRECT_STATE'
    | 'TRANSITION_TYPE_NULL'
    | 'STATES_WITH_DUP_TRANSITIONS'
    | 'BARRIERS_NOT_RUNNING_CONCURRENTLY'
    | 'NON_FORK_STATES'
    | 'NON_REPEAT_STATES'
    | 'INITIAL_STATE_NOT_DEFINED'
    | 'FILE_INTEGRITY_CHECK_FAILED'
    | 'INVALID_URL'
    | 'FILE_DOWNLOAD_FAILED'
    | 'PLATFORM_SOFTWARE_DELETE_ERROR'
    | 'INVALID_CSV_FILE'
    | 'INVALID_REQUEST'
    | 'INVALID_INFRA_STATE'
    | 'PIPELINE_ALREADY_TRIGGERED'
    | 'NON_EXISTING_PIPELINE'
    | 'DUPLICATE_COMMAND_NAMES'
    | 'INVALID_PIPELINE'
    | 'COMMAND_DOES_NOT_EXIST'
    | 'DUPLICATE_ARTIFACTSTREAM_NAMES'
    | 'DUPLICATE_HOST_NAMES'
    | 'STATE_NOT_FOR_TYPE'
    | 'STATE_MACHINE_ISSUE'
    | 'STATE_DISCONTINUE_FAILED'
    | 'STATE_PAUSE_FAILED'
    | 'PAUSE_ALL_ALREADY'
    | 'RESUME_ALL_ALREADY'
    | 'ROLLBACK_ALREADY'
    | 'ABORT_ALL_ALREADY'
    | 'RETRY_FAILED'
    | 'UNKNOWN_ARTIFACT_TYPE'
    | 'UNKNOWN_STAGE_ELEMENT_WRAPPER_TYPE'
    | 'INIT_TIMEOUT'
    | 'LICENSE_EXPIRED'
    | 'NOT_LICENSED'
    | 'REQUEST_TIMEOUT'
    | 'WORKFLOW_ALREADY_TRIGGERED'
    | 'JENKINS_ERROR'
    | 'INVALID_ARTIFACT_SOURCE'
    | 'INVALID_ARTIFACT_SERVER'
    | 'INVALID_CLOUD_PROVIDER'
    | 'UPDATE_NOT_ALLOWED'
    | 'DELETE_NOT_ALLOWED'
    | 'APPDYNAMICS_CONFIGURATION_ERROR'
    | 'APM_CONFIGURATION_ERROR'
    | 'SPLUNK_CONFIGURATION_ERROR'
    | 'ELK_CONFIGURATION_ERROR'
    | 'LOGZ_CONFIGURATION_ERROR'
    | 'SUMO_CONFIGURATION_ERROR'
    | 'INSTANA_CONFIGURATION_ERROR'
    | 'APPDYNAMICS_ERROR'
    | 'STACKDRIVER_ERROR'
    | 'STACKDRIVER_CONFIGURATION_ERROR'
    | 'NEWRELIC_CONFIGURATION_ERROR'
    | 'NEWRELIC_ERROR'
    | 'DYNA_TRACE_CONFIGURATION_ERROR'
    | 'DYNA_TRACE_ERROR'
    | 'CLOUDWATCH_ERROR'
    | 'CLOUDWATCH_CONFIGURATION_ERROR'
    | 'PROMETHEUS_CONFIGURATION_ERROR'
    | 'DATA_DOG_CONFIGURATION_ERROR'
    | 'SERVICE_GUARD_CONFIGURATION_ERROR'
    | 'ENCRYPTION_NOT_CONFIGURED'
    | 'UNAVAILABLE_DELEGATES'
    | 'WORKFLOW_EXECUTION_IN_PROGRESS'
    | 'PIPELINE_EXECUTION_IN_PROGRESS'
    | 'AWS_ACCESS_DENIED'
    | 'AWS_CLUSTER_NOT_FOUND'
    | 'AWS_SERVICE_NOT_FOUND'
    | 'INVALID_YAML_PAYLOAD'
    | 'UNRECOGNIZED_YAML_FIELDS'
    | 'COULD_NOT_MAP_BEFORE_YAML'
    | 'MISSING_BEFORE_YAML'
    | 'MISSING_YAML'
    | 'NON_EMPTY_DELETIONS'
    | 'GENERAL_YAML_ERROR'
    | 'GENERAL_YAML_INFO'
    | 'YAML_GIT_SYNC_ERROR'
    | 'GIT_CONNECTION_ERROR'
    | 'GIT_ERROR'
    | 'ARTIFACT_SERVER_ERROR'
    | 'ENCRYPT_DECRYPT_ERROR'
    | 'SECRET_MANAGEMENT_ERROR'
    | 'KMS_OPERATION_ERROR'
    | 'GCP_KMS_OPERATION_ERROR'
    | 'VAULT_OPERATION_ERROR'
    | 'AWS_SECRETS_MANAGER_OPERATION_ERROR'
    | 'AZURE_KEY_VAULT_OPERATION_ERROR'
    | 'CYBERARK_OPERATION_ERROR'
    | 'UNSUPPORTED_OPERATION_EXCEPTION'
    | 'FEATURE_UNAVAILABLE'
    | 'GENERAL_ERROR'
    | 'BASELINE_CONFIGURATION_ERROR'
    | 'SAML_IDP_CONFIGURATION_NOT_AVAILABLE'
    | 'INVALID_AUTHENTICATION_MECHANISM'
    | 'INVALID_SAML_CONFIGURATION'
    | 'INVALID_OAUTH_CONFIGURATION'
    | 'INVALID_LDAP_CONFIGURATION'
    | 'USER_GROUP_SYNC_FAILURE'
    | 'USER_GROUP_ALREADY_EXIST'
    | 'INVALID_TWO_FACTOR_AUTHENTICATION_CONFIGURATION'
    | 'EXPLANATION'
    | 'HINT'
    | 'NOT_WHITELISTED_IP'
    | 'INVALID_TOTP_TOKEN'
    | 'EMAIL_FAILED'
    | 'SSL_HANDSHAKE_FAILED'
    | 'NO_APPS_ASSIGNED'
    | 'INVALID_INFRA_CONFIGURATION'
    | 'TEMPLATES_LINKED'
    | 'USER_HAS_NO_PERMISSIONS'
    | 'USER_NOT_AUTHORIZED'
    | 'USER_ALREADY_PRESENT'
    | 'INVALID_USAGE_RESTRICTION'
    | 'USAGE_RESTRICTION_ERROR'
    | 'STATE_EXECUTION_INSTANCE_NOT_FOUND'
    | 'DELEGATE_TASK_RETRY'
    | 'KUBERNETES_YAML_ERROR'
    | 'SAVE_FILE_INTO_GCP_STORAGE_FAILED'
    | 'READ_FILE_FROM_GCP_STORAGE_FAILED'
    | 'USAGE_LIMITS_EXCEEDED'
    | 'EVENT_PUBLISH_FAILED'
    | 'JIRA_ERROR'
    | 'EXPRESSION_EVALUATION_FAILED'
    | 'KUBERNETES_VALUES_ERROR'
    | 'KUBERNETES_CLUSTER_ERROR'
    | 'INCORRECT_SIGN_IN_MECHANISM'
    | 'OAUTH_LOGIN_FAILED'
    | 'INVALID_TERRAFORM_TARGETS_REQUEST'
    | 'TERRAFORM_EXECUTION_ERROR'
    | 'FILE_READ_FAILED'
    | 'FILE_SIZE_EXCEEDS_LIMIT'
    | 'CLUSTER_NOT_FOUND'
    | 'MARKETPLACE_TOKEN_NOT_FOUND'
    | 'INVALID_MARKETPLACE_TOKEN'
    | 'INVALID_TICKETING_SERVER'
    | 'SERVICENOW_ERROR'
    | 'PASSWORD_EXPIRED'
    | 'USER_LOCKED'
    | 'PASSWORD_STRENGTH_CHECK_FAILED'
    | 'ACCOUNT_DISABLED'
    | 'INVALID_ACCOUNT_PERMISSION'
    | 'PAGERDUTY_ERROR'
    | 'HEALTH_ERROR'
    | 'SAML_TEST_SUCCESS_MECHANISM_NOT_ENABLED'
    | 'DOMAIN_WHITELIST_FILTER_CHECK_FAILED'
    | 'INVALID_DASHBOARD_UPDATE_REQUEST'
    | 'DUPLICATE_FIELD'
    | 'INVALID_AZURE_VAULT_CONFIGURATION'
    | 'USER_NOT_AUTHORIZED_DUE_TO_USAGE_RESTRICTIONS'
    | 'INVALID_ROLLBACK'
    | 'SUMO_DATA_COLLECTION_ERROR'
    | 'DEPLOYMENT_GOVERNANCE_ERROR'
    | 'BATCH_PROCESSING_ERROR'
    | 'GRAPHQL_ERROR'
    | 'FILE_CREATE_ERROR'
    | 'ILLEGAL_STATE'
    | 'GIT_DIFF_COMMIT_NOT_IN_ORDER'
    | 'FAILED_TO_ACQUIRE_PERSISTENT_LOCK'
    | 'FAILED_TO_ACQUIRE_NON_PERSISTENT_LOCK'
    | 'POD_NOT_FOUND_ERROR'
    | 'COMMAND_EXECUTION_ERROR'
    | 'REGISTRY_EXCEPTION'
    | 'ENGINE_INTERRUPT_PROCESSING_EXCEPTION'
    | 'ENGINE_IO_EXCEPTION'
    | 'ENGINE_OUTCOME_EXCEPTION'
    | 'ENGINE_SWEEPING_OUTPUT_EXCEPTION'
    | 'CACHE_NOT_FOUND_EXCEPTION'
    | 'ENGINE_ENTITY_UPDATE_EXCEPTION'
    | 'SHELL_EXECUTION_EXCEPTION'
    | 'TEMPLATE_NOT_FOUND'
    | 'AZURE_SERVICE_EXCEPTION'
    | 'AZURE_CLIENT_EXCEPTION'
    | 'GIT_UNSEEN_REMOTE_HEAD_COMMIT'
    | 'TIMEOUT_ENGINE_EXCEPTION'
    | 'NO_AVAILABLE_DELEGATES'
    | 'NO_INSTALLED_DELEGATES'
    | 'DUPLICATE_DELEGATE_EXCEPTION'
    | 'GCP_MARKETPLACE_EXCEPTION'
    | 'MISSING_DEFAULT_GOOGLE_CREDENTIALS'
    | 'INCORRECT_DEFAULT_GOOGLE_CREDENTIALS'
    | 'OPTIMISTIC_LOCKING_EXCEPTION'
    | 'NG_PIPELINE_EXECUTION_EXCEPTION'
    | 'NG_PIPELINE_CREATE_EXCEPTION'
    | 'RESOURCE_NOT_FOUND_EXCEPTION'
    | 'PMS_INITIALIZE_SDK_EXCEPTION'
    | 'UNEXPECTED_SNIPPET_EXCEPTION'
    | 'UNEXPECTED_SCHEMA_EXCEPTION'
    | 'CONNECTOR_VALIDATION_EXCEPTION'
    | 'GCP_SECRET_MANAGER_OPERATION_ERROR'
    | 'GCP_SECRET_OPERATION_ERROR'
    | 'GIT_OPERATION_ERROR'
    | 'TASK_FAILURE_ERROR'
    | 'INSTANCE_STATS_PROCESS_ERROR'
    | 'INSTANCE_STATS_MIGRATION_ERROR'
    | 'DEPLOYMENT_MIGRATION_ERROR'
    | 'INSTANCE_STATS_AGGREGATION_ERROR'
    | 'UNRESOLVED_EXPRESSIONS_ERROR'
    | 'KRYO_HANDLER_NOT_FOUND_ERROR'
    | 'DELEGATE_ERROR_HANDLER_EXCEPTION'
    | 'UNEXPECTED_TYPE_ERROR'
    | 'EXCEPTION_HANDLER_NOT_FOUND'
    | 'CONNECTOR_NOT_FOUND_EXCEPTION'
    | 'GCP_SERVER_ERROR'
    | 'HTTP_RESPONSE_EXCEPTION'
    | 'DATA'
  message?: string
  correlationId?: string
  detailedMessage?: string
  responseMessages?: ResponseMessage[]
}

export interface ResponseMessage {
  code?:
    | 'DEFAULT_ERROR_CODE'
    | 'INVALID_ARGUMENT'
    | 'INVALID_EMAIL'
    | 'DOMAIN_NOT_ALLOWED_TO_REGISTER'
    | 'USER_ALREADY_REGISTERED'
    | 'USER_INVITATION_DOES_NOT_EXIST'
    | 'USER_DOES_NOT_EXIST'
    | 'USER_INVITE_OPERATION_FAILED'
    | 'USER_DISABLED'
    | 'ACCOUNT_DOES_NOT_EXIST'
    | 'INACTIVE_ACCOUNT'
    | 'ACCOUNT_MIGRATED'
    | 'USER_DOMAIN_NOT_ALLOWED'
    | 'MAX_FAILED_ATTEMPT_COUNT_EXCEEDED'
    | 'RESOURCE_NOT_FOUND'
    | 'ROLE_DOES_NOT_EXIST'
    | 'EMAIL_NOT_VERIFIED'
    | 'EMAIL_VERIFICATION_TOKEN_NOT_FOUND'
    | 'INVALID_TOKEN'
    | 'INVALID_CAPTCHA_TOKEN'
    | 'NOT_ACCOUNT_MGR_NOR_HAS_ALL_APP_ACCESS'
    | 'EXPIRED_TOKEN'
    | 'TOKEN_ALREADY_REFRESHED_ONCE'
    | 'ACCESS_DENIED'
    | 'NG_ACCESS_DENIED'
    | 'INVALID_CREDENTIAL'
    | 'INVALID_KEY'
    | 'INVALID_KEYPATH'
    | 'INVALID_VARIABLE'
    | 'UNKNOWN_HOST'
    | 'UNREACHABLE_HOST'
    | 'INVALID_PORT'
    | 'SSH_SESSION_TIMEOUT'
    | 'SOCKET_CONNECTION_ERROR'
    | 'SOCKET_CONNECTION_TIMEOUT'
    | 'CONNECTION_TIMEOUT'
    | 'SSH_CONNECTION_ERROR'
    | 'USER_GROUP_ERROR'
    | 'INVALID_EXECUTION_ID'
    | 'ERROR_IN_GETTING_CHANNEL_STREAMS'
    | 'UNEXPECTED'
    | 'UNKNOWN_ERROR'
    | 'UNKNOWN_EXECUTOR_TYPE_ERROR'
    | 'DUPLICATE_STATE_NAMES'
    | 'TRANSITION_NOT_LINKED'
    | 'TRANSITION_TO_INCORRECT_STATE'
    | 'TRANSITION_TYPE_NULL'
    | 'STATES_WITH_DUP_TRANSITIONS'
    | 'BARRIERS_NOT_RUNNING_CONCURRENTLY'
    | 'NON_FORK_STATES'
    | 'NON_REPEAT_STATES'
    | 'INITIAL_STATE_NOT_DEFINED'
    | 'FILE_INTEGRITY_CHECK_FAILED'
    | 'INVALID_URL'
    | 'FILE_DOWNLOAD_FAILED'
    | 'PLATFORM_SOFTWARE_DELETE_ERROR'
    | 'INVALID_CSV_FILE'
    | 'INVALID_REQUEST'
    | 'INVALID_INFRA_STATE'
    | 'PIPELINE_ALREADY_TRIGGERED'
    | 'NON_EXISTING_PIPELINE'
    | 'DUPLICATE_COMMAND_NAMES'
    | 'INVALID_PIPELINE'
    | 'COMMAND_DOES_NOT_EXIST'
    | 'DUPLICATE_ARTIFACTSTREAM_NAMES'
    | 'DUPLICATE_HOST_NAMES'
    | 'STATE_NOT_FOR_TYPE'
    | 'STATE_MACHINE_ISSUE'
    | 'STATE_DISCONTINUE_FAILED'
    | 'STATE_PAUSE_FAILED'
    | 'PAUSE_ALL_ALREADY'
    | 'RESUME_ALL_ALREADY'
    | 'ROLLBACK_ALREADY'
    | 'ABORT_ALL_ALREADY'
    | 'RETRY_FAILED'
    | 'UNKNOWN_ARTIFACT_TYPE'
    | 'UNKNOWN_STAGE_ELEMENT_WRAPPER_TYPE'
    | 'INIT_TIMEOUT'
    | 'LICENSE_EXPIRED'
    | 'NOT_LICENSED'
    | 'REQUEST_TIMEOUT'
    | 'WORKFLOW_ALREADY_TRIGGERED'
    | 'JENKINS_ERROR'
    | 'INVALID_ARTIFACT_SOURCE'
    | 'INVALID_ARTIFACT_SERVER'
    | 'INVALID_CLOUD_PROVIDER'
    | 'UPDATE_NOT_ALLOWED'
    | 'DELETE_NOT_ALLOWED'
    | 'APPDYNAMICS_CONFIGURATION_ERROR'
    | 'APM_CONFIGURATION_ERROR'
    | 'SPLUNK_CONFIGURATION_ERROR'
    | 'ELK_CONFIGURATION_ERROR'
    | 'LOGZ_CONFIGURATION_ERROR'
    | 'SUMO_CONFIGURATION_ERROR'
    | 'INSTANA_CONFIGURATION_ERROR'
    | 'APPDYNAMICS_ERROR'
    | 'STACKDRIVER_ERROR'
    | 'STACKDRIVER_CONFIGURATION_ERROR'
    | 'NEWRELIC_CONFIGURATION_ERROR'
    | 'NEWRELIC_ERROR'
    | 'DYNA_TRACE_CONFIGURATION_ERROR'
    | 'DYNA_TRACE_ERROR'
    | 'CLOUDWATCH_ERROR'
    | 'CLOUDWATCH_CONFIGURATION_ERROR'
    | 'PROMETHEUS_CONFIGURATION_ERROR'
    | 'DATA_DOG_CONFIGURATION_ERROR'
    | 'SERVICE_GUARD_CONFIGURATION_ERROR'
    | 'ENCRYPTION_NOT_CONFIGURED'
    | 'UNAVAILABLE_DELEGATES'
    | 'WORKFLOW_EXECUTION_IN_PROGRESS'
    | 'PIPELINE_EXECUTION_IN_PROGRESS'
    | 'AWS_ACCESS_DENIED'
    | 'AWS_CLUSTER_NOT_FOUND'
    | 'AWS_SERVICE_NOT_FOUND'
    | 'INVALID_YAML_PAYLOAD'
    | 'UNRECOGNIZED_YAML_FIELDS'
    | 'COULD_NOT_MAP_BEFORE_YAML'
    | 'MISSING_BEFORE_YAML'
    | 'MISSING_YAML'
    | 'NON_EMPTY_DELETIONS'
    | 'GENERAL_YAML_ERROR'
    | 'GENERAL_YAML_INFO'
    | 'YAML_GIT_SYNC_ERROR'
    | 'GIT_CONNECTION_ERROR'
    | 'GIT_ERROR'
    | 'ARTIFACT_SERVER_ERROR'
    | 'ENCRYPT_DECRYPT_ERROR'
    | 'SECRET_MANAGEMENT_ERROR'
    | 'KMS_OPERATION_ERROR'
    | 'GCP_KMS_OPERATION_ERROR'
    | 'VAULT_OPERATION_ERROR'
    | 'AWS_SECRETS_MANAGER_OPERATION_ERROR'
    | 'AZURE_KEY_VAULT_OPERATION_ERROR'
    | 'CYBERARK_OPERATION_ERROR'
    | 'UNSUPPORTED_OPERATION_EXCEPTION'
    | 'FEATURE_UNAVAILABLE'
    | 'GENERAL_ERROR'
    | 'BASELINE_CONFIGURATION_ERROR'
    | 'SAML_IDP_CONFIGURATION_NOT_AVAILABLE'
    | 'INVALID_AUTHENTICATION_MECHANISM'
    | 'INVALID_SAML_CONFIGURATION'
    | 'INVALID_OAUTH_CONFIGURATION'
    | 'INVALID_LDAP_CONFIGURATION'
    | 'USER_GROUP_SYNC_FAILURE'
    | 'USER_GROUP_ALREADY_EXIST'
    | 'INVALID_TWO_FACTOR_AUTHENTICATION_CONFIGURATION'
    | 'EXPLANATION'
    | 'HINT'
    | 'NOT_WHITELISTED_IP'
    | 'INVALID_TOTP_TOKEN'
    | 'EMAIL_FAILED'
    | 'SSL_HANDSHAKE_FAILED'
    | 'NO_APPS_ASSIGNED'
    | 'INVALID_INFRA_CONFIGURATION'
    | 'TEMPLATES_LINKED'
    | 'USER_HAS_NO_PERMISSIONS'
    | 'USER_NOT_AUTHORIZED'
    | 'USER_ALREADY_PRESENT'
    | 'INVALID_USAGE_RESTRICTION'
    | 'USAGE_RESTRICTION_ERROR'
    | 'STATE_EXECUTION_INSTANCE_NOT_FOUND'
    | 'DELEGATE_TASK_RETRY'
    | 'KUBERNETES_YAML_ERROR'
    | 'SAVE_FILE_INTO_GCP_STORAGE_FAILED'
    | 'READ_FILE_FROM_GCP_STORAGE_FAILED'
    | 'USAGE_LIMITS_EXCEEDED'
    | 'EVENT_PUBLISH_FAILED'
    | 'JIRA_ERROR'
    | 'EXPRESSION_EVALUATION_FAILED'
    | 'KUBERNETES_VALUES_ERROR'
    | 'KUBERNETES_CLUSTER_ERROR'
    | 'INCORRECT_SIGN_IN_MECHANISM'
    | 'OAUTH_LOGIN_FAILED'
    | 'INVALID_TERRAFORM_TARGETS_REQUEST'
    | 'TERRAFORM_EXECUTION_ERROR'
    | 'FILE_READ_FAILED'
    | 'FILE_SIZE_EXCEEDS_LIMIT'
    | 'CLUSTER_NOT_FOUND'
    | 'MARKETPLACE_TOKEN_NOT_FOUND'
    | 'INVALID_MARKETPLACE_TOKEN'
    | 'INVALID_TICKETING_SERVER'
    | 'SERVICENOW_ERROR'
    | 'PASSWORD_EXPIRED'
    | 'USER_LOCKED'
    | 'PASSWORD_STRENGTH_CHECK_FAILED'
    | 'ACCOUNT_DISABLED'
    | 'INVALID_ACCOUNT_PERMISSION'
    | 'PAGERDUTY_ERROR'
    | 'HEALTH_ERROR'
    | 'SAML_TEST_SUCCESS_MECHANISM_NOT_ENABLED'
    | 'DOMAIN_WHITELIST_FILTER_CHECK_FAILED'
    | 'INVALID_DASHBOARD_UPDATE_REQUEST'
    | 'DUPLICATE_FIELD'
    | 'INVALID_AZURE_VAULT_CONFIGURATION'
    | 'USER_NOT_AUTHORIZED_DUE_TO_USAGE_RESTRICTIONS'
    | 'INVALID_ROLLBACK'
    | 'SUMO_DATA_COLLECTION_ERROR'
    | 'DEPLOYMENT_GOVERNANCE_ERROR'
    | 'BATCH_PROCESSING_ERROR'
    | 'GRAPHQL_ERROR'
    | 'FILE_CREATE_ERROR'
    | 'ILLEGAL_STATE'
    | 'GIT_DIFF_COMMIT_NOT_IN_ORDER'
    | 'FAILED_TO_ACQUIRE_PERSISTENT_LOCK'
    | 'FAILED_TO_ACQUIRE_NON_PERSISTENT_LOCK'
    | 'POD_NOT_FOUND_ERROR'
    | 'COMMAND_EXECUTION_ERROR'
    | 'REGISTRY_EXCEPTION'
    | 'ENGINE_INTERRUPT_PROCESSING_EXCEPTION'
    | 'ENGINE_IO_EXCEPTION'
    | 'ENGINE_OUTCOME_EXCEPTION'
    | 'ENGINE_SWEEPING_OUTPUT_EXCEPTION'
    | 'CACHE_NOT_FOUND_EXCEPTION'
    | 'ENGINE_ENTITY_UPDATE_EXCEPTION'
    | 'SHELL_EXECUTION_EXCEPTION'
    | 'TEMPLATE_NOT_FOUND'
    | 'AZURE_SERVICE_EXCEPTION'
    | 'AZURE_CLIENT_EXCEPTION'
    | 'GIT_UNSEEN_REMOTE_HEAD_COMMIT'
    | 'TIMEOUT_ENGINE_EXCEPTION'
    | 'NO_AVAILABLE_DELEGATES'
    | 'NO_INSTALLED_DELEGATES'
    | 'DUPLICATE_DELEGATE_EXCEPTION'
    | 'GCP_MARKETPLACE_EXCEPTION'
    | 'MISSING_DEFAULT_GOOGLE_CREDENTIALS'
    | 'INCORRECT_DEFAULT_GOOGLE_CREDENTIALS'
    | 'OPTIMISTIC_LOCKING_EXCEPTION'
    | 'NG_PIPELINE_EXECUTION_EXCEPTION'
    | 'NG_PIPELINE_CREATE_EXCEPTION'
    | 'RESOURCE_NOT_FOUND_EXCEPTION'
    | 'PMS_INITIALIZE_SDK_EXCEPTION'
    | 'UNEXPECTED_SNIPPET_EXCEPTION'
    | 'UNEXPECTED_SCHEMA_EXCEPTION'
    | 'CONNECTOR_VALIDATION_EXCEPTION'
    | 'GCP_SECRET_MANAGER_OPERATION_ERROR'
    | 'GCP_SECRET_OPERATION_ERROR'
    | 'GIT_OPERATION_ERROR'
    | 'TASK_FAILURE_ERROR'
    | 'INSTANCE_STATS_PROCESS_ERROR'
    | 'INSTANCE_STATS_MIGRATION_ERROR'
    | 'DEPLOYMENT_MIGRATION_ERROR'
    | 'INSTANCE_STATS_AGGREGATION_ERROR'
    | 'UNRESOLVED_EXPRESSIONS_ERROR'
    | 'KRYO_HANDLER_NOT_FOUND_ERROR'
    | 'DELEGATE_ERROR_HANDLER_EXCEPTION'
    | 'UNEXPECTED_TYPE_ERROR'
    | 'EXCEPTION_HANDLER_NOT_FOUND'
    | 'CONNECTOR_NOT_FOUND_EXCEPTION'
    | 'GCP_SERVER_ERROR'
    | 'HTTP_RESPONSE_EXCEPTION'
    | 'DATA'
  level?: 'INFO' | 'ERROR'
  message?: string
  exception?: Throwable
  failureTypes?: (
    | 'EXPIRED'
    | 'DELEGATE_PROVISIONING'
    | 'CONNECTIVITY'
    | 'AUTHENTICATION'
    | 'VERIFICATION_FAILURE'
    | 'APPLICATION_ERROR'
    | 'AUTHORIZATION_ERROR'
    | 'TIMEOUT_ERROR'
  )[]
}

export interface StackTraceElement {
  methodName?: string
  fileName?: string
  lineNumber?: number
  className?: string
  nativeMethod?: boolean
}

export interface Throwable {
  cause?: Throwable
  stackTrace?: StackTraceElement[]
  message?: string
  localizedMessage?: string
  suppressed?: Throwable[]
}

export interface ResponseBoolean {
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
  data?: boolean
  metaData?: { [key: string]: any }
  correlationId?: string
}

export interface Page {
  totalPages?: number
  totalElements?: number
  size?: number
  content?: { [key: string]: any }[]
  number?: number
  sort?: Sort
  first?: boolean
  last?: boolean
  pageable?: Pageable
  numberOfElements?: number
  empty?: boolean
}

export interface PageFilterDTO {
  totalPages?: number
  totalItems?: number
  pageItemCount?: number
  pageSize?: number
  content?: FilterDTO[]
  pageIndex?: number
  empty?: boolean
}

export interface ResponsePageFilterDTO {
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
  data?: PageFilterDTO
  metaData?: { [key: string]: any }
  correlationId?: string
}

export interface NGTriggerResponse {
  name?: string
  identifier?: string
  description?: string
  type?: 'Webhook' | 'NewArtifact' | 'Scheduled'
  accountIdentifier?: string
  orgIdentifier?: string
  projectIdentifier?: string
  targetIdentifier?: string
  yaml?: string
  version?: number
  enabled?: boolean
}

export interface ResponseNGTriggerResponse {
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
  data?: NGTriggerResponse
  metaData?: { [key: string]: any }
  correlationId?: string
}

export type AwsCodeCommitTriggerSpec = WebhookTriggerSpec & {
  gitRepoSpec?: GitRepoSpec
}

export type BitbucketTriggerSpec = WebhookTriggerSpec & {
  gitRepoSpec?: GitRepoSpec
}

export type CronTriggerSpec = ScheduledTriggerSpec & {
  expression?: string
}

export type CustomWebhookTriggerSpec = WebhookTriggerSpec & {}

export interface GitRepoSpec {
  identifier?: string
  repoName?: string
}

export type GithubTriggerSpec = WebhookTriggerSpec & {
  gitRepoSpec?: GitRepoSpec
}

export type GitlabTriggerSpec = WebhookTriggerSpec & {
  gitRepoSpec?: GitRepoSpec
}

export interface NGTriggerConfig {
  name?: string
  identifier: string
  description?: string
  target?: NGTriggerTarget
  source?: NGTriggerSource
  tags?: {
    [key: string]: string
  }
  enabled?: boolean
}

export interface NGTriggerSource {
  type?: 'Webhook' | 'NewArtifact' | 'Scheduled'
  spec?: NGTriggerSpec
}

export interface NGTriggerSpec {
  [key: string]: any
}

export interface NGTriggerTarget {
  targetIdentifier?: string
  type?: 'Pipeline'
  spec?: TargetSpec
}

export type PipelineTargetSpec = TargetSpec & {
  runtimeInputYaml?: string
}

export interface RepoSpec {
  identifier?: string
  repoName?: string
}

export type ScheduledTriggerConfig = NGTriggerSpec & {
  type?: string
  spec?: ScheduledTriggerSpec
}

export interface ScheduledTriggerSpec {
  [key: string]: any
}

export interface TargetSpec {
  [key: string]: any
}

export interface WebhookCondition {
  key?: string
  operator?: string
  value?: string
}

export type WebhookTriggerConfig = NGTriggerSpec & {
  type?: string
  spec?: WebhookTriggerSpec
}

export interface WebhookTriggerSpec {
  actions?: (
    | 'created'
    | 'closed'
    | 'edited'
    | 'edited'
    | 'opened'
    | 'reopened'
    | 'labeled'
    | 'unlabeled'
    | 'deleted'
    | 'synchronized'
    | 'synced'
    | 'merged'
    | 'sync'
    | 'open'
    | 'close'
    | 'reopen'
    | 'merge'
    | 'update'
    | 'pull request created'
    | 'pull request updated'
    | 'pull request merged'
    | 'pull request declined'
    | 'created'
    | 'deleted'
  )[]
  type?: 'GITHUB' | 'GITLAB' | 'BITBUCKET' | 'AWS_CODECOMMIT' | 'CUSTOM'
  repoSpec?: RepoSpec
  payloadConditions?: WebhookCondition[]
  jexlCondition?: string
  pathFilters?: string[]
  headerConditions?: WebhookCondition[]
  event?: 'Pull Request' | 'Push' | 'Issue Comment' | 'Delete' | 'Merge Request' | 'Repository' | 'Branch' | 'Tag'
}

export interface LastTriggerExecutionDetails {
  lastExecutionTime?: number
  lastExecutionSuccessful?: boolean
  lastExecutionStatus?: string
  planExecutionId?: string
  message?: string
}

export interface NGTriggerDetailsResponse {
  name?: string
  identifier?: string
  description?: string
  type?: 'Webhook' | 'NewArtifact' | 'Scheduled'
  lastTriggerExecutionDetails?: LastTriggerExecutionDetails
  webhookDetails?: WebhookDetails
  tags?: {
    [key: string]: string
  }
  executions?: number[]
  yaml?: string
  enabled?: boolean
}

export interface PageNGTriggerDetailsResponse {
  totalPages?: number
  totalItems?: number
  pageItemCount?: number
  pageSize?: number
  content?: NGTriggerDetailsResponse[]
  pageIndex?: number
  empty?: boolean
}

export interface ResponsePageNGTriggerDetailsResponse {
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
  data?: PageNGTriggerDetailsResponse
  metaData?: { [key: string]: any }
  correlationId?: string
}

export interface WebhookDetails {
  webhookSecret?: string
  webhookSourceRepo?: string
}

export interface ResponseNGTriggerDetailsResponse {
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
  data?: NGTriggerDetailsResponse
  metaData?: { [key: string]: any }
  correlationId?: string
}

export interface PageNGTriggerResponse {
  totalPages?: number
  totalItems?: number
  pageItemCount?: number
  pageSize?: number
  content?: NGTriggerResponse[]
  pageIndex?: number
  empty?: boolean
}

export interface ResponsePageNGTriggerResponse {
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
  data?: PageNGTriggerResponse
  metaData?: { [key: string]: any }
  correlationId?: string
}

export interface RestResponse {
  metaData?: {
    [key: string]: { [key: string]: any }
  }
  resource?: { [key: string]: any }
  responseMessages?: ResponseMessage[]
}

export interface RestResponseString {
  metaData?: {
    [key: string]: { [key: string]: any }
  }
  resource?: string
  responseMessages?: ResponseMessage[]
}

export interface ResponseMapWebhookSourceRepoListWebhookEvent {
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
  data?: {
    [key: string]: (
      | 'Pull Request'
      | 'Push'
      | 'Issue Comment'
      | 'Delete'
      | 'Merge Request'
      | 'Repository'
      | 'Branch'
      | 'Tag'
    )[]
  }
  metaData?: { [key: string]: any }
  correlationId?: string
}

export interface ResponseListWebhookAction {
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
  data?: (
    | 'created'
    | 'closed'
    | 'edited'
    | 'edited'
    | 'opened'
    | 'reopened'
    | 'labeled'
    | 'unlabeled'
    | 'deleted'
    | 'synchronized'
    | 'synced'
    | 'merged'
    | 'sync'
    | 'open'
    | 'close'
    | 'reopen'
    | 'merge'
    | 'update'
    | 'pull request created'
    | 'pull request updated'
    | 'pull request merged'
    | 'pull request declined'
    | 'created'
    | 'deleted'
  )[]
  metaData?: { [key: string]: any }
  correlationId?: string
}

export interface ResponseString {
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
  data?: string
  metaData?: { [key: string]: any }
  correlationId?: string
}

export interface ApprovalInstanceDetailsDTO {
  [key: string]: any
}

export interface ApprovalInstanceResponse {
  id?: string
  type: 'HarnessApproval' | 'JiraApproval'
  status: 'WAITING' | 'APPROVED' | 'REJECTED' | 'EXPIRED'
  deadline?: number
  details: ApprovalInstanceDetailsDTO
  createdAt?: number
  lastModifiedAt?: number
}

export interface ApproverInput {
  name?: string
  value: string
}

export interface ApproverInputInfoDTO {
  name?: string
  defaultValue?: string
}

export interface ApproversDTO {
  userGroups?: string[]
  minimumCount?: number
  disallowPipelineExecutor?: boolean
}

export interface ConditionDTO {
  key: string
  value: string
  operator: 'equals' | 'not equals' | 'in' | 'not in'
}

export interface CriteriaSpecDTO {
  [key: string]: any
}

export interface CriteriaSpecWrapperDTO {
  type: 'Jexl' | 'KeyValues'
  spec: CriteriaSpecDTO
}

export interface EmbeddedUser {
  uuid?: string
  name?: string
  email?: string
}

export interface HarnessApprovalActivity {
  user: EmbeddedUser
  action: 'APPROVE' | 'REJECT'
  approverInputs?: ApproverInput[]
  comments?: string
  approvedAt?: number
}

export type HarnessApprovalInstanceDetails = ApprovalInstanceDetailsDTO & {
  approvalMessage: string
  includePipelineExecutionHistory?: boolean
  approvers: ApproversDTO
  approvalActivities?: HarnessApprovalActivity[]
  approverInputs?: ApproverInputInfoDTO[]
}

export type JexlCriteriaSpec = CriteriaSpecDTO & {
  expression?: string
}

export type JiraApprovalInstanceDetails = ApprovalInstanceDetailsDTO & {
  connectorRef?: string
  issue: JiraIssueKeyNG
  approvalCriteria: CriteriaSpecWrapperDTO
  rejectionCriteria: CriteriaSpecWrapperDTO
}

export interface JiraIssueKeyNG {
  url: string
  key: string
}

export interface ResponseApprovalInstanceResponse {
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
  data?: ApprovalInstanceResponse
  metaData?: { [key: string]: any }
  correlationId?: string
}

export type KeyValueCriteriaSpec = CriteriaSpecDTO & {
  matchAnyCondition?: boolean
  conditions: ConditionDTO[]
}

export interface HarnessApprovalActivityRequest {
  action: 'APPROVE' | 'REJECT'
  approverInputs?: ApproverInput[]
  comments?: string
}

export interface HarnessApprovalInstanceAuthorization {
  authorized?: boolean
  reason?: string
}

export interface ResponseHarnessApprovalInstanceAuthorization {
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
  data?: HarnessApprovalInstanceAuthorization
  metaData?: { [key: string]: any }
  correlationId?: string
}

export interface BarrierSetupInfo {
  name?: string
  identifier?: string
  stages?: StageDetail[]
}

export interface ResponseListBarrierSetupInfo {
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
  data?: BarrierSetupInfo[]
  metaData?: { [key: string]: any }
  correlationId?: string
}

export interface StageDetail {
  name?: string
}

export interface BarrierExecutionInfo {
  name?: string
  identifier?: string
  startedAt?: number
  started?: boolean
  timeoutIn?: number
  stages?: StageDetail[]
}

export interface ResponseListBarrierExecutionInfo {
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
  data?: BarrierExecutionInfo[]
  metaData?: { [key: string]: any }
  correlationId?: string
}

export interface BarrierInfo {
  name?: string
  timeoutIn?: number
  stages?: StageDetail[]
}

export interface ResponseBarrierInfo {
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
  data?: BarrierInfo
  metaData?: { [key: string]: any }
  correlationId?: string
}

export interface InputSetError {
  fieldName?: string
  message?: string
  identifierOfErrorSource?: string
}

export interface InputSetErrorResponse {
  errors?: InputSetError[]
}

export interface InputSetErrorWrapper {
  errorPipelineYaml?: string
  uuidToErrorResponseMap?: {
    [key: string]: InputSetErrorResponse
  }
}

export interface InputSetResponse {
  accountId?: string
  orgIdentifier?: string
  projectIdentifier?: string
  pipelineIdentifier?: string
  identifier?: string
  inputSetYaml?: string
  name?: string
  description?: string
  tags?: {
    [key: string]: string
  }
  inputSetErrorWrapper?: InputSetErrorWrapper
  version?: number
  errorResponse?: boolean
}

export interface ResponseInputSetResponse {
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
  data?: InputSetResponse
  metaData?: { [key: string]: any }
  correlationId?: string
}

export interface OverlayInputSetResponse {
  accountId?: string
  orgIdentifier?: string
  projectIdentifier?: string
  pipelineIdentifier?: string
  identifier?: string
  name?: string
  description?: string
  inputSetReferences?: string[]
  overlayInputSetYaml?: string
  tags?: {
    [key: string]: string
  }
  invalidInputSetReferences?: {
    [key: string]: string
  }
  version?: number
  errorResponse?: boolean
}

export interface ResponseOverlayInputSetResponse {
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
  data?: OverlayInputSetResponse
  metaData?: { [key: string]: any }
  correlationId?: string
}

export interface InputSetSummaryResponse {
  identifier?: string
  name?: string
  pipelineIdentifier?: string
  description?: string
  inputSetType?: 'INPUT_SET' | 'OVERLAY_INPUT_SET'
  tags?: {
    [key: string]: string
  }
  version?: number
}

export interface PageInputSetSummaryResponse {
  totalPages?: number
  totalItems?: number
  pageItemCount?: number
  pageSize?: number
  content?: InputSetSummaryResponse[]
  pageIndex?: number
  empty?: boolean
}

export interface ResponsePageInputSetSummaryResponse {
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
  data?: PageInputSetSummaryResponse
  metaData?: { [key: string]: any }
  correlationId?: string
}

export interface InputSetTemplateResponse {
  inputSetTemplateYaml?: string
}

export interface ResponseInputSetTemplateResponse {
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
  data?: InputSetTemplateResponse
  metaData?: { [key: string]: any }
  correlationId?: string
}

export interface MergeInputSetResponse {
  pipelineYaml?: string
  inputSetErrorWrapper?: InputSetErrorWrapper
  errorResponse?: boolean
}

export interface ResponseMergeInputSetResponse {
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
  data?: MergeInputSetResponse
  metaData?: { [key: string]: any }
  correlationId?: string
}

export interface MergeInputSetRequest {
  inputSetReferences?: string[]
}

export interface ByteString {
  empty?: boolean
  validUtf8?: boolean
}

export interface Descriptor {
  index?: number
  fullName?: string
  file?: FileDescriptor
  containingType?: Descriptor
  nestedTypes?: Descriptor[]
  enumTypes?: EnumDescriptor[]
  fields?: FieldDescriptor[]
  extensions?: FieldDescriptor[]
  oneofs?: OneofDescriptor[]
  name?: string
  options?: MessageOptions
  extendable?: boolean
}

export interface EnumDescriptor {
  index?: number
  fullName?: string
  file?: FileDescriptor
  containingType?: Descriptor
  values?: EnumValueDescriptor[]
  name?: string
  options?: EnumOptions
}

export interface EnumOptions {
  unknownFields?: UnknownFieldSet
  initialized?: boolean
  serializedSize?: number
  parserForType?: ParserEnumOptions
  defaultInstanceForType?: EnumOptions
  deprecated?: boolean
  uninterpretedOptionList?: UninterpretedOption[]
  uninterpretedOptionOrBuilderList?: UninterpretedOptionOrBuilder[]
  uninterpretedOptionCount?: number
  allowAlias?: boolean
  initializationErrorString?: string
  descriptorForType?: Descriptor
  allFields?: {
    [key: string]: { [key: string]: any }
  }
  allFieldsRaw?: {
    [key: string]: { [key: string]: any }
  }
}

export interface EnumValueDescriptor {
  index?: number
  fullName?: string
  file?: FileDescriptor
  type?: EnumDescriptor
  name?: string
  number?: number
  options?: EnumValueOptions
}

export interface EnumValueOptions {
  unknownFields?: UnknownFieldSet
  initialized?: boolean
  serializedSize?: number
  parserForType?: ParserEnumValueOptions
  defaultInstanceForType?: EnumValueOptions
  deprecated?: boolean
  uninterpretedOptionList?: UninterpretedOption[]
  uninterpretedOptionOrBuilderList?: UninterpretedOptionOrBuilder[]
  uninterpretedOptionCount?: number
  initializationErrorString?: string
  descriptorForType?: Descriptor
  allFields?: {
    [key: string]: { [key: string]: any }
  }
  allFieldsRaw?: {
    [key: string]: { [key: string]: any }
  }
}

export interface FieldDescriptor {
  index?: number
  fullName?: string
  jsonName?: string
  file?: FileDescriptor
  extensionScope?: Descriptor
  type?:
    | 'DOUBLE'
    | 'FLOAT'
    | 'INT64'
    | 'UINT64'
    | 'INT32'
    | 'FIXED64'
    | 'FIXED32'
    | 'BOOL'
    | 'STRING'
    | 'GROUP'
    | 'MESSAGE'
    | 'BYTES'
    | 'UINT32'
    | 'ENUM'
    | 'SFIXED32'
    | 'SFIXED64'
    | 'SINT32'
    | 'SINT64'
  containingType?: Descriptor
  messageType?: Descriptor
  containingOneof?: OneofDescriptor
  enumType?: EnumDescriptor
  defaultValue?: { [key: string]: any }
  name?: string
  number?: number
  required?: boolean
  optional?: boolean
  repeated?: boolean
  javaType?: 'INT' | 'LONG' | 'FLOAT' | 'DOUBLE' | 'BOOLEAN' | 'STRING' | 'BYTE_STRING' | 'ENUM' | 'MESSAGE'
  mapField?: boolean
  options?: FieldOptions
  extension?: boolean
  packed?: boolean
  liteJavaType?: 'INT' | 'LONG' | 'FLOAT' | 'DOUBLE' | 'BOOLEAN' | 'STRING' | 'BYTE_STRING' | 'ENUM' | 'MESSAGE'
  liteType?:
    | 'DOUBLE'
    | 'FLOAT'
    | 'INT64'
    | 'UINT64'
    | 'INT32'
    | 'FIXED64'
    | 'FIXED32'
    | 'BOOL'
    | 'STRING'
    | 'GROUP'
    | 'MESSAGE'
    | 'BYTES'
    | 'UINT32'
    | 'ENUM'
    | 'SFIXED32'
    | 'SFIXED64'
    | 'SINT32'
    | 'SINT64'
  packable?: boolean
}

export interface FieldOptions {
  unknownFields?: UnknownFieldSet
  initialized?: boolean
  serializedSize?: number
  parserForType?: ParserFieldOptions
  defaultInstanceForType?: FieldOptions
  packed?: boolean
  deprecated?: boolean
  uninterpretedOptionList?: UninterpretedOption[]
  uninterpretedOptionOrBuilderList?: UninterpretedOptionOrBuilder[]
  uninterpretedOptionCount?: number
  ctype?: 'STRING' | 'CORD' | 'STRING_PIECE'
  jstype?: 'JS_NORMAL' | 'JS_STRING' | 'JS_NUMBER'
  lazy?: boolean
  weak?: boolean
  initializationErrorString?: string
  descriptorForType?: Descriptor
  allFields?: {
    [key: string]: { [key: string]: any }
  }
  allFieldsRaw?: {
    [key: string]: { [key: string]: any }
  }
}

export interface FileDescriptor {
  messageTypes?: Descriptor[]
  enumTypes?: EnumDescriptor[]
  services?: ServiceDescriptor[]
  extensions?: FieldDescriptor[]
  dependencies?: FileDescriptor[]
  publicDependencies?: FileDescriptor[]
  name?: string
  package?: string
  file?: FileDescriptor
  fullName?: string
  options?: FileOptions
  syntax?: 'UNKNOWN' | 'PROTO2' | 'PROTO3'
}

export interface FileOptions {
  unknownFields?: UnknownFieldSet
  initialized?: boolean
  serializedSize?: number
  parserForType?: ParserFileOptions
  defaultInstanceForType?: FileOptions
  javaStringCheckUtf8?: boolean
  deprecated?: boolean
  uninterpretedOptionList?: UninterpretedOption[]
  uninterpretedOptionOrBuilderList?: UninterpretedOptionOrBuilder[]
  uninterpretedOptionCount?: number
  javaPackage?: string
  javaPackageBytes?: ByteString
  javaOuterClassname?: string
  javaOuterClassnameBytes?: ByteString
  javaMultipleFiles?: boolean
  javaGenerateEqualsAndHash?: boolean
  optimizeFor?: 'SPEED' | 'CODE_SIZE' | 'LITE_RUNTIME'
  goPackage?: string
  goPackageBytes?: ByteString
  ccGenericServices?: boolean
  javaGenericServices?: boolean
  pyGenericServices?: boolean
  phpGenericServices?: boolean
  ccEnableArenas?: boolean
  objcClassPrefix?: string
  objcClassPrefixBytes?: ByteString
  csharpNamespace?: string
  csharpNamespaceBytes?: ByteString
  swiftPrefix?: string
  swiftPrefixBytes?: ByteString
  phpClassPrefix?: string
  phpClassPrefixBytes?: ByteString
  phpNamespace?: string
  phpNamespaceBytes?: ByteString
  phpMetadataNamespace?: string
  phpMetadataNamespaceBytes?: ByteString
  rubyPackage?: string
  rubyPackageBytes?: ByteString
  initializationErrorString?: string
  descriptorForType?: Descriptor
  allFields?: {
    [key: string]: { [key: string]: any }
  }
  allFieldsRaw?: {
    [key: string]: { [key: string]: any }
  }
}

export interface Message {
  parserForType?: ParserMessage
  serializedSize?: number
  initialized?: boolean
  defaultInstanceForType?: MessageLite
  unknownFields?: UnknownFieldSet
  initializationErrorString?: string
  descriptorForType?: Descriptor
  allFields?: {
    [key: string]: { [key: string]: any }
  }
}

export interface MessageLite {
  serializedSize?: number
  parserForType?: ParserMessageLite
  initialized?: boolean
  defaultInstanceForType?: MessageLite
}

export interface MessageOptions {
  unknownFields?: UnknownFieldSet
  initialized?: boolean
  serializedSize?: number
  parserForType?: ParserMessageOptions
  defaultInstanceForType?: MessageOptions
  mapEntry?: boolean
  messageSetWireFormat?: boolean
  noStandardDescriptorAccessor?: boolean
  deprecated?: boolean
  uninterpretedOptionList?: UninterpretedOption[]
  uninterpretedOptionOrBuilderList?: UninterpretedOptionOrBuilder[]
  uninterpretedOptionCount?: number
  initializationErrorString?: string
  descriptorForType?: Descriptor
  allFields?: {
    [key: string]: { [key: string]: any }
  }
  allFieldsRaw?: {
    [key: string]: { [key: string]: any }
  }
}

export interface MethodDescriptor {
  index?: number
  fullName?: string
  file?: FileDescriptor
  service?: ServiceDescriptor
  inputType?: Descriptor
  outputType?: Descriptor
  name?: string
  options?: MethodOptions
  clientStreaming?: boolean
  serverStreaming?: boolean
}

export interface MethodOptions {
  unknownFields?: UnknownFieldSet
  initialized?: boolean
  serializedSize?: number
  parserForType?: ParserMethodOptions
  defaultInstanceForType?: MethodOptions
  deprecated?: boolean
  uninterpretedOptionList?: UninterpretedOption[]
  uninterpretedOptionOrBuilderList?: UninterpretedOptionOrBuilder[]
  uninterpretedOptionCount?: number
  idempotencyLevel?: 'IDEMPOTENCY_UNKNOWN' | 'NO_SIDE_EFFECTS' | 'IDEMPOTENT'
  initializationErrorString?: string
  descriptorForType?: Descriptor
  allFields?: {
    [key: string]: { [key: string]: any }
  }
  allFieldsRaw?: {
    [key: string]: { [key: string]: any }
  }
}

export interface NamePart {
  unknownFields?: UnknownFieldSet
  namePart?: string
  namePartBytes?: ByteString
  isExtension?: boolean
  initialized?: boolean
  serializedSize?: number
  parserForType?: ParserNamePart
  defaultInstanceForType?: NamePart
  initializationErrorString?: string
  descriptorForType?: Descriptor
  allFields?: {
    [key: string]: { [key: string]: any }
  }
}

export interface NamePartOrBuilder {
  namePart?: string
  namePartBytes?: ByteString
  isExtension?: boolean
  unknownFields?: UnknownFieldSet
  defaultInstanceForType?: Message
  initializationErrorString?: string
  descriptorForType?: Descriptor
  allFields?: {
    [key: string]: { [key: string]: any }
  }
  initialized?: boolean
}

export interface OneofDescriptor {
  index?: number
  fullName?: string
  file?: FileDescriptor
  containingType?: Descriptor
  fieldCount?: number
  fields?: FieldDescriptor[]
  name?: string
  options?: OneofOptions
}

export interface OneofOptions {
  unknownFields?: UnknownFieldSet
  initialized?: boolean
  serializedSize?: number
  parserForType?: ParserOneofOptions
  defaultInstanceForType?: OneofOptions
  uninterpretedOptionList?: UninterpretedOption[]
  uninterpretedOptionOrBuilderList?: UninterpretedOptionOrBuilder[]
  uninterpretedOptionCount?: number
  initializationErrorString?: string
  descriptorForType?: Descriptor
  allFields?: {
    [key: string]: { [key: string]: any }
  }
  allFieldsRaw?: {
    [key: string]: { [key: string]: any }
  }
}

export interface Parser {
  [key: string]: any
}

export interface ParserEnumOptions {
  [key: string]: any
}

export interface ParserEnumValueOptions {
  [key: string]: any
}

export interface ParserFieldOptions {
  [key: string]: any
}

export interface ParserFileOptions {
  [key: string]: any
}

export interface ParserMessage {
  [key: string]: any
}

export interface ParserMessageLite {
  [key: string]: any
}

export interface ParserMessageOptions {
  [key: string]: any
}

export interface ParserMethodOptions {
  [key: string]: any
}

export interface ParserNamePart {
  [key: string]: any
}

export interface ParserOneofOptions {
  [key: string]: any
}

export interface ParserServiceOptions {
  [key: string]: any
}

export interface ParserUninterpretedOption {
  [key: string]: any
}

export interface ParserYamlProperties {
  [key: string]: any
}

export interface ResponseVariableMergeServiceResponse {
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
  data?: VariableMergeServiceResponse
  metaData?: { [key: string]: any }
  correlationId?: string
}

export interface ServiceDescriptor {
  index?: number
  fullName?: string
  file?: FileDescriptor
  methods?: MethodDescriptor[]
  name?: string
  options?: ServiceOptions
}

export interface ServiceOptions {
  unknownFields?: UnknownFieldSet
  initialized?: boolean
  serializedSize?: number
  parserForType?: ParserServiceOptions
  defaultInstanceForType?: ServiceOptions
  deprecated?: boolean
  uninterpretedOptionList?: UninterpretedOption[]
  uninterpretedOptionOrBuilderList?: UninterpretedOptionOrBuilder[]
  uninterpretedOptionCount?: number
  initializationErrorString?: string
  descriptorForType?: Descriptor
  allFields?: {
    [key: string]: { [key: string]: any }
  }
  allFieldsRaw?: {
    [key: string]: { [key: string]: any }
  }
}

export interface UninterpretedOption {
  unknownFields?: UnknownFieldSet
  nameCount?: number
  initialized?: boolean
  serializedSize?: number
  parserForType?: ParserUninterpretedOption
  defaultInstanceForType?: UninterpretedOption
  stringValue?: ByteString
  doubleValue?: number
  nameList?: NamePart[]
  nameOrBuilderList?: NamePartOrBuilder[]
  identifierValue?: string
  identifierValueBytes?: ByteString
  positiveIntValue?: number
  negativeIntValue?: number
  aggregateValue?: string
  aggregateValueBytes?: ByteString
  initializationErrorString?: string
  descriptorForType?: Descriptor
  allFields?: {
    [key: string]: { [key: string]: any }
  }
}

export interface UninterpretedOptionOrBuilder {
  nameCount?: number
  stringValue?: ByteString
  doubleValue?: number
  nameList?: NamePart[]
  nameOrBuilderList?: NamePartOrBuilder[]
  identifierValue?: string
  identifierValueBytes?: ByteString
  positiveIntValue?: number
  negativeIntValue?: number
  aggregateValue?: string
  aggregateValueBytes?: ByteString
  unknownFields?: UnknownFieldSet
  defaultInstanceForType?: Message
  initializationErrorString?: string
  descriptorForType?: Descriptor
  allFields?: {
    [key: string]: { [key: string]: any }
  }
  initialized?: boolean
}

export interface UnknownFieldSet {
  initialized?: boolean
  serializedSize?: number
  parserForType?: Parser
  defaultInstanceForType?: UnknownFieldSet
  serializedSizeAsMessageSet?: number
}

export interface VariableMergeServiceResponse {
  yaml?: string
  metadataMap?: {
    [key: string]: VariableResponseMapValue
  }
  errorResponses?: string[]
}

export interface VariableResponseMapValue {
  yamlProperties?: YamlProperties
}

export interface YamlProperties {
  unknownFields?: UnknownFieldSet
  initialized?: boolean
  serializedSize?: number
  parserForType?: ParserYamlProperties
  defaultInstanceForType?: YamlProperties
  fqn?: string
  fqnBytes?: ByteString
  localNameBytes?: ByteString
  localName?: string
  initializationErrorString?: string
  descriptorForType?: Descriptor
  allFields?: {
    [key: string]: { [key: string]: any }
  }
}

export interface PMSPipelineResponseDTO {
  yamlPipeline?: string
  version?: number
}

export interface ResponsePMSPipelineResponseDTO {
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
  data?: PMSPipelineResponseDTO
  metaData?: { [key: string]: any }
  correlationId?: string
}

export interface PMSPipelineSummaryResponse {
  name?: string
  identifier?: string
  description?: string
  tags?: {
    [key: string]: string
  }
  version?: number
  numOfStages?: number
  createdAt?: number
  lastUpdatedAt?: number
  modules?: string[]
  executionSummaryInfo?: ExecutionSummaryInfo
  filters?: {
    [key: string]: {
      [key: string]: { [key: string]: any }
    }
  }
  stageNames?: string[]
}

export interface PagePMSPipelineSummaryResponse {
  totalPages?: number
  totalElements?: number
  size?: number
  content?: PMSPipelineSummaryResponse[]
  number?: number
  sort?: Sort
  first?: boolean
  last?: boolean
  pageable?: Pageable
  numberOfElements?: number
  empty?: boolean
}

export interface Pageable {
  offset?: number
  pageSize?: number
  sort?: Sort
  paged?: boolean
  unpaged?: boolean
  pageNumber?: number
}

export interface ResponsePagePMSPipelineSummaryResponse {
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
  data?: PagePMSPipelineSummaryResponse
  metaData?: { [key: string]: any }
  correlationId?: string
}

export interface Sort {
  unsorted?: boolean
  sorted?: boolean
  empty?: boolean
}

export interface ExecutionSummaryInfo {
  numOfErrors?: number[]
  deployments?: number[]
  lastExecutionTs?: number
  lastExecutionStatus?:
    | 'Running'
    | 'Failed'
    | 'NotStarted'
    | 'Expired'
    | 'Aborted'
    | 'Queued'
    | 'Paused'
    | 'Waiting'
    | 'Success'
    | 'Suspended'
    | 'Skipped'
    | 'Pausing'
  lastExecutionId?: string
}

export interface ResponsePMSPipelineSummaryResponse {
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
  data?: PMSPipelineSummaryResponse
  metaData?: { [key: string]: any }
  correlationId?: string
}

export interface EdgeLayoutList {
  currentNodeChildren?: string[]
  nextIds?: string[]
}

export interface ExecutionErrorInfo {
  unknownFields?: UnknownFieldSet
  message?: string
  initialized?: boolean
  serializedSize?: number
  parserForType?: ParserExecutionErrorInfo
  defaultInstanceForType?: ExecutionErrorInfo
  messageBytes?: ByteString
  initializationErrorString?: string
  descriptorForType?: Descriptor
  allFields?: {
    [key: string]: { [key: string]: any }
  }
}

export interface ExecutionTriggerInfo {
  unknownFields?: UnknownFieldSet
  initialized?: boolean
  serializedSize?: number
  parserForType?: ParserExecutionTriggerInfo
  defaultInstanceForType?: ExecutionTriggerInfo
  triggerTypeValue?: number
  triggerType?: 'NOOP' | 'MANUAL' | 'WEBHOOK' | 'WEBHOOK_CUSTOM' | 'SCHEDULER_CRON' | 'UNRECOGNIZED'
  triggeredBy?: TriggeredBy
  triggeredByOrBuilder?: TriggeredByOrBuilder
  initializationErrorString?: string
  descriptorForType?: Descriptor
  allFields?: {
    [key: string]: { [key: string]: any }
  }
}

export interface GraphLayoutNode {
  nodeType?: string
  nodeGroup?: string
  nodeIdentifier?: string
  name?: string
  nodeUuid?: string
  status?:
    | 'Running'
    | 'Failed'
    | 'NotStarted'
    | 'Expired'
    | 'Aborted'
    | 'Queued'
    | 'Paused'
    | 'Waiting'
    | 'Success'
    | 'Suspended'
    | 'Skipped'
    | 'Pausing'
  module?: string
  moduleInfo?: {
    [key: string]: {
      [key: string]: { [key: string]: any }
    }
  }
  startTs?: number
  endTs?: number
  edgeLayoutList?: EdgeLayoutList
  skipInfo?: SkipInfo
  nodeRunInfo?: NodeRunInfo
  barrierFound?: boolean
  failureInfo?: ExecutionErrorInfo
}

export interface NodeRunInfo {
  unknownFields?: UnknownFieldSet
  initialized?: boolean
  serializedSize?: number
  parserForType?: ParserNodeRunInfo
  defaultInstanceForType?: NodeRunInfo
  evaluatedCondition?: boolean
  whenCondition?: string
  whenConditionBytes?: ByteString
  initializationErrorString?: string
  descriptorForType?: Descriptor
  allFields?: {
    [key: string]: { [key: string]: any }
  }
}

export interface PagePipelineExecutionSummary {
  totalPages?: number
  totalElements?: number
  size?: number
  content?: PipelineExecutionSummary[]
  number?: number
  sort?: Sort
  first?: boolean
  last?: boolean
  pageable?: Pageable
  numberOfElements?: number
  empty?: boolean
}

export interface ParserExecutionErrorInfo {
  [key: string]: any
}

export interface ParserExecutionTriggerInfo {
  [key: string]: any
}

export interface ParserNodeRunInfo {
  [key: string]: any
}

export interface ParserSkipInfo {
  [key: string]: any
}

export interface ParserTriggeredBy {
  [key: string]: any
}

export interface PipelineExecutionSummary {
  pipelineIdentifier?: string
  planExecutionId?: string
  name?: string
  status?:
    | 'Running'
    | 'Failed'
    | 'NotStarted'
    | 'Expired'
    | 'Aborted'
    | 'Queued'
    | 'Paused'
    | 'Waiting'
    | 'Success'
    | 'Suspended'
    | 'Skipped'
    | 'Pausing'
  tags?: NGTag[]
  executionTriggerInfo?: ExecutionTriggerInfo
  executionErrorInfo?: ExecutionErrorInfo
  moduleInfo?: {
    [key: string]: {
      [key: string]: { [key: string]: any }
    }
  }
  layoutNodeMap?: {
    [key: string]: GraphLayoutNode
  }
  modules?: string[]
  startingNodeId?: string
  startTs?: number
  endTs?: number
  createdAt?: number
  runSequence?: number
  successfulStagesCount?: number
  runningStagesCount?: number
  failedStagesCount?: number
  totalStagesCount?: number
}

export interface ResponsePagePipelineExecutionSummary {
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
  data?: PagePipelineExecutionSummary
  metaData?: { [key: string]: any }
  correlationId?: string
}

export interface SkipInfo {
  unknownFields?: UnknownFieldSet
  initialized?: boolean
  serializedSize?: number
  parserForType?: ParserSkipInfo
  defaultInstanceForType?: SkipInfo
  skipCondition?: string
  skipConditionBytes?: ByteString
  evaluatedCondition?: boolean
  initializationErrorString?: string
  descriptorForType?: Descriptor
  allFields?: {
    [key: string]: { [key: string]: any }
  }
}

export interface TriggeredBy {
  unknownFields?: UnknownFieldSet
  initialized?: boolean
  serializedSize?: number
  parserForType?: ParserTriggeredBy
  defaultInstanceForType?: TriggeredBy
  uuid?: string
  uuidBytes?: ByteString
  identifierBytes?: ByteString
  extraInfoCount?: number
  extraInfo?: {
    [key: string]: string
  }
  extraInfoMap?: {
    [key: string]: string
  }
  identifier?: string
  initializationErrorString?: string
  descriptorForType?: Descriptor
  allFields?: {
    [key: string]: { [key: string]: any }
  }
}

export interface TriggeredByOrBuilder {
  uuid?: string
  uuidBytes?: ByteString
  identifierBytes?: ByteString
  extraInfoCount?: number
  extraInfo?: {
    [key: string]: string
  }
  extraInfoMap?: {
    [key: string]: string
  }
  identifier?: string
  unknownFields?: UnknownFieldSet
  defaultInstanceForType?: Message
  initializationErrorString?: string
  descriptorForType?: Descriptor
  allFields?: {
    [key: string]: { [key: string]: any }
  }
  initialized?: boolean
}

export interface AdviserIssuer {
  unknownFields?: UnknownFieldSet
  initialized?: boolean
  serializedSize?: number
  parserForType?: ParserAdviserIssuer
  defaultInstanceForType?: AdviserIssuer
  adviserTypeValue?: number
  adviserType?: 'UNKNOWN' | 'NEXT_STEP' | 'RETRY' | 'INTERVENTION_WAIT' | 'END_PLAN' | 'MARK_SUCCESS' | 'UNRECOGNIZED'
  initializationErrorString?: string
  descriptorForType?: Descriptor
  allFields?: {
    [key: string]: { [key: string]: any }
  }
}

export interface AdviserIssuerOrBuilder {
  adviserTypeValue?: number
  adviserType?: 'UNKNOWN' | 'NEXT_STEP' | 'RETRY' | 'INTERVENTION_WAIT' | 'END_PLAN' | 'MARK_SUCCESS' | 'UNRECOGNIZED'
  unknownFields?: UnknownFieldSet
  defaultInstanceForType?: Message
  initializationErrorString?: string
  descriptorForType?: Descriptor
  allFields?: {
    [key: string]: { [key: string]: any }
  }
  initialized?: boolean
}

export interface AsyncExecutableResponse {
  unknownFields?: UnknownFieldSet
  initialized?: boolean
  serializedSize?: number
  parserForType?: ParserAsyncExecutableResponse
  defaultInstanceForType?: AsyncExecutableResponse
  mode?: 'RUNNING_MODE' | 'APPROVAL_WAITING_MODE' | 'RESOURCE_WAITING_MODE' | 'UNRECOGNIZED'
  callbackIdsCount?: number
  callbackIdsList?: string[]
  logKeysList?: string[]
  logKeysCount?: number
  unitsList?: string[]
  unitsCount?: number
  modeValue?: number
  initializationErrorString?: string
  descriptorForType?: Descriptor
  allFields?: {
    [key: string]: { [key: string]: any }
  }
}

export interface AsyncExecutableResponseOrBuilder {
  mode?: 'RUNNING_MODE' | 'APPROVAL_WAITING_MODE' | 'RESOURCE_WAITING_MODE' | 'UNRECOGNIZED'
  callbackIdsCount?: number
  callbackIdsList?: string[]
  logKeysList?: string[]
  logKeysCount?: number
  unitsList?: string[]
  unitsCount?: number
  modeValue?: number
  unknownFields?: UnknownFieldSet
  defaultInstanceForType?: Message
  initializationErrorString?: string
  descriptorForType?: Descriptor
  allFields?: {
    [key: string]: { [key: string]: any }
  }
  initialized?: boolean
}

export interface Child {
  unknownFields?: UnknownFieldSet
  initialized?: boolean
  serializedSize?: number
  parserForType?: ParserChild
  defaultInstanceForType?: Child
  childNodeIdBytes?: ByteString
  childNodeId?: string
  initializationErrorString?: string
  descriptorForType?: Descriptor
  allFields?: {
    [key: string]: { [key: string]: any }
  }
}

export interface ChildChainExecutableResponse {
  unknownFields?: UnknownFieldSet
  initialized?: boolean
  serializedSize?: number
  parserForType?: ParserChildChainExecutableResponse
  defaultInstanceForType?: ChildChainExecutableResponse
  nextChildId?: string
  nextChildIdBytes?: ByteString
  previousChildId?: string
  previousChildIdBytes?: ByteString
  passThroughData?: ByteString
  lastLink?: boolean
  suspend?: boolean
  initializationErrorString?: string
  descriptorForType?: Descriptor
  allFields?: {
    [key: string]: { [key: string]: any }
  }
}

export interface ChildChainExecutableResponseOrBuilder {
  nextChildId?: string
  nextChildIdBytes?: ByteString
  previousChildId?: string
  previousChildIdBytes?: ByteString
  passThroughData?: ByteString
  lastLink?: boolean
  suspend?: boolean
  unknownFields?: UnknownFieldSet
  defaultInstanceForType?: Message
  initializationErrorString?: string
  descriptorForType?: Descriptor
  allFields?: {
    [key: string]: { [key: string]: any }
  }
  initialized?: boolean
}

export interface ChildExecutableResponse {
  unknownFields?: UnknownFieldSet
  initialized?: boolean
  serializedSize?: number
  parserForType?: ParserChildExecutableResponse
  defaultInstanceForType?: ChildExecutableResponse
  childNodeIdBytes?: ByteString
  childNodeId?: string
  initializationErrorString?: string
  descriptorForType?: Descriptor
  allFields?: {
    [key: string]: { [key: string]: any }
  }
}

export interface ChildExecutableResponseOrBuilder {
  childNodeIdBytes?: ByteString
  childNodeId?: string
  unknownFields?: UnknownFieldSet
  defaultInstanceForType?: Message
  initializationErrorString?: string
  descriptorForType?: Descriptor
  allFields?: {
    [key: string]: { [key: string]: any }
  }
  initialized?: boolean
}

export interface ChildOrBuilder {
  childNodeIdBytes?: ByteString
  childNodeId?: string
  unknownFields?: UnknownFieldSet
  defaultInstanceForType?: Message
  initializationErrorString?: string
  descriptorForType?: Descriptor
  allFields?: {
    [key: string]: { [key: string]: any }
  }
  initialized?: boolean
}

export interface ChildrenExecutableResponse {
  unknownFields?: UnknownFieldSet
  initialized?: boolean
  serializedSize?: number
  parserForType?: ParserChildrenExecutableResponse
  defaultInstanceForType?: ChildrenExecutableResponse
  childrenCount?: number
  childrenList?: Child[]
  childrenOrBuilderList?: ChildOrBuilder[]
  initializationErrorString?: string
  descriptorForType?: Descriptor
  allFields?: {
    [key: string]: { [key: string]: any }
  }
}

export interface ChildrenExecutableResponseOrBuilder {
  childrenCount?: number
  childrenList?: Child[]
  childrenOrBuilderList?: ChildOrBuilder[]
  unknownFields?: UnknownFieldSet
  defaultInstanceForType?: Message
  initializationErrorString?: string
  descriptorForType?: Descriptor
  allFields?: {
    [key: string]: { [key: string]: any }
  }
  initialized?: boolean
}

export interface DelegateInfo {
  id?: string
  name?: string
  taskId?: string
  taskName?: string
}

export interface ExecutableResponse {
  unknownFields?: UnknownFieldSet
  task?: TaskExecutableResponse
  initialized?: boolean
  serializedSize?: number
  parserForType?: ParserExecutableResponse
  defaultInstanceForType?: ExecutableResponse
  async?: AsyncExecutableResponse
  responseCase?:
    | 'ASYNC'
    | 'CHILD'
    | 'CHILDREN'
    | 'CHILDCHAIN'
    | 'TASK'
    | 'TASKCHAIN'
    | 'SYNC'
    | 'SKIPTASK'
    | 'RESPONSE_NOT_SET'
  asyncOrBuilder?: AsyncExecutableResponseOrBuilder
  child?: ChildExecutableResponse
  childOrBuilder?: ChildExecutableResponseOrBuilder
  children?: ChildrenExecutableResponse
  childrenOrBuilder?: ChildrenExecutableResponseOrBuilder
  childChain?: ChildChainExecutableResponse
  childChainOrBuilder?: ChildChainExecutableResponseOrBuilder
  taskOrBuilder?: TaskExecutableResponseOrBuilder
  taskChain?: TaskChainExecutableResponse
  taskChainOrBuilder?: TaskChainExecutableResponseOrBuilder
  sync?: SyncExecutableResponse
  syncOrBuilder?: SyncExecutableResponseOrBuilder
  skipTask?: SkipTaskExecutableResponse
  skipTaskOrBuilder?: SkipTaskExecutableResponseOrBuilder
  initializationErrorString?: string
  descriptorForType?: Descriptor
  allFields?: {
    [key: string]: { [key: string]: any }
  }
}

export interface ExecutionGraph {
  rootNodeId?: string
  nodeMap?: {
    [key: string]: ExecutionNode
  }
  nodeAdjacencyListMap?: {
    [key: string]: ExecutionNodeAdjacencyList
  }
  representationStrategy?: 'camelCase'
}

export interface ExecutionNode {
  uuid?: string
  setupId?: string
  name?: string
  identifier?: string
  baseFqn?: string
  outcomes?: {
    [key: string]: { [key: string]: any }
  }[]
  stepParameters?: {
    [key: string]: { [key: string]: any }
  }
  startTs?: number
  endTs?: number
  stepType?: string
  status?:
    | 'Running'
    | 'Failed'
    | 'NotStarted'
    | 'Expired'
    | 'Aborted'
    | 'Queued'
    | 'Paused'
    | 'Waiting'
    | 'Success'
    | 'Suspended'
    | 'Skipped'
    | 'Pausing'
  failureInfo?: FailureInfoDTO
  skipInfo?: SkipInfo
  nodeRunInfo?: NodeRunInfo
  executableResponses?: ExecutableResponse[]
  taskIdToProgressDataMap?: {
    [key: string]: ProgressData[]
  }
  unitProgresses?: UnitProgress[]
  delegateInfoList?: DelegateInfo[]
  interruptHistories?: InterruptEffect[]
}

export interface ExecutionNodeAdjacencyList {
  children?: string[]
  nextIds?: string[]
}

export interface FailureInfoDTO {
  message?: string
  failureTypeList?: (
    | 'EXPIRED'
    | 'DELEGATE_PROVISIONING'
    | 'CONNECTIVITY'
    | 'AUTHENTICATION'
    | 'VERIFICATION_FAILURE'
    | 'APPLICATION_ERROR'
    | 'AUTHORIZATION_ERROR'
    | 'TIMEOUT_ERROR'
  )[]
  responseMessages?: ResponseMessage[]
}

export interface InterruptConfig {
  unknownFields?: UnknownFieldSet
  initialized?: boolean
  serializedSize?: number
  parserForType?: ParserInterruptConfig
  defaultInstanceForType?: InterruptConfig
  configCase?: 'RETRYINTERRUPTCONFIG' | 'CONFIG_NOT_SET'
  issuedBy?: IssuedBy
  issuedByOrBuilder?: IssuedByOrBuilder
  retryInterruptConfig?: RetryInterruptConfig
  retryInterruptConfigOrBuilder?: RetryInterruptConfigOrBuilder
  initializationErrorString?: string
  descriptorForType?: Descriptor
  allFields?: {
    [key: string]: { [key: string]: any }
  }
}

export interface InterruptEffect {
  interruptId: string
  tookEffectAt: number
  interruptType:
    | 'UNKNOWN'
    | 'ABORT'
    | 'ABORT_ALL'
    | 'PAUSE'
    | 'PAUSE_ALL'
    | 'RESUME'
    | 'RESUME_ALL'
    | 'RETRY'
    | 'IGNORE'
    | 'WAITING_FOR_MANUAL_INTERVENTION'
    | 'MARK_FAILED'
    | 'MARK_SUCCESS'
    | 'NEXT_STEP'
    | 'END_EXECUTION'
    | 'MARK_EXPIRED'
    | 'CUSTOM_FAILURE'
    | 'UNRECOGNIZED'
  interruptConfig: InterruptConfig
}

export interface IssuedBy {
  unknownFields?: UnknownFieldSet
  initialized?: boolean
  serializedSize?: number
  parserForType?: ParserIssuedBy
  defaultInstanceForType?: IssuedBy
  manualIssuer?: ManualIssuer
  manualIssuerOrBuilder?: ManualIssuerOrBuilder
  adviserIssuer?: AdviserIssuer
  adviserIssuerOrBuilder?: AdviserIssuerOrBuilder
  timeoutIssuer?: TimeoutIssuer
  timeoutIssuerOrBuilder?: TimeoutIssuerOrBuilder
  issuerCase?: 'MANUALISSUER' | 'ADVISERISSUER' | 'TIMEOUTISSUER' | 'ISSUER_NOT_SET'
  initializationErrorString?: string
  descriptorForType?: Descriptor
  allFields?: {
    [key: string]: { [key: string]: any }
  }
}

export interface IssuedByOrBuilder {
  manualIssuer?: ManualIssuer
  manualIssuerOrBuilder?: ManualIssuerOrBuilder
  adviserIssuer?: AdviserIssuer
  adviserIssuerOrBuilder?: AdviserIssuerOrBuilder
  timeoutIssuer?: TimeoutIssuer
  timeoutIssuerOrBuilder?: TimeoutIssuerOrBuilder
  issuerCase?: 'MANUALISSUER' | 'ADVISERISSUER' | 'TIMEOUTISSUER' | 'ISSUER_NOT_SET'
  unknownFields?: UnknownFieldSet
  defaultInstanceForType?: Message
  initializationErrorString?: string
  descriptorForType?: Descriptor
  allFields?: {
    [key: string]: { [key: string]: any }
  }
  initialized?: boolean
}

export interface ManualIssuer {
  unknownFields?: UnknownFieldSet
  initialized?: boolean
  serializedSize?: number
  parserForType?: ParserManualIssuer
  defaultInstanceForType?: ManualIssuer
  emailId?: string
  emailIdBytes?: ByteString
  userId?: string
  userIdBytes?: ByteString
  initializationErrorString?: string
  descriptorForType?: Descriptor
  allFields?: {
    [key: string]: { [key: string]: any }
  }
}

export interface ManualIssuerOrBuilder {
  emailId?: string
  emailIdBytes?: ByteString
  userId?: string
  userIdBytes?: ByteString
  unknownFields?: UnknownFieldSet
  defaultInstanceForType?: Message
  initializationErrorString?: string
  descriptorForType?: Descriptor
  allFields?: {
    [key: string]: { [key: string]: any }
  }
  initialized?: boolean
}

export interface ParserAdviserIssuer {
  [key: string]: any
}

export interface ParserAsyncExecutableResponse {
  [key: string]: any
}

export interface ParserChild {
  [key: string]: any
}

export interface ParserChildChainExecutableResponse {
  [key: string]: any
}

export interface ParserChildExecutableResponse {
  [key: string]: any
}

export interface ParserChildrenExecutableResponse {
  [key: string]: any
}

export interface ParserExecutableResponse {
  [key: string]: any
}

export interface ParserInterruptConfig {
  [key: string]: any
}

export interface ParserIssuedBy {
  [key: string]: any
}

export interface ParserManualIssuer {
  [key: string]: any
}

export interface ParserRetryInterruptConfig {
  [key: string]: any
}

export interface ParserSkipTaskExecutableResponse {
  [key: string]: any
}

export interface ParserSyncExecutableResponse {
  [key: string]: any
}

export interface ParserTaskChainExecutableResponse {
  [key: string]: any
}

export interface ParserTaskExecutableResponse {
  [key: string]: any
}

export interface ParserTimeoutIssuer {
  [key: string]: any
}

export interface ParserUnitProgress {
  [key: string]: any
}

export interface PipelineExecutionDetail {
  pipelineExecutionSummary?: PipelineExecutionSummary
  executionGraph?: ExecutionGraph
}

export interface ProgressData {
  [key: string]: any
}

export interface ResponsePipelineExecutionDetail {
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
  data?: PipelineExecutionDetail
  metaData?: { [key: string]: any }
  correlationId?: string
}

export interface RetryInterruptConfig {
  unknownFields?: UnknownFieldSet
  initialized?: boolean
  serializedSize?: number
  parserForType?: ParserRetryInterruptConfig
  defaultInstanceForType?: RetryInterruptConfig
  retryIdBytes?: ByteString
  retryId?: string
  initializationErrorString?: string
  descriptorForType?: Descriptor
  allFields?: {
    [key: string]: { [key: string]: any }
  }
}

export interface RetryInterruptConfigOrBuilder {
  retryIdBytes?: ByteString
  retryId?: string
  unknownFields?: UnknownFieldSet
  defaultInstanceForType?: Message
  initializationErrorString?: string
  descriptorForType?: Descriptor
  allFields?: {
    [key: string]: { [key: string]: any }
  }
  initialized?: boolean
}

export interface SkipTaskExecutableResponse {
  unknownFields?: UnknownFieldSet
  message?: string
  initialized?: boolean
  serializedSize?: number
  parserForType?: ParserSkipTaskExecutableResponse
  defaultInstanceForType?: SkipTaskExecutableResponse
  messageBytes?: ByteString
  initializationErrorString?: string
  descriptorForType?: Descriptor
  allFields?: {
    [key: string]: { [key: string]: any }
  }
}

export interface SkipTaskExecutableResponseOrBuilder {
  message?: string
  messageBytes?: ByteString
  unknownFields?: UnknownFieldSet
  defaultInstanceForType?: Message
  initializationErrorString?: string
  descriptorForType?: Descriptor
  allFields?: {
    [key: string]: { [key: string]: any }
  }
  initialized?: boolean
}

export interface SyncExecutableResponse {
  unknownFields?: UnknownFieldSet
  initialized?: boolean
  serializedSize?: number
  parserForType?: ParserSyncExecutableResponse
  defaultInstanceForType?: SyncExecutableResponse
  logKeysList?: string[]
  logKeysCount?: number
  unitsList?: string[]
  unitsCount?: number
  initializationErrorString?: string
  descriptorForType?: Descriptor
  allFields?: {
    [key: string]: { [key: string]: any }
  }
}

export interface SyncExecutableResponseOrBuilder {
  logKeysList?: string[]
  logKeysCount?: number
  unitsList?: string[]
  unitsCount?: number
  unknownFields?: UnknownFieldSet
  defaultInstanceForType?: Message
  initializationErrorString?: string
  descriptorForType?: Descriptor
  allFields?: {
    [key: string]: { [key: string]: any }
  }
  initialized?: boolean
}

export interface TaskChainExecutableResponse {
  unknownFields?: UnknownFieldSet
  initialized?: boolean
  serializedSize?: number
  parserForType?: ParserTaskChainExecutableResponse
  defaultInstanceForType?: TaskChainExecutableResponse
  taskId?: string
  taskName?: string
  logKeysList?: string[]
  logKeysCount?: number
  unitsList?: string[]
  unitsCount?: number
  taskCategoryValue?: number
  taskCategory?: 'UNKNOWN_CATEGORY' | 'DELEGATE_TASK_V1' | 'DELEGATE_TASK_V2' | 'UNRECOGNIZED'
  taskNameBytes?: ByteString
  chainEnd?: boolean
  passThroughData?: ByteString
  taskIdBytes?: ByteString
  initializationErrorString?: string
  descriptorForType?: Descriptor
  allFields?: {
    [key: string]: { [key: string]: any }
  }
}

export interface TaskChainExecutableResponseOrBuilder {
  taskId?: string
  taskName?: string
  logKeysList?: string[]
  logKeysCount?: number
  unitsList?: string[]
  unitsCount?: number
  taskCategoryValue?: number
  taskCategory?: 'UNKNOWN_CATEGORY' | 'DELEGATE_TASK_V1' | 'DELEGATE_TASK_V2' | 'UNRECOGNIZED'
  taskNameBytes?: ByteString
  chainEnd?: boolean
  passThroughData?: ByteString
  taskIdBytes?: ByteString
  unknownFields?: UnknownFieldSet
  defaultInstanceForType?: Message
  initializationErrorString?: string
  descriptorForType?: Descriptor
  allFields?: {
    [key: string]: { [key: string]: any }
  }
  initialized?: boolean
}

export interface TaskExecutableResponse {
  unknownFields?: UnknownFieldSet
  initialized?: boolean
  serializedSize?: number
  parserForType?: ParserTaskExecutableResponse
  defaultInstanceForType?: TaskExecutableResponse
  taskId?: string
  taskName?: string
  logKeysList?: string[]
  logKeysCount?: number
  unitsList?: string[]
  unitsCount?: number
  taskCategoryValue?: number
  taskCategory?: 'UNKNOWN_CATEGORY' | 'DELEGATE_TASK_V1' | 'DELEGATE_TASK_V2' | 'UNRECOGNIZED'
  taskNameBytes?: ByteString
  taskIdBytes?: ByteString
  initializationErrorString?: string
  descriptorForType?: Descriptor
  allFields?: {
    [key: string]: { [key: string]: any }
  }
}

export interface TaskExecutableResponseOrBuilder {
  taskId?: string
  taskName?: string
  logKeysList?: string[]
  logKeysCount?: number
  unitsList?: string[]
  unitsCount?: number
  taskCategoryValue?: number
  taskCategory?: 'UNKNOWN_CATEGORY' | 'DELEGATE_TASK_V1' | 'DELEGATE_TASK_V2' | 'UNRECOGNIZED'
  taskNameBytes?: ByteString
  taskIdBytes?: ByteString
  unknownFields?: UnknownFieldSet
  defaultInstanceForType?: Message
  initializationErrorString?: string
  descriptorForType?: Descriptor
  allFields?: {
    [key: string]: { [key: string]: any }
  }
  initialized?: boolean
}

export interface TimeoutIssuer {
  unknownFields?: UnknownFieldSet
  initialized?: boolean
  serializedSize?: number
  parserForType?: ParserTimeoutIssuer
  defaultInstanceForType?: TimeoutIssuer
  initializationErrorString?: string
  descriptorForType?: Descriptor
  allFields?: {
    [key: string]: { [key: string]: any }
  }
}

export interface TimeoutIssuerOrBuilder {
  unknownFields?: UnknownFieldSet
  defaultInstanceForType?: Message
  initializationErrorString?: string
  descriptorForType?: Descriptor
  allFields?: {
    [key: string]: { [key: string]: any }
  }
  initialized?: boolean
}

export interface UnitProgress {
  unknownFields?: UnknownFieldSet
  initialized?: boolean
  serializedSize?: number
  parserForType?: ParserUnitProgress
  defaultInstanceForType?: UnitProgress
  unitName?: string
  unitNameBytes?: ByteString
  statusValue?: number
  status?: 'UNKNOWN' | 'SUCCESS' | 'FAILURE' | 'RUNNING' | 'QUEUED' | 'SKIPPED' | 'EXPIRED' | 'UNRECOGNIZED'
  startTime?: number
  endTime?: number
  initializationErrorString?: string
  descriptorForType?: Descriptor
  allFields?: {
    [key: string]: { [key: string]: any }
  }
}

export interface JsonNode {
  array?: boolean
  null?: boolean
  object?: boolean
  valueNode?: boolean
  containerNode?: boolean
  missingNode?: boolean
  nodeType?: 'ARRAY' | 'BINARY' | 'BOOLEAN' | 'MISSING' | 'NULL' | 'NUMBER' | 'OBJECT' | 'POJO' | 'STRING'
  pojo?: boolean
  number?: boolean
  integralNumber?: boolean
  floatingPointNumber?: boolean
  short?: boolean
  int?: boolean
  long?: boolean
  float?: boolean
  double?: boolean
  bigDecimal?: boolean
  bigInteger?: boolean
  textual?: boolean
  boolean?: boolean
  binary?: boolean
}

export interface ResponseJsonNode {
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
  data?: JsonNode
  metaData?: { [key: string]: any }
  correlationId?: string
}

export interface NotificationChannelWrapper {
  type?: string
  spec?: PmsNotificationChannel
}

export interface NotificationRules {
  name?: string
  enabled?: boolean
  pipelineEvents?: PipelineEvent[]
  notificationMethod?: NotificationChannelWrapper
}

export interface PipelineEvent {
  type?:
    | 'AllEvents'
    | 'PipelineStart'
    | 'PipelineSuccess'
    | 'PipelineFailed'
    | 'PipelinePaused'
    | 'StageSuccess'
    | 'StageFailed'
    | 'StageStart'
    | 'StepFailed'
  forStages?: string[]
}

export type PmsEmailChannel = PmsNotificationChannel & {
  userGroups?: string[]
  recipients?: string[]
}

export type PmsMSTeamChannel = PmsNotificationChannel & {
  msTeamKeys?: string[]
  userGroups?: string[]
}

export interface PmsNotificationChannel {
  [key: string]: any
}

export type PmsPagerDutyChannel = PmsNotificationChannel & {
  userGroups?: string[]
  integrationKey?: string
}

export type PmsSlackChannel = PmsNotificationChannel & {
  userGroups?: string[]
  webhookUrl?: string
}

export interface ResponseNotificationRules {
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
  data?: NotificationRules
  metaData?: { [key: string]: any }
  correlationId?: string
}

export interface ResponseExecutionNode {
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
  data?: ExecutionNode
  metaData?: { [key: string]: any }
  correlationId?: string
}

export interface ResponseStepCategory {
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
  data?: StepCategory
  metaData?: { [key: string]: any }
  correlationId?: string
}

export interface StepCategory {
  name?: string
  stepsData?: StepData[]
  stepCategories?: StepCategory[]
}

export interface StepData {
  name?: string
  type?: string
}

export interface Commit {
  unknownFields?: UnknownFieldSet
  message?: string
  initialized?: boolean
  serializedSize?: number
  parserForType?: ParserCommit
  defaultInstanceForType?: Commit
  messageBytes?: ByteString
  link?: string
  sha?: string
  shaBytes?: ByteString
  linkBytes?: ByteString
  author?: Signature
  authorOrBuilder?: SignatureOrBuilder
  committer?: Signature
  committerOrBuilder?: SignatureOrBuilder
  initializationErrorString?: string
  descriptorForType?: Descriptor
  allFields?: {
    [key: string]: { [key: string]: any }
  }
}

export interface CommitOrBuilder {
  message?: string
  messageBytes?: ByteString
  link?: string
  sha?: string
  shaBytes?: ByteString
  linkBytes?: ByteString
  author?: Signature
  authorOrBuilder?: SignatureOrBuilder
  committer?: Signature
  committerOrBuilder?: SignatureOrBuilder
  unknownFields?: UnknownFieldSet
  defaultInstanceForType?: Message
  initializationErrorString?: string
  descriptorForType?: Descriptor
  allFields?: {
    [key: string]: { [key: string]: any }
  }
  initialized?: boolean
}

export interface ExecutionMetadata {
  unknownFields?: UnknownFieldSet
  principalInfo?: ExecutionPrincipalInfo
  initialized?: boolean
  serializedSize?: number
  parserForType?: ParserExecutionMetadata
  defaultInstanceForType?: ExecutionMetadata
  yaml?: string
  runSequence?: number
  triggerInfo?: ExecutionTriggerInfo
  triggerInfoOrBuilder?: ExecutionTriggerInfoOrBuilder
  triggerPayload?: TriggerPayload
  triggerPayloadOrBuilder?: TriggerPayloadOrBuilder
  pipelineIdentifier?: string
  pipelineIdentifierBytes?: ByteString
  inputSetYaml?: string
  inputSetYamlBytes?: ByteString
  executionUuid?: string
  executionUuidBytes?: ByteString
  yamlBytes?: ByteString
  principalInfoOrBuilder?: ExecutionPrincipalInfoOrBuilder
  processedYaml?: string
  processedYamlBytes?: ByteString
  initializationErrorString?: string
  descriptorForType?: Descriptor
  allFields?: {
    [key: string]: { [key: string]: any }
  }
}

export interface ExecutionPrincipalInfo {
  unknownFields?: UnknownFieldSet
  initialized?: boolean
  serializedSize?: number
  parserForType?: ParserExecutionPrincipalInfo
  defaultInstanceForType?: ExecutionPrincipalInfo
  principal?: string
  principalBytes?: ByteString
  principalTypeValue?: number
  principalType?: 'UNKNOWN' | 'USER' | 'USER_GROUP' | 'API_KEY' | 'SERVICE' | 'UNRECOGNIZED'
  initializationErrorString?: string
  descriptorForType?: Descriptor
  allFields?: {
    [key: string]: { [key: string]: any }
  }
}

export interface ExecutionPrincipalInfoOrBuilder {
  principal?: string
  principalBytes?: ByteString
  principalTypeValue?: number
  principalType?: 'UNKNOWN' | 'USER' | 'USER_GROUP' | 'API_KEY' | 'SERVICE' | 'UNRECOGNIZED'
  unknownFields?: UnknownFieldSet
  defaultInstanceForType?: Message
  initializationErrorString?: string
  descriptorForType?: Descriptor
  allFields?: {
    [key: string]: { [key: string]: any }
  }
  initialized?: boolean
}

export interface ExecutionTriggerInfoOrBuilder {
  triggerTypeValue?: number
  triggerType?: 'NOOP' | 'MANUAL' | 'WEBHOOK' | 'WEBHOOK_CUSTOM' | 'SCHEDULER_CRON' | 'UNRECOGNIZED'
  triggeredBy?: TriggeredBy
  triggeredByOrBuilder?: TriggeredByOrBuilder
  unknownFields?: UnknownFieldSet
  defaultInstanceForType?: Message
  initializationErrorString?: string
  descriptorForType?: Descriptor
  allFields?: {
    [key: string]: { [key: string]: any }
  }
  initialized?: boolean
}

export interface Label {
  unknownFields?: UnknownFieldSet
  name?: string
  initialized?: boolean
  serializedSize?: number
  parserForType?: ParserLabel
  defaultInstanceForType?: Label
  nameBytes?: ByteString
  colorBytes?: ByteString
  color?: string
  initializationErrorString?: string
  descriptorForType?: Descriptor
  allFields?: {
    [key: string]: { [key: string]: any }
  }
}

export interface LabelOrBuilder {
  name?: string
  nameBytes?: ByteString
  colorBytes?: ByteString
  color?: string
  unknownFields?: UnknownFieldSet
  defaultInstanceForType?: Message
  initializationErrorString?: string
  descriptorForType?: Descriptor
  allFields?: {
    [key: string]: { [key: string]: any }
  }
  initialized?: boolean
}

export interface ParsedPayload {
  unknownFields?: UnknownFieldSet
  initialized?: boolean
  serializedSize?: number
  parserForType?: ParserParsedPayload
  defaultInstanceForType?: ParsedPayload
  prOrBuilder?: PullRequestHookOrBuilder
  push?: PushHook
  pr?: PullRequestHook
  pushOrBuilder?: PushHookOrBuilder
  payloadCase?: 'PR' | 'PUSH' | 'PAYLOAD_NOT_SET'
  initializationErrorString?: string
  descriptorForType?: Descriptor
  allFields?: {
    [key: string]: { [key: string]: any }
  }
}

export interface ParsedPayloadOrBuilder {
  prOrBuilder?: PullRequestHookOrBuilder
  push?: PushHook
  pr?: PullRequestHook
  pushOrBuilder?: PushHookOrBuilder
  payloadCase?: 'PR' | 'PUSH' | 'PAYLOAD_NOT_SET'
  unknownFields?: UnknownFieldSet
  defaultInstanceForType?: Message
  initializationErrorString?: string
  descriptorForType?: Descriptor
  allFields?: {
    [key: string]: { [key: string]: any }
  }
  initialized?: boolean
}

export interface ParserCommit {
  [key: string]: any
}

export interface ParserExecutionMetadata {
  [key: string]: any
}

export interface ParserExecutionPrincipalInfo {
  [key: string]: any
}

export interface ParserLabel {
  [key: string]: any
}

export interface ParserParsedPayload {
  [key: string]: any
}

export interface ParserPerm {
  [key: string]: any
}

export interface ParserPullRequest {
  [key: string]: any
}

export interface ParserPullRequestHook {
  [key: string]: any
}

export interface ParserPushHook {
  [key: string]: any
}

export interface ParserReference {
  [key: string]: any
}

export interface ParserRepository {
  [key: string]: any
}

export interface ParserSignature {
  [key: string]: any
}

export interface ParserTimestamp {
  [key: string]: any
}

export interface ParserTriggerPayload {
  [key: string]: any
}

export interface ParserUser {
  [key: string]: any
}

export interface Perm {
  unknownFields?: UnknownFieldSet
  initialized?: boolean
  serializedSize?: number
  parserForType?: ParserPerm
  defaultInstanceForType?: Perm
  admin?: boolean
  pull?: boolean
  push?: boolean
  initializationErrorString?: string
  descriptorForType?: Descriptor
  allFields?: {
    [key: string]: { [key: string]: any }
  }
}

export interface PermOrBuilder {
  admin?: boolean
  pull?: boolean
  push?: boolean
  unknownFields?: UnknownFieldSet
  defaultInstanceForType?: Message
  initializationErrorString?: string
  descriptorForType?: Descriptor
  allFields?: {
    [key: string]: { [key: string]: any }
  }
  initialized?: boolean
}

export interface PlanExecution {
  uuid?: string
  createdAt?: number
  setupAbstractions?: {
    [key: string]: string
  }
  validUntil?: string
  status?:
    | 'NO_OP'
    | 'RUNNING'
    | 'INTERVENTION_WAITING'
    | 'TIMED_WAITING'
    | 'ASYNC_WAITING'
    | 'TASK_WAITING'
    | 'DISCONTINUING'
    | 'PAUSING'
    | 'QUEUED'
    | 'SKIPPED'
    | 'PAUSED'
    | 'ABORTED'
    | 'ERRORED'
    | 'FAILED'
    | 'EXPIRED'
    | 'SUSPENDED'
    | 'SUCCEEDED'
    | 'IGNORE_FAILED'
    | 'APPROVAL_WAITING'
    | 'RESOURCE_WAITING'
    | 'UNRECOGNIZED'
  startTs?: number
  endTs?: number
  metadata?: ExecutionMetadata
  lastUpdatedAt?: number
  version?: number
  nextIteration?: number
}

export interface PlanExecutionResponseDto {
  planExecution?: PlanExecution
}

export interface PullRequest {
  unknownFields?: UnknownFieldSet
  base?: Reference
  target?: string
  ref?: string
  number?: number
  created?: Timestamp
  initialized?: boolean
  serializedSize?: number
  parserForType?: ParserPullRequest
  defaultInstanceForType?: PullRequest
  title?: string
  source?: string
  head?: Reference
  link?: string
  bodyBytes?: ByteString
  sha?: string
  fork?: string
  titleBytes?: ByteString
  shaBytes?: ByteString
  sourceBytes?: ByteString
  targetBytes?: ByteString
  forkBytes?: ByteString
  linkBytes?: ByteString
  closed?: boolean
  merged?: boolean
  baseOrBuilder?: ReferenceOrBuilder
  headOrBuilder?: ReferenceOrBuilder
  author?: User
  authorOrBuilder?: UserOrBuilder
  createdOrBuilder?: TimestampOrBuilder
  updated?: Timestamp
  updatedOrBuilder?: TimestampOrBuilder
  labelsList?: Label[]
  labelsCount?: number
  labelsOrBuilderList?: LabelOrBuilder[]
  refBytes?: ByteString
  body?: string
  initializationErrorString?: string
  descriptorForType?: Descriptor
  allFields?: {
    [key: string]: { [key: string]: any }
  }
}

export interface PullRequestHook {
  unknownFields?: UnknownFieldSet
  action?:
    | 'UNKNOWN'
    | 'CREATE'
    | 'UPDATE'
    | 'DELETE'
    | 'OPEN'
    | 'REOPEN'
    | 'CLOSE'
    | 'LABEL'
    | 'UNLABEL'
    | 'SYNC'
    | 'MERGE'
    | 'UNRECOGNIZED'
  initialized?: boolean
  serializedSize?: number
  parserForType?: ParserPullRequestHook
  defaultInstanceForType?: PullRequestHook
  prOrBuilder?: PullRequestOrBuilder
  pr?: PullRequest
  repo?: Repository
  actionValue?: number
  repoOrBuilder?: RepositoryOrBuilder
  sender?: User
  senderOrBuilder?: UserOrBuilder
  initializationErrorString?: string
  descriptorForType?: Descriptor
  allFields?: {
    [key: string]: { [key: string]: any }
  }
}

export interface PullRequestHookOrBuilder {
  action?:
    | 'UNKNOWN'
    | 'CREATE'
    | 'UPDATE'
    | 'DELETE'
    | 'OPEN'
    | 'REOPEN'
    | 'CLOSE'
    | 'LABEL'
    | 'UNLABEL'
    | 'SYNC'
    | 'MERGE'
    | 'UNRECOGNIZED'
  prOrBuilder?: PullRequestOrBuilder
  pr?: PullRequest
  repo?: Repository
  actionValue?: number
  repoOrBuilder?: RepositoryOrBuilder
  sender?: User
  senderOrBuilder?: UserOrBuilder
  unknownFields?: UnknownFieldSet
  defaultInstanceForType?: Message
  initializationErrorString?: string
  descriptorForType?: Descriptor
  allFields?: {
    [key: string]: { [key: string]: any }
  }
  initialized?: boolean
}

export interface PullRequestOrBuilder {
  base?: Reference
  target?: string
  ref?: string
  number?: number
  created?: Timestamp
  title?: string
  source?: string
  head?: Reference
  link?: string
  bodyBytes?: ByteString
  sha?: string
  fork?: string
  titleBytes?: ByteString
  shaBytes?: ByteString
  sourceBytes?: ByteString
  targetBytes?: ByteString
  forkBytes?: ByteString
  linkBytes?: ByteString
  closed?: boolean
  merged?: boolean
  baseOrBuilder?: ReferenceOrBuilder
  headOrBuilder?: ReferenceOrBuilder
  author?: User
  authorOrBuilder?: UserOrBuilder
  createdOrBuilder?: TimestampOrBuilder
  updated?: Timestamp
  updatedOrBuilder?: TimestampOrBuilder
  labelsList?: Label[]
  labelsCount?: number
  labelsOrBuilderList?: LabelOrBuilder[]
  refBytes?: ByteString
  body?: string
  unknownFields?: UnknownFieldSet
  defaultInstanceForType?: Message
  initializationErrorString?: string
  descriptorForType?: Descriptor
  allFields?: {
    [key: string]: { [key: string]: any }
  }
  initialized?: boolean
}

export interface PushHook {
  unknownFields?: UnknownFieldSet
  ref?: string
  initialized?: boolean
  serializedSize?: number
  parserForType?: ParserPushHook
  defaultInstanceForType?: PushHook
  repo?: Repository
  after?: string
  repoOrBuilder?: RepositoryOrBuilder
  baseRef?: string
  baseRefBytes?: ByteString
  before?: string
  beforeBytes?: ByteString
  afterBytes?: ByteString
  commit?: Commit
  commitOrBuilder?: CommitOrBuilder
  commitsList?: Commit[]
  commitsCount?: number
  commitsOrBuilderList?: CommitOrBuilder[]
  sender?: User
  senderOrBuilder?: UserOrBuilder
  refBytes?: ByteString
  initializationErrorString?: string
  descriptorForType?: Descriptor
  allFields?: {
    [key: string]: { [key: string]: any }
  }
}

export interface PushHookOrBuilder {
  ref?: string
  repo?: Repository
  after?: string
  repoOrBuilder?: RepositoryOrBuilder
  baseRef?: string
  baseRefBytes?: ByteString
  before?: string
  beforeBytes?: ByteString
  afterBytes?: ByteString
  commit?: Commit
  commitOrBuilder?: CommitOrBuilder
  commitsList?: Commit[]
  commitsCount?: number
  commitsOrBuilderList?: CommitOrBuilder[]
  sender?: User
  senderOrBuilder?: UserOrBuilder
  refBytes?: ByteString
  unknownFields?: UnknownFieldSet
  defaultInstanceForType?: Message
  initializationErrorString?: string
  descriptorForType?: Descriptor
  allFields?: {
    [key: string]: { [key: string]: any }
  }
  initialized?: boolean
}

export interface Reference {
  unknownFields?: UnknownFieldSet
  name?: string
  path?: string
  initialized?: boolean
  serializedSize?: number
  parserForType?: ParserReference
  defaultInstanceForType?: Reference
  sha?: string
  nameBytes?: ByteString
  shaBytes?: ByteString
  pathBytes?: ByteString
  initializationErrorString?: string
  descriptorForType?: Descriptor
  allFields?: {
    [key: string]: { [key: string]: any }
  }
}

export interface ReferenceOrBuilder {
  name?: string
  path?: string
  sha?: string
  nameBytes?: ByteString
  shaBytes?: ByteString
  pathBytes?: ByteString
  unknownFields?: UnknownFieldSet
  defaultInstanceForType?: Message
  initializationErrorString?: string
  descriptorForType?: Descriptor
  allFields?: {
    [key: string]: { [key: string]: any }
  }
  initialized?: boolean
}

export interface Repository {
  unknownFields?: UnknownFieldSet
  name?: string
  id?: string
  created?: Timestamp
  branch?: string
  initialized?: boolean
  serializedSize?: number
  parserForType?: ParserRepository
  defaultInstanceForType?: Repository
  namespace?: string
  link?: string
  nameBytes?: ByteString
  linkBytes?: ByteString
  createdOrBuilder?: TimestampOrBuilder
  updated?: Timestamp
  updatedOrBuilder?: TimestampOrBuilder
  idBytes?: ByteString
  namespaceBytes?: ByteString
  perm?: Perm
  permOrBuilder?: PermOrBuilder
  branchBytes?: ByteString
  private?: boolean
  clone?: string
  cloneBytes?: ByteString
  cloneSsh?: string
  cloneSshBytes?: ByteString
  initializationErrorString?: string
  descriptorForType?: Descriptor
  allFields?: {
    [key: string]: { [key: string]: any }
  }
}

export interface RepositoryOrBuilder {
  name?: string
  id?: string
  created?: Timestamp
  branch?: string
  namespace?: string
  link?: string
  nameBytes?: ByteString
  linkBytes?: ByteString
  createdOrBuilder?: TimestampOrBuilder
  updated?: Timestamp
  updatedOrBuilder?: TimestampOrBuilder
  idBytes?: ByteString
  namespaceBytes?: ByteString
  perm?: Perm
  permOrBuilder?: PermOrBuilder
  branchBytes?: ByteString
  private?: boolean
  clone?: string
  cloneBytes?: ByteString
  cloneSsh?: string
  cloneSshBytes?: ByteString
  unknownFields?: UnknownFieldSet
  defaultInstanceForType?: Message
  initializationErrorString?: string
  descriptorForType?: Descriptor
  allFields?: {
    [key: string]: { [key: string]: any }
  }
  initialized?: boolean
}

export interface ResponsePlanExecutionResponseDto {
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
  data?: PlanExecutionResponseDto
  metaData?: { [key: string]: any }
  correlationId?: string
}

export interface Signature {
  unknownFields?: UnknownFieldSet
  name?: string
  initialized?: boolean
  serializedSize?: number
  parserForType?: ParserSignature
  defaultInstanceForType?: Signature
  date?: Timestamp
  email?: string
  nameBytes?: ByteString
  login?: string
  loginBytes?: ByteString
  emailBytes?: ByteString
  avatar?: string
  avatarBytes?: ByteString
  dateOrBuilder?: TimestampOrBuilder
  initializationErrorString?: string
  descriptorForType?: Descriptor
  allFields?: {
    [key: string]: { [key: string]: any }
  }
}

export interface SignatureOrBuilder {
  name?: string
  date?: Timestamp
  email?: string
  nameBytes?: ByteString
  login?: string
  loginBytes?: ByteString
  emailBytes?: ByteString
  avatar?: string
  avatarBytes?: ByteString
  dateOrBuilder?: TimestampOrBuilder
  unknownFields?: UnknownFieldSet
  defaultInstanceForType?: Message
  initializationErrorString?: string
  descriptorForType?: Descriptor
  allFields?: {
    [key: string]: { [key: string]: any }
  }
  initialized?: boolean
}

export interface Timestamp {
  unknownFields?: UnknownFieldSet
  initialized?: boolean
  serializedSize?: number
  parserForType?: ParserTimestamp
  defaultInstanceForType?: Timestamp
  nanos?: number
  seconds?: number
  initializationErrorString?: string
  descriptorForType?: Descriptor
  allFields?: {
    [key: string]: { [key: string]: any }
  }
}

export interface TimestampOrBuilder {
  nanos?: number
  seconds?: number
  unknownFields?: UnknownFieldSet
  defaultInstanceForType?: Message
  initializationErrorString?: string
  descriptorForType?: Descriptor
  allFields?: {
    [key: string]: { [key: string]: any }
  }
  initialized?: boolean
}

export interface TriggerPayload {
  unknownFields?: UnknownFieldSet
  type?: 'CUSTOM' | 'GIT' | 'SCHEDULED' | 'UNRECOGNIZED'
  initialized?: boolean
  serializedSize?: number
  parserForType?: ParserTriggerPayload
  defaultInstanceForType?: TriggerPayload
  jsonPayloadBytes?: ByteString
  jsonPayload?: string
  parsedPayload?: ParsedPayload
  parsedPayloadOrBuilder?: ParsedPayloadOrBuilder
  typeValue?: number
  initializationErrorString?: string
  descriptorForType?: Descriptor
  allFields?: {
    [key: string]: { [key: string]: any }
  }
}

export interface TriggerPayloadOrBuilder {
  type?: 'CUSTOM' | 'GIT' | 'SCHEDULED' | 'UNRECOGNIZED'
  jsonPayloadBytes?: ByteString
  jsonPayload?: string
  parsedPayload?: ParsedPayload
  parsedPayloadOrBuilder?: ParsedPayloadOrBuilder
  typeValue?: number
  unknownFields?: UnknownFieldSet
  defaultInstanceForType?: Message
  initializationErrorString?: string
  descriptorForType?: Descriptor
  allFields?: {
    [key: string]: { [key: string]: any }
  }
  initialized?: boolean
}

export interface User {
  unknownFields?: UnknownFieldSet
  name?: string
  created?: Timestamp
  initialized?: boolean
  serializedSize?: number
  parserForType?: ParserUser
  defaultInstanceForType?: User
  email?: string
  nameBytes?: ByteString
  createdOrBuilder?: TimestampOrBuilder
  updated?: Timestamp
  updatedOrBuilder?: TimestampOrBuilder
  login?: string
  loginBytes?: ByteString
  emailBytes?: ByteString
  avatar?: string
  avatarBytes?: ByteString
  initializationErrorString?: string
  descriptorForType?: Descriptor
  allFields?: {
    [key: string]: { [key: string]: any }
  }
}

export interface UserOrBuilder {
  name?: string
  created?: Timestamp
  email?: string
  nameBytes?: ByteString
  createdOrBuilder?: TimestampOrBuilder
  updated?: Timestamp
  updatedOrBuilder?: TimestampOrBuilder
  login?: string
  loginBytes?: ByteString
  emailBytes?: ByteString
  avatar?: string
  avatarBytes?: ByteString
  unknownFields?: UnknownFieldSet
  defaultInstanceForType?: Message
  initializationErrorString?: string
  descriptorForType?: Descriptor
  allFields?: {
    [key: string]: { [key: string]: any }
  }
  initialized?: boolean
}

export interface ResponsePipelineExecutionInterrupt {
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
  data?: PipelineExecutionInterrupt
  metaData?: { [key: string]: any }
  correlationId?: string
}

export interface PipelineExecutionInterrupt {
  id?: string
  type?: 'Abort' | 'Pause' | 'Resume' | 'Ignore' | 'StageRollback' | 'StepGroupRollback' | 'MarkAsSuccess' | 'Retry'
  planExecutionId?: string
}

export interface ConnectorCheckResponse {
  connectorIdentifier?: string
  errorInfo?: PreFlightEntityErrorInfo
  fqn?: string
  stageName?: string
  stageIdentifier?: string
  stepName?: string
  stepIdentifier?: string
  status?: 'SUCCESS' | 'FAILURE' | 'IN_PROGRESS'
}

export interface ConnectorWrapperResponse {
  checkResponses?: ConnectorCheckResponse[]
  status?: 'SUCCESS' | 'FAILURE' | 'IN_PROGRESS'
  label?: string
}

export interface PipelineInputResponse {
  errorInfo?: PreFlightEntityErrorInfo
  success?: boolean
  fqn?: string
  stageName?: string
  stepName?: string
}

export interface PipelineWrapperResponse {
  pipelineInputResponse?: PipelineInputResponse[]
  status?: 'SUCCESS' | 'FAILURE' | 'IN_PROGRESS'
  label?: string
}

export interface PreFlightCause {
  cause?: string
}

export interface PreFlightDTO {
  pipelineInputWrapperResponse?: PipelineWrapperResponse
  connectorWrapperResponse?: ConnectorWrapperResponse
  status?: 'SUCCESS' | 'FAILURE' | 'IN_PROGRESS'
  errorInfo?: PreFlightErrorInfo
}

export interface PreFlightEntityErrorInfo {
  summary?: string
  description?: string
  causes?: PreFlightCause[]
  resolution?: PreFlightResolution[]
}

export interface PreFlightErrorInfo {
  count?: number
  message?: string
}

export interface PreFlightResolution {
  resolution?: string
}

export interface ResponsePreFlightDTO {
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
  data?: PreFlightDTO
  metaData?: { [key: string]: any }
  correlationId?: string
}

export interface ResourceConstraintExecutionInfo {
  pipelineIdentifier?: string
  planExecutionId?: string
  state?: 'BLOCKED' | 'ACTIVE' | 'FINISHED' | 'REJECTED'
}

export interface ResponseListResourceConstraintExecutionInfo {
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
  data?: ResourceConstraintExecutionInfo[]
  metaData?: { [key: string]: any }
  correlationId?: string
}

export interface RestResponseVersionPackage {
  metaData?: {
    [key: string]: { [key: string]: any }
  }
  resource?: VersionPackage
  responseMessages?: ResponseMessage[]
}

export interface RuntimeInfo {
  primary?: boolean
  primaryVersion?: string
  deployMode?: string
}

export interface VersionInfo {
  version?: string
  buildNo?: string
  gitCommit?: string
  gitBranch?: string
  timestamp?: string
}

export interface VersionPackage {
  versionInfo?: VersionInfo
  runtimeInfo?: RuntimeInfo
}

export type FilterPropertiesRequestBody = FilterProperties

export type MergeInputSetRequestRequestBody = MergeInputSetRequest

export type NGTriggerConfigRequestBody = NGTriggerConfig

export type FilterDTORequestBody = FilterDTO

export interface GetFilterQueryParams {
  accountIdentifier?: string
  orgIdentifier?: string
  projectIdentifier?: string
  type: 'Connector' | 'PipelineSetup' | 'PipelineExecution' | 'Deployment' | 'Audit'
}

export interface GetFilterPathParams {
  identifier: string
}

export type GetFilterProps = Omit<
  GetProps<ResponseFilterDTO, Failure | Error, GetFilterQueryParams, GetFilterPathParams>,
  'path'
> &
  GetFilterPathParams

/**
 * Get Filter
 */
export const GetFilter = ({ identifier, ...props }: GetFilterProps) => (
  <Get<ResponseFilterDTO, Failure | Error, GetFilterQueryParams, GetFilterPathParams>
    path="/filters/${identifier}"
    base={getConfig('pipeline/api')}
    {...props}
  />
)

export type UseGetFilterProps = Omit<
  UseGetProps<ResponseFilterDTO, Failure | Error, GetFilterQueryParams, GetFilterPathParams>,
  'path'
> &
  GetFilterPathParams

/**
 * Get Filter
 */
export const useGetFilter = ({ identifier, ...props }: UseGetFilterProps) =>
  useGet<ResponseFilterDTO, Failure | Error, GetFilterQueryParams, GetFilterPathParams>(
    (paramsInPath: GetFilterPathParams) => `/filters/${paramsInPath.identifier}`,
    { base: getConfig('pipeline/api'), pathParams: { identifier }, ...props }
  )

/**
 * Get Filter
 */
export const getFilterPromise = (
  {
    identifier,
    ...props
  }: GetUsingFetchProps<ResponseFilterDTO, Failure | Error, GetFilterQueryParams, GetFilterPathParams> & {
    identifier: string
  },
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseFilterDTO, Failure | Error, GetFilterQueryParams, GetFilterPathParams>(
    getConfig('pipeline/api'),
    `/filters/${identifier}`,
    props,
    signal
  )

export interface DeleteFilterQueryParams {
  accountIdentifier?: string
  orgIdentifier?: string
  projectIdentifier?: string
  type: 'Connector' | 'PipelineSetup' | 'PipelineExecution' | 'Deployment' | 'Audit'
}

export type DeleteFilterProps = Omit<
  MutateProps<ResponseBoolean, Failure | Error, DeleteFilterQueryParams, string, void>,
  'path' | 'verb'
>

/**
 * Delete a filter
 */
export const DeleteFilter = (props: DeleteFilterProps) => (
  <Mutate<ResponseBoolean, Failure | Error, DeleteFilterQueryParams, string, void>
    verb="DELETE"
    path="/filters"
    base={getConfig('pipeline/api')}
    {...props}
  />
)

export type UseDeleteFilterProps = Omit<
  UseMutateProps<ResponseBoolean, Failure | Error, DeleteFilterQueryParams, string, void>,
  'path' | 'verb'
>

/**
 * Delete a filter
 */
export const useDeleteFilter = (props: UseDeleteFilterProps) =>
  useMutate<ResponseBoolean, Failure | Error, DeleteFilterQueryParams, string, void>('DELETE', `/filters`, {
    base: getConfig('pipeline/api'),
    ...props
  })

/**
 * Delete a filter
 */
export const deleteFilterPromise = (
  props: MutateUsingFetchProps<ResponseBoolean, Failure | Error, DeleteFilterQueryParams, string, void>,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<ResponseBoolean, Failure | Error, DeleteFilterQueryParams, string, void>(
    'DELETE',
    getConfig('pipeline/api'),
    `/filters`,
    props,
    signal
  )

export interface GetFilterListQueryParams {
  pageIndex?: number
  pageSize?: number
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
  type: 'Connector' | 'PipelineSetup' | 'PipelineExecution' | 'Deployment' | 'Audit'
}

export type GetFilterListProps = Omit<
  GetProps<ResponsePageFilterDTO, Failure | Error, GetFilterListQueryParams, void>,
  'path'
>

/**
 * Get Filter
 */
export const GetFilterList = (props: GetFilterListProps) => (
  <Get<ResponsePageFilterDTO, Failure | Error, GetFilterListQueryParams, void>
    path="/filters"
    base={getConfig('pipeline/api')}
    {...props}
  />
)

export type UseGetFilterListProps = Omit<
  UseGetProps<ResponsePageFilterDTO, Failure | Error, GetFilterListQueryParams, void>,
  'path'
>

/**
 * Get Filter
 */
export const useGetFilterList = (props: UseGetFilterListProps) =>
  useGet<ResponsePageFilterDTO, Failure | Error, GetFilterListQueryParams, void>(`/filters`, {
    base: getConfig('pipeline/api'),
    ...props
  })

/**
 * Get Filter
 */
export const getFilterListPromise = (
  props: GetUsingFetchProps<ResponsePageFilterDTO, Failure | Error, GetFilterListQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponsePageFilterDTO, Failure | Error, GetFilterListQueryParams, void>(
    getConfig('pipeline/api'),
    `/filters`,
    props,
    signal
  )

export interface PostFilterQueryParams {
  accountIdentifier: string
}

export type PostFilterProps = Omit<
  MutateProps<ResponseFilterDTO, Failure | Error, PostFilterQueryParams, FilterDTORequestBody, void>,
  'path' | 'verb'
>

/**
 * Create a Filter
 */
export const PostFilter = (props: PostFilterProps) => (
  <Mutate<ResponseFilterDTO, Failure | Error, PostFilterQueryParams, FilterDTORequestBody, void>
    verb="POST"
    path="/filters"
    base={getConfig('pipeline/api')}
    {...props}
  />
)

export type UsePostFilterProps = Omit<
  UseMutateProps<ResponseFilterDTO, Failure | Error, PostFilterQueryParams, FilterDTORequestBody, void>,
  'path' | 'verb'
>

/**
 * Create a Filter
 */
export const usePostFilter = (props: UsePostFilterProps) =>
  useMutate<ResponseFilterDTO, Failure | Error, PostFilterQueryParams, FilterDTORequestBody, void>('POST', `/filters`, {
    base: getConfig('pipeline/api'),
    ...props
  })

/**
 * Create a Filter
 */
export const postFilterPromise = (
  props: MutateUsingFetchProps<ResponseFilterDTO, Failure | Error, PostFilterQueryParams, FilterDTORequestBody, void>,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<ResponseFilterDTO, Failure | Error, PostFilterQueryParams, FilterDTORequestBody, void>(
    'POST',
    getConfig('pipeline/api'),
    `/filters`,
    props,
    signal
  )

export interface UpdateFilterQueryParams {
  accountIdentifier?: string
}

export type UpdateFilterProps = Omit<
  MutateProps<ResponseFilterDTO, Failure | Error, UpdateFilterQueryParams, FilterDTORequestBody, void>,
  'path' | 'verb'
>

/**
 * Update a Filter
 */
export const UpdateFilter = (props: UpdateFilterProps) => (
  <Mutate<ResponseFilterDTO, Failure | Error, UpdateFilterQueryParams, FilterDTORequestBody, void>
    verb="PUT"
    path="/filters"
    base={getConfig('pipeline/api')}
    {...props}
  />
)

export type UseUpdateFilterProps = Omit<
  UseMutateProps<ResponseFilterDTO, Failure | Error, UpdateFilterQueryParams, FilterDTORequestBody, void>,
  'path' | 'verb'
>

/**
 * Update a Filter
 */
export const useUpdateFilter = (props: UseUpdateFilterProps) =>
  useMutate<ResponseFilterDTO, Failure | Error, UpdateFilterQueryParams, FilterDTORequestBody, void>(
    'PUT',
    `/filters`,
    { base: getConfig('pipeline/api'), ...props }
  )

/**
 * Update a Filter
 */
export const updateFilterPromise = (
  props: MutateUsingFetchProps<ResponseFilterDTO, Failure | Error, UpdateFilterQueryParams, FilterDTORequestBody, void>,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<ResponseFilterDTO, Failure | Error, UpdateFilterQueryParams, FilterDTORequestBody, void>(
    'PUT',
    getConfig('pipeline/api'),
    `/filters`,
    props,
    signal
  )

export interface GetTriggerQueryParams {
  accountIdentifier: string
  orgIdentifier: string
  projectIdentifier: string
  targetIdentifier: string
}

export interface GetTriggerPathParams {
  triggerIdentifier: string
}

export type GetTriggerProps = Omit<
  GetProps<ResponseNGTriggerResponse, Failure | Error, GetTriggerQueryParams, GetTriggerPathParams>,
  'path'
> &
  GetTriggerPathParams

/**
 * Gets a trigger by identifier
 */
export const GetTrigger = ({ triggerIdentifier, ...props }: GetTriggerProps) => (
  <Get<ResponseNGTriggerResponse, Failure | Error, GetTriggerQueryParams, GetTriggerPathParams>
    path="/triggers/${triggerIdentifier}"
    base={getConfig('pipeline/api')}
    {...props}
  />
)

export type UseGetTriggerProps = Omit<
  UseGetProps<ResponseNGTriggerResponse, Failure | Error, GetTriggerQueryParams, GetTriggerPathParams>,
  'path'
> &
  GetTriggerPathParams

/**
 * Gets a trigger by identifier
 */
export const useGetTrigger = ({ triggerIdentifier, ...props }: UseGetTriggerProps) =>
  useGet<ResponseNGTriggerResponse, Failure | Error, GetTriggerQueryParams, GetTriggerPathParams>(
    (paramsInPath: GetTriggerPathParams) => `/triggers/${paramsInPath.triggerIdentifier}`,
    { base: getConfig('pipeline/api'), pathParams: { triggerIdentifier }, ...props }
  )

/**
 * Gets a trigger by identifier
 */
export const getTriggerPromise = (
  {
    triggerIdentifier,
    ...props
  }: GetUsingFetchProps<ResponseNGTriggerResponse, Failure | Error, GetTriggerQueryParams, GetTriggerPathParams> & {
    triggerIdentifier: string
  },
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseNGTriggerResponse, Failure | Error, GetTriggerQueryParams, GetTriggerPathParams>(
    getConfig('pipeline/api'),
    `/triggers/${triggerIdentifier}`,
    props,
    signal
  )

export interface UpdateTriggerQueryParams {
  accountIdentifier: string
  orgIdentifier: string
  projectIdentifier: string
}

export interface UpdateTriggerPathParams {
  triggerIdentifier: string
}

export type UpdateTriggerProps = Omit<
  MutateProps<
    ResponseNGTriggerResponse,
    Failure | Error,
    UpdateTriggerQueryParams,
    NGTriggerConfigRequestBody,
    UpdateTriggerPathParams
  >,
  'path' | 'verb'
> &
  UpdateTriggerPathParams

/**
 * Update a trigger by identifier
 */
export const UpdateTrigger = ({ triggerIdentifier, ...props }: UpdateTriggerProps) => (
  <Mutate<
    ResponseNGTriggerResponse,
    Failure | Error,
    UpdateTriggerQueryParams,
    NGTriggerConfigRequestBody,
    UpdateTriggerPathParams
  >
    verb="PUT"
    path="/triggers/${triggerIdentifier}"
    base={getConfig('pipeline/api')}
    {...props}
  />
)

export type UseUpdateTriggerProps = Omit<
  UseMutateProps<
    ResponseNGTriggerResponse,
    Failure | Error,
    UpdateTriggerQueryParams,
    NGTriggerConfigRequestBody,
    UpdateTriggerPathParams
  >,
  'path' | 'verb'
> &
  UpdateTriggerPathParams

/**
 * Update a trigger by identifier
 */
export const useUpdateTrigger = ({ triggerIdentifier, ...props }: UseUpdateTriggerProps) =>
  useMutate<
    ResponseNGTriggerResponse,
    Failure | Error,
    UpdateTriggerQueryParams,
    NGTriggerConfigRequestBody,
    UpdateTriggerPathParams
  >('PUT', (paramsInPath: UpdateTriggerPathParams) => `/triggers/${paramsInPath.triggerIdentifier}`, {
    base: getConfig('pipeline/api'),
    pathParams: { triggerIdentifier },
    ...props
  })

/**
 * Update a trigger by identifier
 */
export const updateTriggerPromise = (
  {
    triggerIdentifier,
    ...props
  }: MutateUsingFetchProps<
    ResponseNGTriggerResponse,
    Failure | Error,
    UpdateTriggerQueryParams,
    NGTriggerConfigRequestBody,
    UpdateTriggerPathParams
  > & { triggerIdentifier: string },
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseNGTriggerResponse,
    Failure | Error,
    UpdateTriggerQueryParams,
    NGTriggerConfigRequestBody,
    UpdateTriggerPathParams
  >('PUT', getConfig('pipeline/api'), `/triggers/${triggerIdentifier}`, props, signal)

export interface DeleteTriggerQueryParams {
  accountIdentifier: string
  orgIdentifier: string
  projectIdentifier: string
  targetIdentifier: string
}

export type DeleteTriggerProps = Omit<
  MutateProps<ResponseBoolean, Failure | Error, DeleteTriggerQueryParams, string, void>,
  'path' | 'verb'
>

/**
 * Delete a trigger by identifier
 */
export const DeleteTrigger = (props: DeleteTriggerProps) => (
  <Mutate<ResponseBoolean, Failure | Error, DeleteTriggerQueryParams, string, void>
    verb="DELETE"
    path="/triggers"
    base={getConfig('pipeline/api')}
    {...props}
  />
)

export type UseDeleteTriggerProps = Omit<
  UseMutateProps<ResponseBoolean, Failure | Error, DeleteTriggerQueryParams, string, void>,
  'path' | 'verb'
>

/**
 * Delete a trigger by identifier
 */
export const useDeleteTrigger = (props: UseDeleteTriggerProps) =>
  useMutate<ResponseBoolean, Failure | Error, DeleteTriggerQueryParams, string, void>('DELETE', `/triggers`, {
    base: getConfig('pipeline/api'),
    ...props
  })

/**
 * Delete a trigger by identifier
 */
export const deleteTriggerPromise = (
  props: MutateUsingFetchProps<ResponseBoolean, Failure | Error, DeleteTriggerQueryParams, string, void>,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<ResponseBoolean, Failure | Error, DeleteTriggerQueryParams, string, void>(
    'DELETE',
    getConfig('pipeline/api'),
    `/triggers`,
    props,
    signal
  )

export interface GetTriggerListForTargetQueryParams {
  accountIdentifier: string
  orgIdentifier: string
  projectIdentifier: string
  targetIdentifier: string
  filter?: string
  page?: number
  size?: number
  sort?: string[]
  searchTerm?: string
}

export type GetTriggerListForTargetProps = Omit<
  GetProps<ResponsePageNGTriggerDetailsResponse, Failure | Error, GetTriggerListForTargetQueryParams, void>,
  'path'
>

/**
 * Gets Triggers list for target
 */
export const GetTriggerListForTarget = (props: GetTriggerListForTargetProps) => (
  <Get<ResponsePageNGTriggerDetailsResponse, Failure | Error, GetTriggerListForTargetQueryParams, void>
    path="/triggers"
    base={getConfig('pipeline/api')}
    {...props}
  />
)

export type UseGetTriggerListForTargetProps = Omit<
  UseGetProps<ResponsePageNGTriggerDetailsResponse, Failure | Error, GetTriggerListForTargetQueryParams, void>,
  'path'
>

/**
 * Gets Triggers list for target
 */
export const useGetTriggerListForTarget = (props: UseGetTriggerListForTargetProps) =>
  useGet<ResponsePageNGTriggerDetailsResponse, Failure | Error, GetTriggerListForTargetQueryParams, void>(`/triggers`, {
    base: getConfig('pipeline/api'),
    ...props
  })

/**
 * Gets Triggers list for target
 */
export const getTriggerListForTargetPromise = (
  props: GetUsingFetchProps<
    ResponsePageNGTriggerDetailsResponse,
    Failure | Error,
    GetTriggerListForTargetQueryParams,
    void
  >,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponsePageNGTriggerDetailsResponse, Failure | Error, GetTriggerListForTargetQueryParams, void>(
    getConfig('pipeline/api'),
    `/triggers`,
    props,
    signal
  )

export interface CreateTriggerQueryParams {
  accountIdentifier: string
  orgIdentifier: string
  projectIdentifier: string
}

export type CreateTriggerProps = Omit<
  MutateProps<ResponseNGTriggerResponse, Failure | Error, CreateTriggerQueryParams, NGTriggerConfigRequestBody, void>,
  'path' | 'verb'
>

/**
 * Create Trigger
 */
export const CreateTrigger = (props: CreateTriggerProps) => (
  <Mutate<ResponseNGTriggerResponse, Failure | Error, CreateTriggerQueryParams, NGTriggerConfigRequestBody, void>
    verb="POST"
    path="/triggers"
    base={getConfig('pipeline/api')}
    {...props}
  />
)

export type UseCreateTriggerProps = Omit<
  UseMutateProps<
    ResponseNGTriggerResponse,
    Failure | Error,
    CreateTriggerQueryParams,
    NGTriggerConfigRequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Create Trigger
 */
export const useCreateTrigger = (props: UseCreateTriggerProps) =>
  useMutate<ResponseNGTriggerResponse, Failure | Error, CreateTriggerQueryParams, NGTriggerConfigRequestBody, void>(
    'POST',
    `/triggers`,
    { base: getConfig('pipeline/api'), ...props }
  )

/**
 * Create Trigger
 */
export const createTriggerPromise = (
  props: MutateUsingFetchProps<
    ResponseNGTriggerResponse,
    Failure | Error,
    CreateTriggerQueryParams,
    NGTriggerConfigRequestBody,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseNGTriggerResponse,
    Failure | Error,
    CreateTriggerQueryParams,
    NGTriggerConfigRequestBody,
    void
  >('POST', getConfig('pipeline/api'), `/triggers`, props, signal)

export interface GetTriggerDetailsQueryParams {
  accountIdentifier: string
  orgIdentifier: string
  projectIdentifier: string
  targetIdentifier: string
}

export interface GetTriggerDetailsPathParams {
  triggerIdentifier: string
}

export type GetTriggerDetailsProps = Omit<
  GetProps<
    ResponseNGTriggerDetailsResponse,
    Failure | Error,
    GetTriggerDetailsQueryParams,
    GetTriggerDetailsPathParams
  >,
  'path'
> &
  GetTriggerDetailsPathParams

/**
 * Gets Triggers list for target
 */
export const GetTriggerDetails = ({ triggerIdentifier, ...props }: GetTriggerDetailsProps) => (
  <Get<ResponseNGTriggerDetailsResponse, Failure | Error, GetTriggerDetailsQueryParams, GetTriggerDetailsPathParams>
    path="/triggers/${triggerIdentifier}/details"
    base={getConfig('pipeline/api')}
    {...props}
  />
)

export type UseGetTriggerDetailsProps = Omit<
  UseGetProps<
    ResponseNGTriggerDetailsResponse,
    Failure | Error,
    GetTriggerDetailsQueryParams,
    GetTriggerDetailsPathParams
  >,
  'path'
> &
  GetTriggerDetailsPathParams

/**
 * Gets Triggers list for target
 */
export const useGetTriggerDetails = ({ triggerIdentifier, ...props }: UseGetTriggerDetailsProps) =>
  useGet<ResponseNGTriggerDetailsResponse, Failure | Error, GetTriggerDetailsQueryParams, GetTriggerDetailsPathParams>(
    (paramsInPath: GetTriggerDetailsPathParams) => `/triggers/${paramsInPath.triggerIdentifier}/details`,
    { base: getConfig('pipeline/api'), pathParams: { triggerIdentifier }, ...props }
  )

/**
 * Gets Triggers list for target
 */
export const getTriggerDetailsPromise = (
  {
    triggerIdentifier,
    ...props
  }: GetUsingFetchProps<
    ResponseNGTriggerDetailsResponse,
    Failure | Error,
    GetTriggerDetailsQueryParams,
    GetTriggerDetailsPathParams
  > & { triggerIdentifier: string },
  signal?: RequestInit['signal']
) =>
  getUsingFetch<
    ResponseNGTriggerDetailsResponse,
    Failure | Error,
    GetTriggerDetailsQueryParams,
    GetTriggerDetailsPathParams
  >(getConfig('pipeline/api'), `/triggers/${triggerIdentifier}/details`, props, signal)

export interface GetTriggerListForRepoURLQueryParams {
  repoURL: string
  filter?: string
  page?: number
  size?: number
  sort?: string[]
  searchTerm?: string
}

export type GetTriggerListForRepoURLProps = Omit<
  GetProps<ResponsePageNGTriggerResponse, Failure | Error, GetTriggerListForRepoURLQueryParams, void>,
  'path'
>

/**
 * Gets Triggers list for Repo URL
 */
export const GetTriggerListForRepoURL = (props: GetTriggerListForRepoURLProps) => (
  <Get<ResponsePageNGTriggerResponse, Failure | Error, GetTriggerListForRepoURLQueryParams, void>
    path="/triggers/triggersList"
    base={getConfig('pipeline/api')}
    {...props}
  />
)

export type UseGetTriggerListForRepoURLProps = Omit<
  UseGetProps<ResponsePageNGTriggerResponse, Failure | Error, GetTriggerListForRepoURLQueryParams, void>,
  'path'
>

/**
 * Gets Triggers list for Repo URL
 */
export const useGetTriggerListForRepoURL = (props: UseGetTriggerListForRepoURLProps) =>
  useGet<ResponsePageNGTriggerResponse, Failure | Error, GetTriggerListForRepoURLQueryParams, void>(
    `/triggers/triggersList`,
    { base: getConfig('pipeline/api'), ...props }
  )

/**
 * Gets Triggers list for Repo URL
 */
export const getTriggerListForRepoURLPromise = (
  props: GetUsingFetchProps<ResponsePageNGTriggerResponse, Failure | Error, GetTriggerListForRepoURLQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponsePageNGTriggerResponse, Failure | Error, GetTriggerListForRepoURLQueryParams, void>(
    getConfig('pipeline/api'),
    `/triggers/triggersList`,
    props,
    signal
  )

export type GenerateWebhookTokenProps = Omit<GetProps<RestResponseString, Failure | Error, void, void>, 'path'>

/**
 * Regenerate webhook token
 */
export const GenerateWebhookToken = (props: GenerateWebhookTokenProps) => (
  <Get<RestResponseString, Failure | Error, void, void>
    path="/triggers/regenerateToken"
    base={getConfig('pipeline/api')}
    {...props}
  />
)

export type UseGenerateWebhookTokenProps = Omit<UseGetProps<RestResponseString, Failure | Error, void, void>, 'path'>

/**
 * Regenerate webhook token
 */
export const useGenerateWebhookToken = (props: UseGenerateWebhookTokenProps) =>
  useGet<RestResponseString, Failure | Error, void, void>(`/triggers/regenerateToken`, {
    base: getConfig('pipeline/api'),
    ...props
  })

/**
 * Regenerate webhook token
 */
export const generateWebhookTokenPromise = (
  props: GetUsingFetchProps<RestResponseString, Failure | Error, void, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<RestResponseString, Failure | Error, void, void>(
    getConfig('pipeline/api'),
    `/triggers/regenerateToken`,
    props,
    signal
  )

export interface UpdateTriggerStatusQueryParams {
  accountIdentifier: string
  orgIdentifier: string
  projectIdentifier: string
  targetIdentifier: string
  status: boolean
}

export interface UpdateTriggerStatusPathParams {
  triggerIdentifier: string
}

export type UpdateTriggerStatusProps = Omit<
  MutateProps<ResponseBoolean, Failure | Error, UpdateTriggerStatusQueryParams, void, UpdateTriggerStatusPathParams>,
  'path' | 'verb'
> &
  UpdateTriggerStatusPathParams

/**
 * Update a trigger's status by identifier
 */
export const UpdateTriggerStatus = ({ triggerIdentifier, ...props }: UpdateTriggerStatusProps) => (
  <Mutate<ResponseBoolean, Failure | Error, UpdateTriggerStatusQueryParams, void, UpdateTriggerStatusPathParams>
    verb="PUT"
    path="/triggers/${triggerIdentifier}/status"
    base={getConfig('pipeline/api')}
    {...props}
  />
)

export type UseUpdateTriggerStatusProps = Omit<
  UseMutateProps<ResponseBoolean, Failure | Error, UpdateTriggerStatusQueryParams, void, UpdateTriggerStatusPathParams>,
  'path' | 'verb'
> &
  UpdateTriggerStatusPathParams

/**
 * Update a trigger's status by identifier
 */
export const useUpdateTriggerStatus = ({ triggerIdentifier, ...props }: UseUpdateTriggerStatusProps) =>
  useMutate<ResponseBoolean, Failure | Error, UpdateTriggerStatusQueryParams, void, UpdateTriggerStatusPathParams>(
    'PUT',
    (paramsInPath: UpdateTriggerStatusPathParams) => `/triggers/${paramsInPath.triggerIdentifier}/status`,
    { base: getConfig('pipeline/api'), pathParams: { triggerIdentifier }, ...props }
  )

/**
 * Update a trigger's status by identifier
 */
export const updateTriggerStatusPromise = (
  {
    triggerIdentifier,
    ...props
  }: MutateUsingFetchProps<
    ResponseBoolean,
    Failure | Error,
    UpdateTriggerStatusQueryParams,
    void,
    UpdateTriggerStatusPathParams
  > & { triggerIdentifier: string },
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseBoolean,
    Failure | Error,
    UpdateTriggerStatusQueryParams,
    void,
    UpdateTriggerStatusPathParams
  >('PUT', getConfig('pipeline/api'), `/triggers/${triggerIdentifier}/status`, props, signal)

export type GetSourceRepoToEventProps = Omit<
  GetProps<ResponseMapWebhookSourceRepoListWebhookEvent, Failure | Error, void, void>,
  'path'
>

/**
 * Get Source Repo types with Events
 */
export const GetSourceRepoToEvent = (props: GetSourceRepoToEventProps) => (
  <Get<ResponseMapWebhookSourceRepoListWebhookEvent, Failure | Error, void, void>
    path="/webhook/sourceRepos"
    base={getConfig('pipeline/api')}
    {...props}
  />
)

export type UseGetSourceRepoToEventProps = Omit<
  UseGetProps<ResponseMapWebhookSourceRepoListWebhookEvent, Failure | Error, void, void>,
  'path'
>

/**
 * Get Source Repo types with Events
 */
export const useGetSourceRepoToEvent = (props: UseGetSourceRepoToEventProps) =>
  useGet<ResponseMapWebhookSourceRepoListWebhookEvent, Failure | Error, void, void>(`/webhook/sourceRepos`, {
    base: getConfig('pipeline/api'),
    ...props
  })

/**
 * Get Source Repo types with Events
 */
export const getSourceRepoToEventPromise = (
  props: GetUsingFetchProps<ResponseMapWebhookSourceRepoListWebhookEvent, Failure | Error, void, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseMapWebhookSourceRepoListWebhookEvent, Failure | Error, void, void>(
    getConfig('pipeline/api'),
    `/webhook/sourceRepos`,
    props,
    signal
  )

export interface GetActionsListQueryParams {
  sourceRepo: 'GITHUB' | 'GITLAB' | 'BITBUCKET' | 'AWS_CODECOMMIT' | 'CUSTOM'
  event: string
}

export type GetActionsListProps = Omit<
  GetProps<ResponseListWebhookAction, Failure | Error, GetActionsListQueryParams, void>,
  'path'
>

/**
 * Get Actions for event type and source
 */
export const GetActionsList = (props: GetActionsListProps) => (
  <Get<ResponseListWebhookAction, Failure | Error, GetActionsListQueryParams, void>
    path="/webhook/actions"
    base={getConfig('pipeline/api')}
    {...props}
  />
)

export type UseGetActionsListProps = Omit<
  UseGetProps<ResponseListWebhookAction, Failure | Error, GetActionsListQueryParams, void>,
  'path'
>

/**
 * Get Actions for event type and source
 */
export const useGetActionsList = (props: UseGetActionsListProps) =>
  useGet<ResponseListWebhookAction, Failure | Error, GetActionsListQueryParams, void>(`/webhook/actions`, {
    base: getConfig('pipeline/api'),
    ...props
  })

/**
 * Get Actions for event type and source
 */
export const getActionsListPromise = (
  props: GetUsingFetchProps<ResponseListWebhookAction, Failure | Error, GetActionsListQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseListWebhookAction, Failure | Error, GetActionsListQueryParams, void>(
    getConfig('pipeline/api'),
    `/webhook/actions`,
    props,
    signal
  )

export interface WebhookEndpointQueryParams {
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
}

export type WebhookEndpointProps = Omit<
  MutateProps<ResponseString, Failure | Error, WebhookEndpointQueryParams, string, void>,
  'path' | 'verb'
>

/**
 * accept webhook event
 */
export const WebhookEndpoint = (props: WebhookEndpointProps) => (
  <Mutate<ResponseString, Failure | Error, WebhookEndpointQueryParams, string, void>
    verb="POST"
    path="/webhook/trigger"
    base={getConfig('pipeline/api')}
    {...props}
  />
)

export type UseWebhookEndpointProps = Omit<
  UseMutateProps<ResponseString, Failure | Error, WebhookEndpointQueryParams, string, void>,
  'path' | 'verb'
>

/**
 * accept webhook event
 */
export const useWebhookEndpoint = (props: UseWebhookEndpointProps) =>
  useMutate<ResponseString, Failure | Error, WebhookEndpointQueryParams, string, void>('POST', `/webhook/trigger`, {
    base: getConfig('pipeline/api'),
    ...props
  })

/**
 * accept webhook event
 */
export const webhookEndpointPromise = (
  props: MutateUsingFetchProps<ResponseString, Failure | Error, WebhookEndpointQueryParams, string, void>,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<ResponseString, Failure | Error, WebhookEndpointQueryParams, string, void>(
    'POST',
    getConfig('pipeline/api'),
    `/webhook/trigger`,
    props,
    signal
  )

export interface GetApprovalInstancePathParams {
  approvalInstanceId: string
}

export type GetApprovalInstanceProps = Omit<
  GetProps<ResponseApprovalInstanceResponse, Failure | Error, void, GetApprovalInstancePathParams>,
  'path'
> &
  GetApprovalInstancePathParams

/**
 * Gets an approval instance by id
 */
export const GetApprovalInstance = ({ approvalInstanceId, ...props }: GetApprovalInstanceProps) => (
  <Get<ResponseApprovalInstanceResponse, Failure | Error, void, GetApprovalInstancePathParams>
    path="/approvals/${approvalInstanceId}"
    base={getConfig('pipeline/api')}
    {...props}
  />
)

export type UseGetApprovalInstanceProps = Omit<
  UseGetProps<ResponseApprovalInstanceResponse, Failure | Error, void, GetApprovalInstancePathParams>,
  'path'
> &
  GetApprovalInstancePathParams

/**
 * Gets an approval instance by id
 */
export const useGetApprovalInstance = ({ approvalInstanceId, ...props }: UseGetApprovalInstanceProps) =>
  useGet<ResponseApprovalInstanceResponse, Failure | Error, void, GetApprovalInstancePathParams>(
    (paramsInPath: GetApprovalInstancePathParams) => `/approvals/${paramsInPath.approvalInstanceId}`,
    { base: getConfig('pipeline/api'), pathParams: { approvalInstanceId }, ...props }
  )

/**
 * Gets an approval instance by id
 */
export const getApprovalInstancePromise = (
  {
    approvalInstanceId,
    ...props
  }: GetUsingFetchProps<ResponseApprovalInstanceResponse, Failure | Error, void, GetApprovalInstancePathParams> & {
    approvalInstanceId: string
  },
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseApprovalInstanceResponse, Failure | Error, void, GetApprovalInstancePathParams>(
    getConfig('pipeline/api'),
    `/approvals/${approvalInstanceId}`,
    props,
    signal
  )

export interface GetInitialStageYamlSnippetQueryParams {
  approvalType: 'HarnessApproval' | 'JiraApproval'
}

export type GetInitialStageYamlSnippetProps = Omit<
  GetProps<ResponseString, Failure | Error, GetInitialStageYamlSnippetQueryParams, void>,
  'path'
>

/**
 * Gets the initial yaml snippet for approval stage
 */
export const GetInitialStageYamlSnippet = (props: GetInitialStageYamlSnippetProps) => (
  <Get<ResponseString, Failure | Error, GetInitialStageYamlSnippetQueryParams, void>
    path="/approvals/stage-yaml-snippet"
    base={getConfig('pipeline/api')}
    {...props}
  />
)

export type UseGetInitialStageYamlSnippetProps = Omit<
  UseGetProps<ResponseString, Failure | Error, GetInitialStageYamlSnippetQueryParams, void>,
  'path'
>

/**
 * Gets the initial yaml snippet for approval stage
 */
export const useGetInitialStageYamlSnippet = (props: UseGetInitialStageYamlSnippetProps) =>
  useGet<ResponseString, Failure | Error, GetInitialStageYamlSnippetQueryParams, void>(
    `/approvals/stage-yaml-snippet`,
    { base: getConfig('pipeline/api'), ...props }
  )

/**
 * Gets the initial yaml snippet for approval stage
 */
export const getInitialStageYamlSnippetPromise = (
  props: GetUsingFetchProps<ResponseString, Failure | Error, GetInitialStageYamlSnippetQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseString, Failure | Error, GetInitialStageYamlSnippetQueryParams, void>(
    getConfig('pipeline/api'),
    `/approvals/stage-yaml-snippet`,
    props,
    signal
  )

export interface AddHarnessApprovalActivityPathParams {
  approvalInstanceId: string
}

export type AddHarnessApprovalActivityProps = Omit<
  MutateProps<
    ResponseApprovalInstanceResponse,
    Failure | Error,
    void,
    HarnessApprovalActivityRequest,
    AddHarnessApprovalActivityPathParams
  >,
  'path' | 'verb'
> &
  AddHarnessApprovalActivityPathParams

/**
 * Add a new Harness approval activity
 */
export const AddHarnessApprovalActivity = ({ approvalInstanceId, ...props }: AddHarnessApprovalActivityProps) => (
  <Mutate<
    ResponseApprovalInstanceResponse,
    Failure | Error,
    void,
    HarnessApprovalActivityRequest,
    AddHarnessApprovalActivityPathParams
  >
    verb="POST"
    path="/approvals/${approvalInstanceId}/harness/activity"
    base={getConfig('pipeline/api')}
    {...props}
  />
)

export type UseAddHarnessApprovalActivityProps = Omit<
  UseMutateProps<
    ResponseApprovalInstanceResponse,
    Failure | Error,
    void,
    HarnessApprovalActivityRequest,
    AddHarnessApprovalActivityPathParams
  >,
  'path' | 'verb'
> &
  AddHarnessApprovalActivityPathParams

/**
 * Add a new Harness approval activity
 */
export const useAddHarnessApprovalActivity = ({ approvalInstanceId, ...props }: UseAddHarnessApprovalActivityProps) =>
  useMutate<
    ResponseApprovalInstanceResponse,
    Failure | Error,
    void,
    HarnessApprovalActivityRequest,
    AddHarnessApprovalActivityPathParams
  >(
    'POST',
    (paramsInPath: AddHarnessApprovalActivityPathParams) =>
      `/approvals/${paramsInPath.approvalInstanceId}/harness/activity`,
    { base: getConfig('pipeline/api'), pathParams: { approvalInstanceId }, ...props }
  )

/**
 * Add a new Harness approval activity
 */
export const addHarnessApprovalActivityPromise = (
  {
    approvalInstanceId,
    ...props
  }: MutateUsingFetchProps<
    ResponseApprovalInstanceResponse,
    Failure | Error,
    void,
    HarnessApprovalActivityRequest,
    AddHarnessApprovalActivityPathParams
  > & { approvalInstanceId: string },
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseApprovalInstanceResponse,
    Failure | Error,
    void,
    HarnessApprovalActivityRequest,
    AddHarnessApprovalActivityPathParams
  >('POST', getConfig('pipeline/api'), `/approvals/${approvalInstanceId}/harness/activity`, props, signal)

export interface GetHarnessApprovalInstanceAuthorizationPathParams {
  approvalInstanceId: string
}

export type GetHarnessApprovalInstanceAuthorizationProps = Omit<
  GetProps<
    ResponseHarnessApprovalInstanceAuthorization,
    Failure | Error,
    void,
    GetHarnessApprovalInstanceAuthorizationPathParams
  >,
  'path'
> &
  GetHarnessApprovalInstanceAuthorizationPathParams

/**
 * Gets a Harness approval instance authorization for the current user
 */
export const GetHarnessApprovalInstanceAuthorization = ({
  approvalInstanceId,
  ...props
}: GetHarnessApprovalInstanceAuthorizationProps) => (
  <Get<
    ResponseHarnessApprovalInstanceAuthorization,
    Failure | Error,
    void,
    GetHarnessApprovalInstanceAuthorizationPathParams
  >
    path="/approvals/${approvalInstanceId}/harness/authorization"
    base={getConfig('pipeline/api')}
    {...props}
  />
)

export type UseGetHarnessApprovalInstanceAuthorizationProps = Omit<
  UseGetProps<
    ResponseHarnessApprovalInstanceAuthorization,
    Failure | Error,
    void,
    GetHarnessApprovalInstanceAuthorizationPathParams
  >,
  'path'
> &
  GetHarnessApprovalInstanceAuthorizationPathParams

/**
 * Gets a Harness approval instance authorization for the current user
 */
export const useGetHarnessApprovalInstanceAuthorization = ({
  approvalInstanceId,
  ...props
}: UseGetHarnessApprovalInstanceAuthorizationProps) =>
  useGet<
    ResponseHarnessApprovalInstanceAuthorization,
    Failure | Error,
    void,
    GetHarnessApprovalInstanceAuthorizationPathParams
  >(
    (paramsInPath: GetHarnessApprovalInstanceAuthorizationPathParams) =>
      `/approvals/${paramsInPath.approvalInstanceId}/harness/authorization`,
    { base: getConfig('pipeline/api'), pathParams: { approvalInstanceId }, ...props }
  )

/**
 * Gets a Harness approval instance authorization for the current user
 */
export const getHarnessApprovalInstanceAuthorizationPromise = (
  {
    approvalInstanceId,
    ...props
  }: GetUsingFetchProps<
    ResponseHarnessApprovalInstanceAuthorization,
    Failure | Error,
    void,
    GetHarnessApprovalInstanceAuthorizationPathParams
  > & { approvalInstanceId: string },
  signal?: RequestInit['signal']
) =>
  getUsingFetch<
    ResponseHarnessApprovalInstanceAuthorization,
    Failure | Error,
    void,
    GetHarnessApprovalInstanceAuthorizationPathParams
  >(getConfig('pipeline/api'), `/approvals/${approvalInstanceId}/harness/authorization`, props, signal)

export type GetBarriersSetupInfoListProps = Omit<
  MutateProps<ResponseListBarrierSetupInfo, Failure | Error, void, void, void>,
  'path' | 'verb'
>

/**
 * Gets barriers setup info list
 */
export const GetBarriersSetupInfoList = (props: GetBarriersSetupInfoListProps) => (
  <Mutate<ResponseListBarrierSetupInfo, Failure | Error, void, void, void>
    verb="PUT"
    path="/barriers/setupInfo"
    base={getConfig('pipeline/api')}
    {...props}
  />
)

export type UseGetBarriersSetupInfoListProps = Omit<
  UseMutateProps<ResponseListBarrierSetupInfo, Failure | Error, void, void, void>,
  'path' | 'verb'
>

/**
 * Gets barriers setup info list
 */
export const useGetBarriersSetupInfoList = (props: UseGetBarriersSetupInfoListProps) =>
  useMutate<ResponseListBarrierSetupInfo, Failure | Error, void, void, void>('PUT', `/barriers/setupInfo`, {
    base: getConfig('pipeline/api'),
    ...props
  })

/**
 * Gets barriers setup info list
 */
export const getBarriersSetupInfoListPromise = (
  props: MutateUsingFetchProps<ResponseListBarrierSetupInfo, Failure | Error, void, void, void>,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<ResponseListBarrierSetupInfo, Failure | Error, void, void, void>(
    'PUT',
    getConfig('pipeline/api'),
    `/barriers/setupInfo`,
    props,
    signal
  )

export interface GetBarriersExecutionInfoQueryParams {
  stageSetupId: string
  planExecutionId: string
}

export type GetBarriersExecutionInfoProps = Omit<
  GetProps<ResponseListBarrierExecutionInfo, Failure | Error, GetBarriersExecutionInfoQueryParams, void>,
  'path'
>

/**
 * Gets barriers execution info list
 */
export const GetBarriersExecutionInfo = (props: GetBarriersExecutionInfoProps) => (
  <Get<ResponseListBarrierExecutionInfo, Failure | Error, GetBarriersExecutionInfoQueryParams, void>
    path="/barriers/executionInfo"
    base={getConfig('pipeline/api')}
    {...props}
  />
)

export type UseGetBarriersExecutionInfoProps = Omit<
  UseGetProps<ResponseListBarrierExecutionInfo, Failure | Error, GetBarriersExecutionInfoQueryParams, void>,
  'path'
>

/**
 * Gets barriers execution info list
 */
export const useGetBarriersExecutionInfo = (props: UseGetBarriersExecutionInfoProps) =>
  useGet<ResponseListBarrierExecutionInfo, Failure | Error, GetBarriersExecutionInfoQueryParams, void>(
    `/barriers/executionInfo`,
    { base: getConfig('pipeline/api'), ...props }
  )

/**
 * Gets barriers execution info list
 */
export const getBarriersExecutionInfoPromise = (
  props: GetUsingFetchProps<
    ResponseListBarrierExecutionInfo,
    Failure | Error,
    GetBarriersExecutionInfoQueryParams,
    void
  >,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseListBarrierExecutionInfo, Failure | Error, GetBarriersExecutionInfoQueryParams, void>(
    getConfig('pipeline/api'),
    `/barriers/executionInfo`,
    props,
    signal
  )

export interface GetBarrierInfoQueryParams {
  barrierSetupId: string
  planExecutionId: string
}

export type GetBarrierInfoProps = Omit<
  GetProps<ResponseBarrierInfo, Failure | Error, GetBarrierInfoQueryParams, void>,
  'path'
>

/**
 * Gets barriers info
 */
export const GetBarrierInfo = (props: GetBarrierInfoProps) => (
  <Get<ResponseBarrierInfo, Failure | Error, GetBarrierInfoQueryParams, void>
    path="/barriers/info"
    base={getConfig('pipeline/api')}
    {...props}
  />
)

export type UseGetBarrierInfoProps = Omit<
  UseGetProps<ResponseBarrierInfo, Failure | Error, GetBarrierInfoQueryParams, void>,
  'path'
>

/**
 * Gets barriers info
 */
export const useGetBarrierInfo = (props: UseGetBarrierInfoProps) =>
  useGet<ResponseBarrierInfo, Failure | Error, GetBarrierInfoQueryParams, void>(`/barriers/info`, {
    base: getConfig('pipeline/api'),
    ...props
  })

/**
 * Gets barriers info
 */
export const getBarrierInfoPromise = (
  props: GetUsingFetchProps<ResponseBarrierInfo, Failure | Error, GetBarrierInfoQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseBarrierInfo, Failure | Error, GetBarrierInfoQueryParams, void>(
    getConfig('pipeline/api'),
    `/barriers/info`,
    props,
    signal
  )

export type GetPMSHealthStatusProps = Omit<GetProps<RestResponseString, unknown, void, void>, 'path'>

/**
 * get health for PMS service
 */
export const GetPMSHealthStatus = (props: GetPMSHealthStatusProps) => (
  <Get<RestResponseString, unknown, void, void> path="/health" base={getConfig('pipeline/api')} {...props} />
)

export type UseGetPMSHealthStatusProps = Omit<UseGetProps<RestResponseString, unknown, void, void>, 'path'>

/**
 * get health for PMS service
 */
export const useGetPMSHealthStatus = (props: UseGetPMSHealthStatusProps) =>
  useGet<RestResponseString, unknown, void, void>(`/health`, { base: getConfig('pipeline/api'), ...props })

/**
 * get health for PMS service
 */
export const getPMSHealthStatusPromise = (
  props: GetUsingFetchProps<RestResponseString, unknown, void, void>,
  signal?: RequestInit['signal']
) => getUsingFetch<RestResponseString, unknown, void, void>(getConfig('pipeline/api'), `/health`, props, signal)

export interface GetInputSetForPipelineQueryParams {
  accountIdentifier: string
  orgIdentifier: string
  projectIdentifier: string
  pipelineIdentifier: string
  deleted?: boolean
}

export interface GetInputSetForPipelinePathParams {
  inputSetIdentifier: string
}

export type GetInputSetForPipelineProps = Omit<
  GetProps<
    ResponseInputSetResponse,
    Failure | Error,
    GetInputSetForPipelineQueryParams,
    GetInputSetForPipelinePathParams
  >,
  'path'
> &
  GetInputSetForPipelinePathParams

/**
 * Gets an InputSet by identifier
 */
export const GetInputSetForPipeline = ({ inputSetIdentifier, ...props }: GetInputSetForPipelineProps) => (
  <Get<ResponseInputSetResponse, Failure | Error, GetInputSetForPipelineQueryParams, GetInputSetForPipelinePathParams>
    path="/inputSets/${inputSetIdentifier}"
    base={getConfig('pipeline/api')}
    {...props}
  />
)

export type UseGetInputSetForPipelineProps = Omit<
  UseGetProps<
    ResponseInputSetResponse,
    Failure | Error,
    GetInputSetForPipelineQueryParams,
    GetInputSetForPipelinePathParams
  >,
  'path'
> &
  GetInputSetForPipelinePathParams

/**
 * Gets an InputSet by identifier
 */
export const useGetInputSetForPipeline = ({ inputSetIdentifier, ...props }: UseGetInputSetForPipelineProps) =>
  useGet<
    ResponseInputSetResponse,
    Failure | Error,
    GetInputSetForPipelineQueryParams,
    GetInputSetForPipelinePathParams
  >((paramsInPath: GetInputSetForPipelinePathParams) => `/inputSets/${paramsInPath.inputSetIdentifier}`, {
    base: getConfig('pipeline/api'),
    pathParams: { inputSetIdentifier },
    ...props
  })

/**
 * Gets an InputSet by identifier
 */
export const getInputSetForPipelinePromise = (
  {
    inputSetIdentifier,
    ...props
  }: GetUsingFetchProps<
    ResponseInputSetResponse,
    Failure | Error,
    GetInputSetForPipelineQueryParams,
    GetInputSetForPipelinePathParams
  > & { inputSetIdentifier: string },
  signal?: RequestInit['signal']
) =>
  getUsingFetch<
    ResponseInputSetResponse,
    Failure | Error,
    GetInputSetForPipelineQueryParams,
    GetInputSetForPipelinePathParams
  >(getConfig('pipeline/api'), `/inputSets/${inputSetIdentifier}`, props, signal)

export interface UpdateInputSetForPipelineQueryParams {
  accountIdentifier: string
  orgIdentifier: string
  projectIdentifier: string
  pipelineIdentifier: string
}

export interface UpdateInputSetForPipelinePathParams {
  inputSetIdentifier: string
}

export type UpdateInputSetForPipelineProps = Omit<
  MutateProps<
    ResponseInputSetResponse,
    Failure | Error,
    UpdateInputSetForPipelineQueryParams,
    void,
    UpdateInputSetForPipelinePathParams
  >,
  'path' | 'verb'
> &
  UpdateInputSetForPipelinePathParams

/**
 * Update an InputSet by identifier
 */
export const UpdateInputSetForPipeline = ({ inputSetIdentifier, ...props }: UpdateInputSetForPipelineProps) => (
  <Mutate<
    ResponseInputSetResponse,
    Failure | Error,
    UpdateInputSetForPipelineQueryParams,
    void,
    UpdateInputSetForPipelinePathParams
  >
    verb="PUT"
    path="/inputSets/${inputSetIdentifier}"
    base={getConfig('pipeline/api')}
    {...props}
  />
)

export type UseUpdateInputSetForPipelineProps = Omit<
  UseMutateProps<
    ResponseInputSetResponse,
    Failure | Error,
    UpdateInputSetForPipelineQueryParams,
    void,
    UpdateInputSetForPipelinePathParams
  >,
  'path' | 'verb'
> &
  UpdateInputSetForPipelinePathParams

/**
 * Update an InputSet by identifier
 */
export const useUpdateInputSetForPipeline = ({ inputSetIdentifier, ...props }: UseUpdateInputSetForPipelineProps) =>
  useMutate<
    ResponseInputSetResponse,
    Failure | Error,
    UpdateInputSetForPipelineQueryParams,
    void,
    UpdateInputSetForPipelinePathParams
  >('PUT', (paramsInPath: UpdateInputSetForPipelinePathParams) => `/inputSets/${paramsInPath.inputSetIdentifier}`, {
    base: getConfig('pipeline/api'),
    pathParams: { inputSetIdentifier },
    ...props
  })

/**
 * Update an InputSet by identifier
 */
export const updateInputSetForPipelinePromise = (
  {
    inputSetIdentifier,
    ...props
  }: MutateUsingFetchProps<
    ResponseInputSetResponse,
    Failure | Error,
    UpdateInputSetForPipelineQueryParams,
    void,
    UpdateInputSetForPipelinePathParams
  > & { inputSetIdentifier: string },
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseInputSetResponse,
    Failure | Error,
    UpdateInputSetForPipelineQueryParams,
    void,
    UpdateInputSetForPipelinePathParams
  >('PUT', getConfig('pipeline/api'), `/inputSets/${inputSetIdentifier}`, props, signal)

export interface DeleteInputSetForPipelineQueryParams {
  accountIdentifier: string
  orgIdentifier: string
  projectIdentifier: string
  pipelineIdentifier: string
}

export type DeleteInputSetForPipelineProps = Omit<
  MutateProps<ResponseBoolean, Failure | Error, DeleteInputSetForPipelineQueryParams, string, void>,
  'path' | 'verb'
>

/**
 * Delete an inputSet by identifier
 */
export const DeleteInputSetForPipeline = (props: DeleteInputSetForPipelineProps) => (
  <Mutate<ResponseBoolean, Failure | Error, DeleteInputSetForPipelineQueryParams, string, void>
    verb="DELETE"
    path="/inputSets"
    base={getConfig('pipeline/api')}
    {...props}
  />
)

export type UseDeleteInputSetForPipelineProps = Omit<
  UseMutateProps<ResponseBoolean, Failure | Error, DeleteInputSetForPipelineQueryParams, string, void>,
  'path' | 'verb'
>

/**
 * Delete an inputSet by identifier
 */
export const useDeleteInputSetForPipeline = (props: UseDeleteInputSetForPipelineProps) =>
  useMutate<ResponseBoolean, Failure | Error, DeleteInputSetForPipelineQueryParams, string, void>(
    'DELETE',
    `/inputSets`,
    { base: getConfig('pipeline/api'), ...props }
  )

/**
 * Delete an inputSet by identifier
 */
export const deleteInputSetForPipelinePromise = (
  props: MutateUsingFetchProps<ResponseBoolean, Failure | Error, DeleteInputSetForPipelineQueryParams, string, void>,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<ResponseBoolean, Failure | Error, DeleteInputSetForPipelineQueryParams, string, void>(
    'DELETE',
    getConfig('pipeline/api'),
    `/inputSets`,
    props,
    signal
  )

export interface GetOverlayInputSetForPipelineQueryParams {
  accountIdentifier: string
  orgIdentifier: string
  projectIdentifier: string
  pipelineIdentifier: string
  deleted?: boolean
}

export interface GetOverlayInputSetForPipelinePathParams {
  inputSetIdentifier: string
}

export type GetOverlayInputSetForPipelineProps = Omit<
  GetProps<
    ResponseOverlayInputSetResponse,
    Failure | Error,
    GetOverlayInputSetForPipelineQueryParams,
    GetOverlayInputSetForPipelinePathParams
  >,
  'path'
> &
  GetOverlayInputSetForPipelinePathParams

/**
 * Gets an Overlay InputSet by identifier
 */
export const GetOverlayInputSetForPipeline = ({ inputSetIdentifier, ...props }: GetOverlayInputSetForPipelineProps) => (
  <Get<
    ResponseOverlayInputSetResponse,
    Failure | Error,
    GetOverlayInputSetForPipelineQueryParams,
    GetOverlayInputSetForPipelinePathParams
  >
    path="/inputSets/overlay/${inputSetIdentifier}"
    base={getConfig('pipeline/api')}
    {...props}
  />
)

export type UseGetOverlayInputSetForPipelineProps = Omit<
  UseGetProps<
    ResponseOverlayInputSetResponse,
    Failure | Error,
    GetOverlayInputSetForPipelineQueryParams,
    GetOverlayInputSetForPipelinePathParams
  >,
  'path'
> &
  GetOverlayInputSetForPipelinePathParams

/**
 * Gets an Overlay InputSet by identifier
 */
export const useGetOverlayInputSetForPipeline = ({
  inputSetIdentifier,
  ...props
}: UseGetOverlayInputSetForPipelineProps) =>
  useGet<
    ResponseOverlayInputSetResponse,
    Failure | Error,
    GetOverlayInputSetForPipelineQueryParams,
    GetOverlayInputSetForPipelinePathParams
  >(
    (paramsInPath: GetOverlayInputSetForPipelinePathParams) => `/inputSets/overlay/${paramsInPath.inputSetIdentifier}`,
    { base: getConfig('pipeline/api'), pathParams: { inputSetIdentifier }, ...props }
  )

/**
 * Gets an Overlay InputSet by identifier
 */
export const getOverlayInputSetForPipelinePromise = (
  {
    inputSetIdentifier,
    ...props
  }: GetUsingFetchProps<
    ResponseOverlayInputSetResponse,
    Failure | Error,
    GetOverlayInputSetForPipelineQueryParams,
    GetOverlayInputSetForPipelinePathParams
  > & { inputSetIdentifier: string },
  signal?: RequestInit['signal']
) =>
  getUsingFetch<
    ResponseOverlayInputSetResponse,
    Failure | Error,
    GetOverlayInputSetForPipelineQueryParams,
    GetOverlayInputSetForPipelinePathParams
  >(getConfig('pipeline/api'), `/inputSets/overlay/${inputSetIdentifier}`, props, signal)

export interface UpdateOverlayInputSetForPipelineQueryParams {
  accountIdentifier: string
  orgIdentifier: string
  projectIdentifier: string
  pipelineIdentifier: string
}

export interface UpdateOverlayInputSetForPipelinePathParams {
  inputSetIdentifier: string
}

export type UpdateOverlayInputSetForPipelineProps = Omit<
  MutateProps<
    ResponseOverlayInputSetResponse,
    Failure | Error,
    UpdateOverlayInputSetForPipelineQueryParams,
    void,
    UpdateOverlayInputSetForPipelinePathParams
  >,
  'path' | 'verb'
> &
  UpdateOverlayInputSetForPipelinePathParams

/**
 * Update an Overlay InputSet by identifier
 */
export const UpdateOverlayInputSetForPipeline = ({
  inputSetIdentifier,
  ...props
}: UpdateOverlayInputSetForPipelineProps) => (
  <Mutate<
    ResponseOverlayInputSetResponse,
    Failure | Error,
    UpdateOverlayInputSetForPipelineQueryParams,
    void,
    UpdateOverlayInputSetForPipelinePathParams
  >
    verb="PUT"
    path="/inputSets/overlay/${inputSetIdentifier}"
    base={getConfig('pipeline/api')}
    {...props}
  />
)

export type UseUpdateOverlayInputSetForPipelineProps = Omit<
  UseMutateProps<
    ResponseOverlayInputSetResponse,
    Failure | Error,
    UpdateOverlayInputSetForPipelineQueryParams,
    void,
    UpdateOverlayInputSetForPipelinePathParams
  >,
  'path' | 'verb'
> &
  UpdateOverlayInputSetForPipelinePathParams

/**
 * Update an Overlay InputSet by identifier
 */
export const useUpdateOverlayInputSetForPipeline = ({
  inputSetIdentifier,
  ...props
}: UseUpdateOverlayInputSetForPipelineProps) =>
  useMutate<
    ResponseOverlayInputSetResponse,
    Failure | Error,
    UpdateOverlayInputSetForPipelineQueryParams,
    void,
    UpdateOverlayInputSetForPipelinePathParams
  >(
    'PUT',
    (paramsInPath: UpdateOverlayInputSetForPipelinePathParams) =>
      `/inputSets/overlay/${paramsInPath.inputSetIdentifier}`,
    { base: getConfig('pipeline/api'), pathParams: { inputSetIdentifier }, ...props }
  )

/**
 * Update an Overlay InputSet by identifier
 */
export const updateOverlayInputSetForPipelinePromise = (
  {
    inputSetIdentifier,
    ...props
  }: MutateUsingFetchProps<
    ResponseOverlayInputSetResponse,
    Failure | Error,
    UpdateOverlayInputSetForPipelineQueryParams,
    void,
    UpdateOverlayInputSetForPipelinePathParams
  > & { inputSetIdentifier: string },
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseOverlayInputSetResponse,
    Failure | Error,
    UpdateOverlayInputSetForPipelineQueryParams,
    void,
    UpdateOverlayInputSetForPipelinePathParams
  >('PUT', getConfig('pipeline/api'), `/inputSets/overlay/${inputSetIdentifier}`, props, signal)

export interface GetInputSetsListForPipelineQueryParams {
  pageIndex?: number
  pageSize?: number
  accountIdentifier: string
  orgIdentifier: string
  projectIdentifier: string
  pipelineIdentifier: string
  inputSetType?: 'ALL' | 'INPUT_SET' | 'OVERLAY_INPUT_SET'
  searchTerm?: string
  sortOrders?: string[]
}

export type GetInputSetsListForPipelineProps = Omit<
  GetProps<ResponsePageInputSetSummaryResponse, Failure | Error, GetInputSetsListForPipelineQueryParams, void>,
  'path'
>

/**
 * Gets InputSets list for a pipeline
 */
export const GetInputSetsListForPipeline = (props: GetInputSetsListForPipelineProps) => (
  <Get<ResponsePageInputSetSummaryResponse, Failure | Error, GetInputSetsListForPipelineQueryParams, void>
    path="/inputSets"
    base={getConfig('pipeline/api')}
    {...props}
  />
)

export type UseGetInputSetsListForPipelineProps = Omit<
  UseGetProps<ResponsePageInputSetSummaryResponse, Failure | Error, GetInputSetsListForPipelineQueryParams, void>,
  'path'
>

/**
 * Gets InputSets list for a pipeline
 */
export const useGetInputSetsListForPipeline = (props: UseGetInputSetsListForPipelineProps) =>
  useGet<ResponsePageInputSetSummaryResponse, Failure | Error, GetInputSetsListForPipelineQueryParams, void>(
    `/inputSets`,
    { base: getConfig('pipeline/api'), ...props }
  )

/**
 * Gets InputSets list for a pipeline
 */
export const getInputSetsListForPipelinePromise = (
  props: GetUsingFetchProps<
    ResponsePageInputSetSummaryResponse,
    Failure | Error,
    GetInputSetsListForPipelineQueryParams,
    void
  >,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponsePageInputSetSummaryResponse, Failure | Error, GetInputSetsListForPipelineQueryParams, void>(
    getConfig('pipeline/api'),
    `/inputSets`,
    props,
    signal
  )

export interface CreateInputSetForPipelineQueryParams {
  accountIdentifier: string
  orgIdentifier: string
  projectIdentifier: string
  pipelineIdentifier: string
}

export type CreateInputSetForPipelineProps = Omit<
  MutateProps<ResponseInputSetResponse, Failure | Error, CreateInputSetForPipelineQueryParams, void, void>,
  'path' | 'verb'
>

/**
 * Create an InputSet For Pipeline
 */
export const CreateInputSetForPipeline = (props: CreateInputSetForPipelineProps) => (
  <Mutate<ResponseInputSetResponse, Failure | Error, CreateInputSetForPipelineQueryParams, void, void>
    verb="POST"
    path="/inputSets"
    base={getConfig('pipeline/api')}
    {...props}
  />
)

export type UseCreateInputSetForPipelineProps = Omit<
  UseMutateProps<ResponseInputSetResponse, Failure | Error, CreateInputSetForPipelineQueryParams, void, void>,
  'path' | 'verb'
>

/**
 * Create an InputSet For Pipeline
 */
export const useCreateInputSetForPipeline = (props: UseCreateInputSetForPipelineProps) =>
  useMutate<ResponseInputSetResponse, Failure | Error, CreateInputSetForPipelineQueryParams, void, void>(
    'POST',
    `/inputSets`,
    { base: getConfig('pipeline/api'), ...props }
  )

/**
 * Create an InputSet For Pipeline
 */
export const createInputSetForPipelinePromise = (
  props: MutateUsingFetchProps<
    ResponseInputSetResponse,
    Failure | Error,
    CreateInputSetForPipelineQueryParams,
    void,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<ResponseInputSetResponse, Failure | Error, CreateInputSetForPipelineQueryParams, void, void>(
    'POST',
    getConfig('pipeline/api'),
    `/inputSets`,
    props,
    signal
  )

export interface CreateOverlayInputSetForPipelineQueryParams {
  accountIdentifier: string
  orgIdentifier: string
  projectIdentifier: string
  pipelineIdentifier: string
}

export type CreateOverlayInputSetForPipelineProps = Omit<
  MutateProps<
    ResponseOverlayInputSetResponse,
    Failure | Error,
    CreateOverlayInputSetForPipelineQueryParams,
    void,
    void
  >,
  'path' | 'verb'
>

/**
 * Create an Overlay InputSet For Pipeline
 */
export const CreateOverlayInputSetForPipeline = (props: CreateOverlayInputSetForPipelineProps) => (
  <Mutate<ResponseOverlayInputSetResponse, Failure | Error, CreateOverlayInputSetForPipelineQueryParams, void, void>
    verb="POST"
    path="/inputSets/overlay"
    base={getConfig('pipeline/api')}
    {...props}
  />
)

export type UseCreateOverlayInputSetForPipelineProps = Omit<
  UseMutateProps<
    ResponseOverlayInputSetResponse,
    Failure | Error,
    CreateOverlayInputSetForPipelineQueryParams,
    void,
    void
  >,
  'path' | 'verb'
>

/**
 * Create an Overlay InputSet For Pipeline
 */
export const useCreateOverlayInputSetForPipeline = (props: UseCreateOverlayInputSetForPipelineProps) =>
  useMutate<ResponseOverlayInputSetResponse, Failure | Error, CreateOverlayInputSetForPipelineQueryParams, void, void>(
    'POST',
    `/inputSets/overlay`,
    { base: getConfig('pipeline/api'), ...props }
  )

/**
 * Create an Overlay InputSet For Pipeline
 */
export const createOverlayInputSetForPipelinePromise = (
  props: MutateUsingFetchProps<
    ResponseOverlayInputSetResponse,
    Failure | Error,
    CreateOverlayInputSetForPipelineQueryParams,
    void,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseOverlayInputSetResponse,
    Failure | Error,
    CreateOverlayInputSetForPipelineQueryParams,
    void,
    void
  >('POST', getConfig('pipeline/api'), `/inputSets/overlay`, props, signal)

export interface GetTemplateFromPipelineQueryParams {
  accountIdentifier: string
  orgIdentifier: string
  projectIdentifier: string
  pipelineIdentifier: string
}

export type GetTemplateFromPipelineProps = Omit<
  GetProps<ResponseInputSetTemplateResponse, Failure | Error, GetTemplateFromPipelineQueryParams, void>,
  'path'
>

/**
 * Get template from a pipeline yaml
 */
export const GetTemplateFromPipeline = (props: GetTemplateFromPipelineProps) => (
  <Get<ResponseInputSetTemplateResponse, Failure | Error, GetTemplateFromPipelineQueryParams, void>
    path="/inputSets/template"
    base={getConfig('pipeline/api')}
    {...props}
  />
)

export type UseGetTemplateFromPipelineProps = Omit<
  UseGetProps<ResponseInputSetTemplateResponse, Failure | Error, GetTemplateFromPipelineQueryParams, void>,
  'path'
>

/**
 * Get template from a pipeline yaml
 */
export const useGetTemplateFromPipeline = (props: UseGetTemplateFromPipelineProps) =>
  useGet<ResponseInputSetTemplateResponse, Failure | Error, GetTemplateFromPipelineQueryParams, void>(
    `/inputSets/template`,
    { base: getConfig('pipeline/api'), ...props }
  )

/**
 * Get template from a pipeline yaml
 */
export const getTemplateFromPipelinePromise = (
  props: GetUsingFetchProps<
    ResponseInputSetTemplateResponse,
    Failure | Error,
    GetTemplateFromPipelineQueryParams,
    void
  >,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseInputSetTemplateResponse, Failure | Error, GetTemplateFromPipelineQueryParams, void>(
    getConfig('pipeline/api'),
    `/inputSets/template`,
    props,
    signal
  )

export interface GetMergeInputSetFromPipelineTemplateWithListInputQueryParams {
  accountIdentifier: string
  orgIdentifier: string
  projectIdentifier: string
  pipelineIdentifier: string
  useFQNIfError?: boolean
}

export type GetMergeInputSetFromPipelineTemplateWithListInputProps = Omit<
  MutateProps<
    ResponseMergeInputSetResponse,
    Failure | Error,
    GetMergeInputSetFromPipelineTemplateWithListInputQueryParams,
    MergeInputSetRequestRequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Merges given input sets list on pipeline and return input set template format of applied pipeline
 */
export const GetMergeInputSetFromPipelineTemplateWithListInput = (
  props: GetMergeInputSetFromPipelineTemplateWithListInputProps
) => (
  <Mutate<
    ResponseMergeInputSetResponse,
    Failure | Error,
    GetMergeInputSetFromPipelineTemplateWithListInputQueryParams,
    MergeInputSetRequestRequestBody,
    void
  >
    verb="POST"
    path="/inputSets/merge"
    base={getConfig('pipeline/api')}
    {...props}
  />
)

export type UseGetMergeInputSetFromPipelineTemplateWithListInputProps = Omit<
  UseMutateProps<
    ResponseMergeInputSetResponse,
    Failure | Error,
    GetMergeInputSetFromPipelineTemplateWithListInputQueryParams,
    MergeInputSetRequestRequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Merges given input sets list on pipeline and return input set template format of applied pipeline
 */
export const useGetMergeInputSetFromPipelineTemplateWithListInput = (
  props: UseGetMergeInputSetFromPipelineTemplateWithListInputProps
) =>
  useMutate<
    ResponseMergeInputSetResponse,
    Failure | Error,
    GetMergeInputSetFromPipelineTemplateWithListInputQueryParams,
    MergeInputSetRequestRequestBody,
    void
  >('POST', `/inputSets/merge`, { base: getConfig('pipeline/api'), ...props })

/**
 * Merges given input sets list on pipeline and return input set template format of applied pipeline
 */
export const getMergeInputSetFromPipelineTemplateWithListInputPromise = (
  props: MutateUsingFetchProps<
    ResponseMergeInputSetResponse,
    Failure | Error,
    GetMergeInputSetFromPipelineTemplateWithListInputQueryParams,
    MergeInputSetRequestRequestBody,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseMergeInputSetResponse,
    Failure | Error,
    GetMergeInputSetFromPipelineTemplateWithListInputQueryParams,
    MergeInputSetRequestRequestBody,
    void
  >('POST', getConfig('pipeline/api'), `/inputSets/merge`, props, signal)

export interface CreateVariablesQueryParams {
  accountIdentifier: string
  orgIdentifier: string
  projectIdentifier: string
}

export type CreateVariablesProps = Omit<
  MutateProps<ResponseVariableMergeServiceResponse, Failure | Error, CreateVariablesQueryParams, void, void>,
  'path' | 'verb'
>

/**
 * Create variables for Pipeline
 */
export const CreateVariables = (props: CreateVariablesProps) => (
  <Mutate<ResponseVariableMergeServiceResponse, Failure | Error, CreateVariablesQueryParams, void, void>
    verb="POST"
    path="/pipelines/variables"
    base={getConfig('pipeline/api')}
    {...props}
  />
)

export type UseCreateVariablesProps = Omit<
  UseMutateProps<ResponseVariableMergeServiceResponse, Failure | Error, CreateVariablesQueryParams, void, void>,
  'path' | 'verb'
>

/**
 * Create variables for Pipeline
 */
export const useCreateVariables = (props: UseCreateVariablesProps) =>
  useMutate<ResponseVariableMergeServiceResponse, Failure | Error, CreateVariablesQueryParams, void, void>(
    'POST',
    `/pipelines/variables`,
    { base: getConfig('pipeline/api'), ...props }
  )

/**
 * Create variables for Pipeline
 */
export const createVariablesPromise = (
  props: MutateUsingFetchProps<
    ResponseVariableMergeServiceResponse,
    Failure | Error,
    CreateVariablesQueryParams,
    void,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<ResponseVariableMergeServiceResponse, Failure | Error, CreateVariablesQueryParams, void, void>(
    'POST',
    getConfig('pipeline/api'),
    `/pipelines/variables`,
    props,
    signal
  )

export interface GetPipelineQueryParams {
  accountIdentifier: string
  orgIdentifier: string
  projectIdentifier: string
}

export interface GetPipelinePathParams {
  pipelineIdentifier: string
}

export type GetPipelineProps = Omit<
  GetProps<ResponsePMSPipelineResponseDTO, Failure | Error, GetPipelineQueryParams, GetPipelinePathParams>,
  'path'
> &
  GetPipelinePathParams

/**
 * Gets a pipeline by identifier
 */
export const GetPipeline = ({ pipelineIdentifier, ...props }: GetPipelineProps) => (
  <Get<ResponsePMSPipelineResponseDTO, Failure | Error, GetPipelineQueryParams, GetPipelinePathParams>
    path="/pipelines/${pipelineIdentifier}"
    base={getConfig('pipeline/api')}
    {...props}
  />
)

export type UseGetPipelineProps = Omit<
  UseGetProps<ResponsePMSPipelineResponseDTO, Failure | Error, GetPipelineQueryParams, GetPipelinePathParams>,
  'path'
> &
  GetPipelinePathParams

/**
 * Gets a pipeline by identifier
 */
export const useGetPipeline = ({ pipelineIdentifier, ...props }: UseGetPipelineProps) =>
  useGet<ResponsePMSPipelineResponseDTO, Failure | Error, GetPipelineQueryParams, GetPipelinePathParams>(
    (paramsInPath: GetPipelinePathParams) => `/pipelines/${paramsInPath.pipelineIdentifier}`,
    { base: getConfig('pipeline/api'), pathParams: { pipelineIdentifier }, ...props }
  )

/**
 * Gets a pipeline by identifier
 */
export const getPipelinePromise = (
  {
    pipelineIdentifier,
    ...props
  }: GetUsingFetchProps<
    ResponsePMSPipelineResponseDTO,
    Failure | Error,
    GetPipelineQueryParams,
    GetPipelinePathParams
  > & { pipelineIdentifier: string },
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponsePMSPipelineResponseDTO, Failure | Error, GetPipelineQueryParams, GetPipelinePathParams>(
    getConfig('pipeline/api'),
    `/pipelines/${pipelineIdentifier}`,
    props,
    signal
  )

export interface PutPipelineQueryParams {
  accountIdentifier: string
  orgIdentifier: string
  projectIdentifier: string
}

export interface PutPipelinePathParams {
  pipelineIdentifier: string
}

export type PutPipelineProps = Omit<
  MutateProps<ResponseString, Failure | Error, PutPipelineQueryParams, void, PutPipelinePathParams>,
  'path' | 'verb'
> &
  PutPipelinePathParams

/**
 * Update a Pipeline
 */
export const PutPipeline = ({ pipelineIdentifier, ...props }: PutPipelineProps) => (
  <Mutate<ResponseString, Failure | Error, PutPipelineQueryParams, void, PutPipelinePathParams>
    verb="PUT"
    path="/pipelines/${pipelineIdentifier}"
    base={getConfig('pipeline/api')}
    {...props}
  />
)

export type UsePutPipelineProps = Omit<
  UseMutateProps<ResponseString, Failure | Error, PutPipelineQueryParams, void, PutPipelinePathParams>,
  'path' | 'verb'
> &
  PutPipelinePathParams

/**
 * Update a Pipeline
 */
export const usePutPipeline = ({ pipelineIdentifier, ...props }: UsePutPipelineProps) =>
  useMutate<ResponseString, Failure | Error, PutPipelineQueryParams, void, PutPipelinePathParams>(
    'PUT',
    (paramsInPath: PutPipelinePathParams) => `/pipelines/${paramsInPath.pipelineIdentifier}`,
    { base: getConfig('pipeline/api'), pathParams: { pipelineIdentifier }, ...props }
  )

/**
 * Update a Pipeline
 */
export const putPipelinePromise = (
  {
    pipelineIdentifier,
    ...props
  }: MutateUsingFetchProps<ResponseString, Failure | Error, PutPipelineQueryParams, void, PutPipelinePathParams> & {
    pipelineIdentifier: string
  },
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<ResponseString, Failure | Error, PutPipelineQueryParams, void, PutPipelinePathParams>(
    'PUT',
    getConfig('pipeline/api'),
    `/pipelines/${pipelineIdentifier}`,
    props,
    signal
  )

export interface SoftDeletePipelineQueryParams {
  accountIdentifier: string
  orgIdentifier: string
  projectIdentifier: string
}

export type SoftDeletePipelineProps = Omit<
  MutateProps<ResponseBoolean, Failure | Error, SoftDeletePipelineQueryParams, string, void>,
  'path' | 'verb'
>

/**
 * Delete a pipeline
 */
export const SoftDeletePipeline = (props: SoftDeletePipelineProps) => (
  <Mutate<ResponseBoolean, Failure | Error, SoftDeletePipelineQueryParams, string, void>
    verb="DELETE"
    path="/pipelines"
    base={getConfig('pipeline/api')}
    {...props}
  />
)

export type UseSoftDeletePipelineProps = Omit<
  UseMutateProps<ResponseBoolean, Failure | Error, SoftDeletePipelineQueryParams, string, void>,
  'path' | 'verb'
>

/**
 * Delete a pipeline
 */
export const useSoftDeletePipeline = (props: UseSoftDeletePipelineProps) =>
  useMutate<ResponseBoolean, Failure | Error, SoftDeletePipelineQueryParams, string, void>('DELETE', `/pipelines`, {
    base: getConfig('pipeline/api'),
    ...props
  })

/**
 * Delete a pipeline
 */
export const softDeletePipelinePromise = (
  props: MutateUsingFetchProps<ResponseBoolean, Failure | Error, SoftDeletePipelineQueryParams, string, void>,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<ResponseBoolean, Failure | Error, SoftDeletePipelineQueryParams, string, void>(
    'DELETE',
    getConfig('pipeline/api'),
    `/pipelines`,
    props,
    signal
  )

export interface GetPipelineListQueryParams {
  accountIdentifier: string
  orgIdentifier: string
  projectIdentifier: string
  page?: number
  size?: number
  sort?: string[]
  searchTerm?: string
  module?: string
  filterIdentifier?: string
}

export type GetPipelineListProps = Omit<
  MutateProps<
    ResponsePagePMSPipelineSummaryResponse,
    Failure | Error,
    GetPipelineListQueryParams,
    FilterPropertiesRequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Gets Pipeline list
 */
export const GetPipelineList = (props: GetPipelineListProps) => (
  <Mutate<
    ResponsePagePMSPipelineSummaryResponse,
    Failure | Error,
    GetPipelineListQueryParams,
    FilterPropertiesRequestBody,
    void
  >
    verb="POST"
    path="/pipelines/list"
    base={getConfig('pipeline/api')}
    {...props}
  />
)

export type UseGetPipelineListProps = Omit<
  UseMutateProps<
    ResponsePagePMSPipelineSummaryResponse,
    Failure | Error,
    GetPipelineListQueryParams,
    FilterPropertiesRequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Gets Pipeline list
 */
export const useGetPipelineList = (props: UseGetPipelineListProps) =>
  useMutate<
    ResponsePagePMSPipelineSummaryResponse,
    Failure | Error,
    GetPipelineListQueryParams,
    FilterPropertiesRequestBody,
    void
  >('POST', `/pipelines/list`, { base: getConfig('pipeline/api'), ...props })

/**
 * Gets Pipeline list
 */
export const getPipelineListPromise = (
  props: MutateUsingFetchProps<
    ResponsePagePMSPipelineSummaryResponse,
    Failure | Error,
    GetPipelineListQueryParams,
    FilterPropertiesRequestBody,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponsePagePMSPipelineSummaryResponse,
    Failure | Error,
    GetPipelineListQueryParams,
    FilterPropertiesRequestBody,
    void
  >('POST', getConfig('pipeline/api'), `/pipelines/list`, props, signal)

export interface GetPipelineSummaryQueryParams {
  accountIdentifier: string
  orgIdentifier: string
  projectIdentifier: string
}

export interface GetPipelineSummaryPathParams {
  pipelineIdentifier: string
}

export type GetPipelineSummaryProps = Omit<
  GetProps<
    ResponsePMSPipelineSummaryResponse,
    Failure | Error,
    GetPipelineSummaryQueryParams,
    GetPipelineSummaryPathParams
  >,
  'path'
> &
  GetPipelineSummaryPathParams

/**
 * Gets Pipeline Summary of a pipeline
 */
export const GetPipelineSummary = ({ pipelineIdentifier, ...props }: GetPipelineSummaryProps) => (
  <Get<ResponsePMSPipelineSummaryResponse, Failure | Error, GetPipelineSummaryQueryParams, GetPipelineSummaryPathParams>
    path="/pipelines/summary/${pipelineIdentifier}"
    base={getConfig('pipeline/api')}
    {...props}
  />
)

export type UseGetPipelineSummaryProps = Omit<
  UseGetProps<
    ResponsePMSPipelineSummaryResponse,
    Failure | Error,
    GetPipelineSummaryQueryParams,
    GetPipelineSummaryPathParams
  >,
  'path'
> &
  GetPipelineSummaryPathParams

/**
 * Gets Pipeline Summary of a pipeline
 */
export const useGetPipelineSummary = ({ pipelineIdentifier, ...props }: UseGetPipelineSummaryProps) =>
  useGet<
    ResponsePMSPipelineSummaryResponse,
    Failure | Error,
    GetPipelineSummaryQueryParams,
    GetPipelineSummaryPathParams
  >((paramsInPath: GetPipelineSummaryPathParams) => `/pipelines/summary/${paramsInPath.pipelineIdentifier}`, {
    base: getConfig('pipeline/api'),
    pathParams: { pipelineIdentifier },
    ...props
  })

/**
 * Gets Pipeline Summary of a pipeline
 */
export const getPipelineSummaryPromise = (
  {
    pipelineIdentifier,
    ...props
  }: GetUsingFetchProps<
    ResponsePMSPipelineSummaryResponse,
    Failure | Error,
    GetPipelineSummaryQueryParams,
    GetPipelineSummaryPathParams
  > & { pipelineIdentifier: string },
  signal?: RequestInit['signal']
) =>
  getUsingFetch<
    ResponsePMSPipelineSummaryResponse,
    Failure | Error,
    GetPipelineSummaryQueryParams,
    GetPipelineSummaryPathParams
  >(getConfig('pipeline/api'), `/pipelines/summary/${pipelineIdentifier}`, props, signal)

export interface GetListOfExecutionsQueryParams {
  accountIdentifier: string
  orgIdentifier: string
  projectIdentifier: string
  searchTerm?: string
  pipelineIdentifier?: string
  page?: number
  size?: number
  sort?: string[]
  filterIdentifier?: string
  module?: string
  status?:
    | 'Running'
    | 'Failed'
    | 'NotStarted'
    | 'Expired'
    | 'Aborted'
    | 'Queued'
    | 'Paused'
    | 'Waiting'
    | 'Success'
    | 'Suspended'
    | 'Skipped'
    | 'Pausing'
  myDeployments?: boolean
}

export type GetListOfExecutionsProps = Omit<
  MutateProps<
    ResponsePagePipelineExecutionSummary,
    Failure | Error,
    GetListOfExecutionsQueryParams,
    FilterPropertiesRequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Gets Executions list
 */
export const GetListOfExecutions = (props: GetListOfExecutionsProps) => (
  <Mutate<
    ResponsePagePipelineExecutionSummary,
    Failure | Error,
    GetListOfExecutionsQueryParams,
    FilterPropertiesRequestBody,
    void
  >
    verb="POST"
    path="/pipelines/execution/summary"
    base={getConfig('pipeline/api')}
    {...props}
  />
)

export type UseGetListOfExecutionsProps = Omit<
  UseMutateProps<
    ResponsePagePipelineExecutionSummary,
    Failure | Error,
    GetListOfExecutionsQueryParams,
    FilterPropertiesRequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Gets Executions list
 */
export const useGetListOfExecutions = (props: UseGetListOfExecutionsProps) =>
  useMutate<
    ResponsePagePipelineExecutionSummary,
    Failure | Error,
    GetListOfExecutionsQueryParams,
    FilterPropertiesRequestBody,
    void
  >('POST', `/pipelines/execution/summary`, { base: getConfig('pipeline/api'), ...props })

/**
 * Gets Executions list
 */
export const getListOfExecutionsPromise = (
  props: MutateUsingFetchProps<
    ResponsePagePipelineExecutionSummary,
    Failure | Error,
    GetListOfExecutionsQueryParams,
    FilterPropertiesRequestBody,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponsePagePipelineExecutionSummary,
    Failure | Error,
    GetListOfExecutionsQueryParams,
    FilterPropertiesRequestBody,
    void
  >('POST', getConfig('pipeline/api'), `/pipelines/execution/summary`, props, signal)

export interface GetExecutionDetailQueryParams {
  accountIdentifier: string
  orgIdentifier: string
  projectIdentifier: string
  filter?: string
  stageNodeId?: string
}

export interface GetExecutionDetailPathParams {
  planExecutionId: string
}

export type GetExecutionDetailProps = Omit<
  GetProps<
    ResponsePipelineExecutionDetail,
    Failure | Error,
    GetExecutionDetailQueryParams,
    GetExecutionDetailPathParams
  >,
  'path'
> &
  GetExecutionDetailPathParams

/**
 * Gets Execution Detail
 */
export const GetExecutionDetail = ({ planExecutionId, ...props }: GetExecutionDetailProps) => (
  <Get<ResponsePipelineExecutionDetail, Failure | Error, GetExecutionDetailQueryParams, GetExecutionDetailPathParams>
    path="/pipelines/execution/${planExecutionId}"
    base={getConfig('pipeline/api')}
    {...props}
  />
)

export type UseGetExecutionDetailProps = Omit<
  UseGetProps<
    ResponsePipelineExecutionDetail,
    Failure | Error,
    GetExecutionDetailQueryParams,
    GetExecutionDetailPathParams
  >,
  'path'
> &
  GetExecutionDetailPathParams

/**
 * Gets Execution Detail
 */
export const useGetExecutionDetail = ({ planExecutionId, ...props }: UseGetExecutionDetailProps) =>
  useGet<ResponsePipelineExecutionDetail, Failure | Error, GetExecutionDetailQueryParams, GetExecutionDetailPathParams>(
    (paramsInPath: GetExecutionDetailPathParams) => `/pipelines/execution/${paramsInPath.planExecutionId}`,
    { base: getConfig('pipeline/api'), pathParams: { planExecutionId }, ...props }
  )

/**
 * Gets Execution Detail
 */
export const getExecutionDetailPromise = (
  {
    planExecutionId,
    ...props
  }: GetUsingFetchProps<
    ResponsePipelineExecutionDetail,
    Failure | Error,
    GetExecutionDetailQueryParams,
    GetExecutionDetailPathParams
  > & { planExecutionId: string },
  signal?: RequestInit['signal']
) =>
  getUsingFetch<
    ResponsePipelineExecutionDetail,
    Failure | Error,
    GetExecutionDetailQueryParams,
    GetExecutionDetailPathParams
  >(getConfig('pipeline/api'), `/pipelines/execution/${planExecutionId}`, props, signal)

export interface GetYamlSchemaQueryParams {
  entityType:
    | 'Projects'
    | 'Pipelines'
    | 'PipelineSteps'
    | 'Connectors'
    | 'Secrets'
    | 'Service'
    | 'Environment'
    | 'InputSets'
    | 'CvConfig'
    | 'Delegates'
    | 'DelegateConfigurations'
    | 'CvVerificationJob'
    | 'IntegrationStage'
    | 'IntegrationSteps'
    | 'CvKubernetesActivitySource'
    | 'DeploymentSteps'
    | 'DeploymentStage'
    | 'ApprovalStage'
    | 'Triggers'
  projectIdentifier?: string
  orgIdentifier?: string
  scope?: 'account' | 'org' | 'project' | 'unknown'
}

export type GetYamlSchemaProps = Omit<
  GetProps<ResponseJsonNode, Failure | Error, GetYamlSchemaQueryParams, void>,
  'path'
>

/**
 * Get Yaml Schema
 */
export const GetYamlSchema = (props: GetYamlSchemaProps) => (
  <Get<ResponseJsonNode, Failure | Error, GetYamlSchemaQueryParams, void>
    path="/pipelines/yaml-schema"
    base={getConfig('pipeline/api')}
    {...props}
  />
)

export type UseGetYamlSchemaProps = Omit<
  UseGetProps<ResponseJsonNode, Failure | Error, GetYamlSchemaQueryParams, void>,
  'path'
>

/**
 * Get Yaml Schema
 */
export const useGetYamlSchema = (props: UseGetYamlSchemaProps) =>
  useGet<ResponseJsonNode, Failure | Error, GetYamlSchemaQueryParams, void>(`/pipelines/yaml-schema`, {
    base: getConfig('pipeline/api'),
    ...props
  })

/**
 * Get Yaml Schema
 */
export const getYamlSchemaPromise = (
  props: GetUsingFetchProps<ResponseJsonNode, Failure | Error, GetYamlSchemaQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseJsonNode, Failure | Error, GetYamlSchemaQueryParams, void>(
    getConfig('pipeline/api'),
    `/pipelines/yaml-schema`,
    props,
    signal
  )

export type GetNotificationSchemaProps = Omit<GetProps<ResponseNotificationRules, Failure | Error, void, void>, 'path'>

/**
 * Get Notification Schema
 */
export const GetNotificationSchema = (props: GetNotificationSchemaProps) => (
  <Get<ResponseNotificationRules, Failure | Error, void, void>
    path="/pipelines/notification"
    base={getConfig('pipeline/api')}
    {...props}
  />
)

export type UseGetNotificationSchemaProps = Omit<
  UseGetProps<ResponseNotificationRules, Failure | Error, void, void>,
  'path'
>

/**
 * Get Notification Schema
 */
export const useGetNotificationSchema = (props: UseGetNotificationSchemaProps) =>
  useGet<ResponseNotificationRules, Failure | Error, void, void>(`/pipelines/notification`, {
    base: getConfig('pipeline/api'),
    ...props
  })

/**
 * Get Notification Schema
 */
export const getNotificationSchemaPromise = (
  props: GetUsingFetchProps<ResponseNotificationRules, Failure | Error, void, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseNotificationRules, Failure | Error, void, void>(
    getConfig('pipeline/api'),
    `/pipelines/notification`,
    props,
    signal
  )

export interface GetExecutionNodeQueryParams {
  accountIdentifier: string
  orgIdentifier: string
  projectIdentifier: string
  nodeExecutionId: string
}

export type GetExecutionNodeProps = Omit<
  GetProps<ResponseExecutionNode, Failure | Error, GetExecutionNodeQueryParams, void>,
  'path'
>

/**
 * get execution node
 */
export const GetExecutionNode = (props: GetExecutionNodeProps) => (
  <Get<ResponseExecutionNode, Failure | Error, GetExecutionNodeQueryParams, void>
    path="/pipelines/getExecutionNode"
    base={getConfig('pipeline/api')}
    {...props}
  />
)

export type UseGetExecutionNodeProps = Omit<
  UseGetProps<ResponseExecutionNode, Failure | Error, GetExecutionNodeQueryParams, void>,
  'path'
>

/**
 * get execution node
 */
export const useGetExecutionNode = (props: UseGetExecutionNodeProps) =>
  useGet<ResponseExecutionNode, Failure | Error, GetExecutionNodeQueryParams, void>(`/pipelines/getExecutionNode`, {
    base: getConfig('pipeline/api'),
    ...props
  })

/**
 * get execution node
 */
export const getExecutionNodePromise = (
  props: GetUsingFetchProps<ResponseExecutionNode, Failure | Error, GetExecutionNodeQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseExecutionNode, Failure | Error, GetExecutionNodeQueryParams, void>(
    getConfig('pipeline/api'),
    `/pipelines/getExecutionNode`,
    props,
    signal
  )

export interface GetInputsetYamlQueryParams {
  accountIdentifier: string
  orgIdentifier: string
  projectIdentifier: string
}

export interface GetInputsetYamlPathParams {
  planExecutionId: string
}

export type GetInputsetYamlProps = Omit<
  GetProps<void, void, GetInputsetYamlQueryParams, GetInputsetYamlPathParams>,
  'path'
> &
  GetInputsetYamlPathParams

/**
 * Gets  inputsetYaml
 */
export const GetInputsetYaml = ({ planExecutionId, ...props }: GetInputsetYamlProps) => (
  <Get<void, void, GetInputsetYamlQueryParams, GetInputsetYamlPathParams>
    path="/pipelines/execution/${planExecutionId}/inputset"
    base={getConfig('pipeline/api')}
    {...props}
  />
)

export type UseGetInputsetYamlProps = Omit<
  UseGetProps<void, void, GetInputsetYamlQueryParams, GetInputsetYamlPathParams>,
  'path'
> &
  GetInputsetYamlPathParams

/**
 * Gets  inputsetYaml
 */
export const useGetInputsetYaml = ({ planExecutionId, ...props }: UseGetInputsetYamlProps) =>
  useGet<void, void, GetInputsetYamlQueryParams, GetInputsetYamlPathParams>(
    (paramsInPath: GetInputsetYamlPathParams) => `/pipelines/execution/${paramsInPath.planExecutionId}/inputset`,
    { base: getConfig('pipeline/api'), pathParams: { planExecutionId }, ...props }
  )

/**
 * Gets  inputsetYaml
 */
export const getInputsetYamlPromise = (
  {
    planExecutionId,
    ...props
  }: GetUsingFetchProps<void, void, GetInputsetYamlQueryParams, GetInputsetYamlPathParams> & {
    planExecutionId: string
  },
  signal?: RequestInit['signal']
) =>
  getUsingFetch<void, void, GetInputsetYamlQueryParams, GetInputsetYamlPathParams>(
    getConfig('pipeline/api'),
    `/pipelines/execution/${planExecutionId}/inputset`,
    props,
    signal
  )

export interface GetStepsQueryParams {
  category: string
  module: string
  accountId?: string
}

export type GetStepsProps = Omit<GetProps<ResponseStepCategory, Failure | Error, GetStepsQueryParams, void>, 'path'>

/**
 * Get Steps for given module
 */
export const GetSteps = (props: GetStepsProps) => (
  <Get<ResponseStepCategory, Failure | Error, GetStepsQueryParams, void>
    path="/pipelines/steps"
    base={getConfig('pipeline/api')}
    {...props}
  />
)

export type UseGetStepsProps = Omit<
  UseGetProps<ResponseStepCategory, Failure | Error, GetStepsQueryParams, void>,
  'path'
>

/**
 * Get Steps for given module
 */
export const useGetSteps = (props: UseGetStepsProps) =>
  useGet<ResponseStepCategory, Failure | Error, GetStepsQueryParams, void>(`/pipelines/steps`, {
    base: getConfig('pipeline/api'),
    ...props
  })

/**
 * Get Steps for given module
 */
export const getStepsPromise = (
  props: GetUsingFetchProps<ResponseStepCategory, Failure | Error, GetStepsQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseStepCategory, Failure | Error, GetStepsQueryParams, void>(
    getConfig('pipeline/api'),
    `/pipelines/steps`,
    props,
    signal
  )

export interface CreatePipelineQueryParams {
  accountIdentifier: string
  orgIdentifier: string
  projectIdentifier: string
}

export type CreatePipelineProps = Omit<
  MutateProps<ResponseString, Failure | Error, CreatePipelineQueryParams, void, void>,
  'path' | 'verb'
>

/**
 * Create a Pipeline
 */
export const CreatePipeline = (props: CreatePipelineProps) => (
  <Mutate<ResponseString, Failure | Error, CreatePipelineQueryParams, void, void>
    verb="POST"
    path="/pipelines"
    base={getConfig('pipeline/api')}
    {...props}
  />
)

export type UseCreatePipelineProps = Omit<
  UseMutateProps<ResponseString, Failure | Error, CreatePipelineQueryParams, void, void>,
  'path' | 'verb'
>

/**
 * Create a Pipeline
 */
export const useCreatePipeline = (props: UseCreatePipelineProps) =>
  useMutate<ResponseString, Failure | Error, CreatePipelineQueryParams, void, void>('POST', `/pipelines`, {
    base: getConfig('pipeline/api'),
    ...props
  })

/**
 * Create a Pipeline
 */
export const createPipelinePromise = (
  props: MutateUsingFetchProps<ResponseString, Failure | Error, CreatePipelineQueryParams, void, void>,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<ResponseString, Failure | Error, CreatePipelineQueryParams, void, void>(
    'POST',
    getConfig('pipeline/api'),
    `/pipelines`,
    props,
    signal
  )

export interface PostPipelineExecuteWithInputSetYamlQueryParams {
  accountIdentifier: string
  orgIdentifier: string
  projectIdentifier: string
  useFQNIfError?: boolean
}

export interface PostPipelineExecuteWithInputSetYamlPathParams {
  identifier: string
}

export type PostPipelineExecuteWithInputSetYamlProps = Omit<
  MutateProps<
    ResponsePlanExecutionResponseDto,
    unknown,
    PostPipelineExecuteWithInputSetYamlQueryParams,
    void,
    PostPipelineExecuteWithInputSetYamlPathParams
  >,
  'path' | 'verb'
> &
  PostPipelineExecuteWithInputSetYamlPathParams

/**
 * Execute a pipeline with inputSet pipeline yaml
 */
export const PostPipelineExecuteWithInputSetYaml = ({
  identifier,
  ...props
}: PostPipelineExecuteWithInputSetYamlProps) => (
  <Mutate<
    ResponsePlanExecutionResponseDto,
    unknown,
    PostPipelineExecuteWithInputSetYamlQueryParams,
    void,
    PostPipelineExecuteWithInputSetYamlPathParams
  >
    verb="POST"
    path="/pipeline/execute/${identifier}"
    base={getConfig('pipeline/api')}
    {...props}
  />
)

export type UsePostPipelineExecuteWithInputSetYamlProps = Omit<
  UseMutateProps<
    ResponsePlanExecutionResponseDto,
    unknown,
    PostPipelineExecuteWithInputSetYamlQueryParams,
    void,
    PostPipelineExecuteWithInputSetYamlPathParams
  >,
  'path' | 'verb'
> &
  PostPipelineExecuteWithInputSetYamlPathParams

/**
 * Execute a pipeline with inputSet pipeline yaml
 */
export const usePostPipelineExecuteWithInputSetYaml = ({
  identifier,
  ...props
}: UsePostPipelineExecuteWithInputSetYamlProps) =>
  useMutate<
    ResponsePlanExecutionResponseDto,
    unknown,
    PostPipelineExecuteWithInputSetYamlQueryParams,
    void,
    PostPipelineExecuteWithInputSetYamlPathParams
  >(
    'POST',
    (paramsInPath: PostPipelineExecuteWithInputSetYamlPathParams) => `/pipeline/execute/${paramsInPath.identifier}`,
    { base: getConfig('pipeline/api'), pathParams: { identifier }, ...props }
  )

/**
 * Execute a pipeline with inputSet pipeline yaml
 */
export const postPipelineExecuteWithInputSetYamlPromise = (
  {
    identifier,
    ...props
  }: MutateUsingFetchProps<
    ResponsePlanExecutionResponseDto,
    unknown,
    PostPipelineExecuteWithInputSetYamlQueryParams,
    void,
    PostPipelineExecuteWithInputSetYamlPathParams
  > & { identifier: string },
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponsePlanExecutionResponseDto,
    unknown,
    PostPipelineExecuteWithInputSetYamlQueryParams,
    void,
    PostPipelineExecuteWithInputSetYamlPathParams
  >('POST', getConfig('pipeline/api'), `/pipeline/execute/${identifier}`, props, signal)

export interface PostPipelineExecuteWithInputSetListQueryParams {
  accountIdentifier: string
  orgIdentifier: string
  projectIdentifier: string
  useFQNIfError?: boolean
}

export interface PostPipelineExecuteWithInputSetListPathParams {
  identifier: string
}

export type PostPipelineExecuteWithInputSetListProps = Omit<
  MutateProps<
    ResponsePlanExecutionResponseDto,
    unknown,
    PostPipelineExecuteWithInputSetListQueryParams,
    MergeInputSetRequestRequestBody,
    PostPipelineExecuteWithInputSetListPathParams
  >,
  'path' | 'verb'
> &
  PostPipelineExecuteWithInputSetListPathParams

/**
 * Execute a pipeline with input set references list
 */
export const PostPipelineExecuteWithInputSetList = ({
  identifier,
  ...props
}: PostPipelineExecuteWithInputSetListProps) => (
  <Mutate<
    ResponsePlanExecutionResponseDto,
    unknown,
    PostPipelineExecuteWithInputSetListQueryParams,
    MergeInputSetRequestRequestBody,
    PostPipelineExecuteWithInputSetListPathParams
  >
    verb="POST"
    path="/pipeline/execute/${identifier}/inputSetList"
    base={getConfig('pipeline/api')}
    {...props}
  />
)

export type UsePostPipelineExecuteWithInputSetListProps = Omit<
  UseMutateProps<
    ResponsePlanExecutionResponseDto,
    unknown,
    PostPipelineExecuteWithInputSetListQueryParams,
    MergeInputSetRequestRequestBody,
    PostPipelineExecuteWithInputSetListPathParams
  >,
  'path' | 'verb'
> &
  PostPipelineExecuteWithInputSetListPathParams

/**
 * Execute a pipeline with input set references list
 */
export const usePostPipelineExecuteWithInputSetList = ({
  identifier,
  ...props
}: UsePostPipelineExecuteWithInputSetListProps) =>
  useMutate<
    ResponsePlanExecutionResponseDto,
    unknown,
    PostPipelineExecuteWithInputSetListQueryParams,
    MergeInputSetRequestRequestBody,
    PostPipelineExecuteWithInputSetListPathParams
  >(
    'POST',
    (paramsInPath: PostPipelineExecuteWithInputSetListPathParams) =>
      `/pipeline/execute/${paramsInPath.identifier}/inputSetList`,
    { base: getConfig('pipeline/api'), pathParams: { identifier }, ...props }
  )

/**
 * Execute a pipeline with input set references list
 */
export const postPipelineExecuteWithInputSetListPromise = (
  {
    identifier,
    ...props
  }: MutateUsingFetchProps<
    ResponsePlanExecutionResponseDto,
    unknown,
    PostPipelineExecuteWithInputSetListQueryParams,
    MergeInputSetRequestRequestBody,
    PostPipelineExecuteWithInputSetListPathParams
  > & { identifier: string },
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponsePlanExecutionResponseDto,
    unknown,
    PostPipelineExecuteWithInputSetListQueryParams,
    MergeInputSetRequestRequestBody,
    PostPipelineExecuteWithInputSetListPathParams
  >('POST', getConfig('pipeline/api'), `/pipeline/execute/${identifier}/inputSetList`, props, signal)

export interface HandleStageInterruptQueryParams {
  accountIdentifier: string
  orgIdentifier: string
  projectIdentifier: string
  interruptType:
    | 'Abort'
    | 'Pause'
    | 'Resume'
    | 'Ignore'
    | 'StageRollback'
    | 'StepGroupRollback'
    | 'MarkAsSuccess'
    | 'Retry'
}

export interface HandleStageInterruptPathParams {
  planExecutionId: string
  nodeExecutionId: string
}

export type HandleStageInterruptProps = Omit<
  MutateProps<
    ResponsePipelineExecutionInterrupt,
    unknown,
    HandleStageInterruptQueryParams,
    void,
    HandleStageInterruptPathParams
  >,
  'path' | 'verb'
> &
  HandleStageInterruptPathParams

/**
 * pause, resume or stop the stage executions
 */
export const HandleStageInterrupt = ({ planExecutionId, nodeExecutionId, ...props }: HandleStageInterruptProps) => (
  <Mutate<
    ResponsePipelineExecutionInterrupt,
    unknown,
    HandleStageInterruptQueryParams,
    void,
    HandleStageInterruptPathParams
  >
    verb="PUT"
    path="/pipeline/execute/interrupt/${planExecutionId}/${nodeExecutionId}"
    base={getConfig('pipeline/api')}
    {...props}
  />
)

export type UseHandleStageInterruptProps = Omit<
  UseMutateProps<
    ResponsePipelineExecutionInterrupt,
    unknown,
    HandleStageInterruptQueryParams,
    void,
    HandleStageInterruptPathParams
  >,
  'path' | 'verb'
> &
  HandleStageInterruptPathParams

/**
 * pause, resume or stop the stage executions
 */
export const useHandleStageInterrupt = ({ planExecutionId, nodeExecutionId, ...props }: UseHandleStageInterruptProps) =>
  useMutate<
    ResponsePipelineExecutionInterrupt,
    unknown,
    HandleStageInterruptQueryParams,
    void,
    HandleStageInterruptPathParams
  >(
    'PUT',
    (paramsInPath: HandleStageInterruptPathParams) =>
      `/pipeline/execute/interrupt/${paramsInPath.planExecutionId}/${paramsInPath.nodeExecutionId}`,
    { base: getConfig('pipeline/api'), pathParams: { planExecutionId, nodeExecutionId }, ...props }
  )

/**
 * pause, resume or stop the stage executions
 */
export const handleStageInterruptPromise = (
  {
    planExecutionId,
    nodeExecutionId,
    ...props
  }: MutateUsingFetchProps<
    ResponsePipelineExecutionInterrupt,
    unknown,
    HandleStageInterruptQueryParams,
    void,
    HandleStageInterruptPathParams
  > & { planExecutionId: string; nodeExecutionId: string },
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponsePipelineExecutionInterrupt,
    unknown,
    HandleStageInterruptQueryParams,
    void,
    HandleStageInterruptPathParams
  >(
    'PUT',
    getConfig('pipeline/api'),
    `/pipeline/execute/interrupt/${planExecutionId}/${nodeExecutionId}`,
    props,
    signal
  )

export interface HandleManualInterventionInterruptQueryParams {
  accountIdentifier: string
  orgIdentifier: string
  projectIdentifier: string
  interruptType:
    | 'Abort'
    | 'Pause'
    | 'Resume'
    | 'Ignore'
    | 'StageRollback'
    | 'StepGroupRollback'
    | 'MarkAsSuccess'
    | 'Retry'
}

export interface HandleManualInterventionInterruptPathParams {
  planExecutionId: string
  nodeExecutionId: string
}

export type HandleManualInterventionInterruptProps = Omit<
  MutateProps<
    ResponsePipelineExecutionInterrupt,
    unknown,
    HandleManualInterventionInterruptQueryParams,
    void,
    HandleManualInterventionInterruptPathParams
  >,
  'path' | 'verb'
> &
  HandleManualInterventionInterruptPathParams

/**
 * Ignore,Abort,MarkAsSuccess,Retry on post manual intervention
 */
export const HandleManualInterventionInterrupt = ({
  planExecutionId,
  nodeExecutionId,
  ...props
}: HandleManualInterventionInterruptProps) => (
  <Mutate<
    ResponsePipelineExecutionInterrupt,
    unknown,
    HandleManualInterventionInterruptQueryParams,
    void,
    HandleManualInterventionInterruptPathParams
  >
    verb="PUT"
    path="/pipeline/execute/manualIntervention/interrupt/${planExecutionId}/${nodeExecutionId}"
    base={getConfig('pipeline/api')}
    {...props}
  />
)

export type UseHandleManualInterventionInterruptProps = Omit<
  UseMutateProps<
    ResponsePipelineExecutionInterrupt,
    unknown,
    HandleManualInterventionInterruptQueryParams,
    void,
    HandleManualInterventionInterruptPathParams
  >,
  'path' | 'verb'
> &
  HandleManualInterventionInterruptPathParams

/**
 * Ignore,Abort,MarkAsSuccess,Retry on post manual intervention
 */
export const useHandleManualInterventionInterrupt = ({
  planExecutionId,
  nodeExecutionId,
  ...props
}: UseHandleManualInterventionInterruptProps) =>
  useMutate<
    ResponsePipelineExecutionInterrupt,
    unknown,
    HandleManualInterventionInterruptQueryParams,
    void,
    HandleManualInterventionInterruptPathParams
  >(
    'PUT',
    (paramsInPath: HandleManualInterventionInterruptPathParams) =>
      `/pipeline/execute/manualIntervention/interrupt/${paramsInPath.planExecutionId}/${paramsInPath.nodeExecutionId}`,
    { base: getConfig('pipeline/api'), pathParams: { planExecutionId, nodeExecutionId }, ...props }
  )

/**
 * Ignore,Abort,MarkAsSuccess,Retry on post manual intervention
 */
export const handleManualInterventionInterruptPromise = (
  {
    planExecutionId,
    nodeExecutionId,
    ...props
  }: MutateUsingFetchProps<
    ResponsePipelineExecutionInterrupt,
    unknown,
    HandleManualInterventionInterruptQueryParams,
    void,
    HandleManualInterventionInterruptPathParams
  > & { planExecutionId: string; nodeExecutionId: string },
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponsePipelineExecutionInterrupt,
    unknown,
    HandleManualInterventionInterruptQueryParams,
    void,
    HandleManualInterventionInterruptPathParams
  >(
    'PUT',
    getConfig('pipeline/api'),
    `/pipeline/execute/manualIntervention/interrupt/${planExecutionId}/${nodeExecutionId}`,
    props,
    signal
  )

export interface StartPreflightCheckQueryParams {
  accountIdentifier: string
  orgIdentifier: string
  projectIdentifier: string
  pipelineIdentifier?: string
}

export type StartPreflightCheckProps = Omit<
  MutateProps<ResponseString, unknown, StartPreflightCheckQueryParams, void, void>,
  'path' | 'verb'
>

/**
 * initiate pre flight check
 */
export const StartPreflightCheck = (props: StartPreflightCheckProps) => (
  <Mutate<ResponseString, unknown, StartPreflightCheckQueryParams, void, void>
    verb="POST"
    path="/pipeline/execute/preflightCheck"
    base={getConfig('pipeline/api')}
    {...props}
  />
)

export type UseStartPreflightCheckProps = Omit<
  UseMutateProps<ResponseString, unknown, StartPreflightCheckQueryParams, void, void>,
  'path' | 'verb'
>

/**
 * initiate pre flight check
 */
export const useStartPreflightCheck = (props: UseStartPreflightCheckProps) =>
  useMutate<ResponseString, unknown, StartPreflightCheckQueryParams, void, void>(
    'POST',
    `/pipeline/execute/preflightCheck`,
    { base: getConfig('pipeline/api'), ...props }
  )

/**
 * initiate pre flight check
 */
export const startPreflightCheckPromise = (
  props: MutateUsingFetchProps<ResponseString, unknown, StartPreflightCheckQueryParams, void, void>,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<ResponseString, unknown, StartPreflightCheckQueryParams, void, void>(
    'POST',
    getConfig('pipeline/api'),
    `/pipeline/execute/preflightCheck`,
    props,
    signal
  )

export interface GetPreflightCheckResponseQueryParams {
  accountIdentifier: string
  orgIdentifier: string
  projectIdentifier: string
  preflightCheckId: string
}

export type GetPreflightCheckResponseProps = Omit<
  GetProps<ResponsePreFlightDTO, unknown, GetPreflightCheckResponseQueryParams, void>,
  'path'
>

/**
 * get preflight check response
 */
export const GetPreflightCheckResponse = (props: GetPreflightCheckResponseProps) => (
  <Get<ResponsePreFlightDTO, unknown, GetPreflightCheckResponseQueryParams, void>
    path="/pipeline/execute/getPreflightCheckResponse"
    base={getConfig('pipeline/api')}
    {...props}
  />
)

export type UseGetPreflightCheckResponseProps = Omit<
  UseGetProps<ResponsePreFlightDTO, unknown, GetPreflightCheckResponseQueryParams, void>,
  'path'
>

/**
 * get preflight check response
 */
export const useGetPreflightCheckResponse = (props: UseGetPreflightCheckResponseProps) =>
  useGet<ResponsePreFlightDTO, unknown, GetPreflightCheckResponseQueryParams, void>(
    `/pipeline/execute/getPreflightCheckResponse`,
    { base: getConfig('pipeline/api'), ...props }
  )

/**
 * get preflight check response
 */
export const getPreflightCheckResponsePromise = (
  props: GetUsingFetchProps<ResponsePreFlightDTO, unknown, GetPreflightCheckResponseQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponsePreFlightDTO, unknown, GetPreflightCheckResponseQueryParams, void>(
    getConfig('pipeline/api'),
    `/pipeline/execute/getPreflightCheckResponse`,
    props,
    signal
  )

export type RunSchemaOnDbProps = Omit<GetProps<ResponseString, unknown, void, void>, 'path'>

/**
 * Run a schema on db.
 */
export const RunSchemaOnDb = (props: RunSchemaOnDbProps) => (
  <Get<ResponseString, unknown, void, void>
    path="/pipeline/execute/internal/runSchema"
    base={getConfig('pipeline/api')}
    {...props}
  />
)

export type UseRunSchemaOnDbProps = Omit<UseGetProps<ResponseString, unknown, void, void>, 'path'>

/**
 * Run a schema on db.
 */
export const useRunSchemaOnDb = (props: UseRunSchemaOnDbProps) =>
  useGet<ResponseString, unknown, void, void>(`/pipeline/execute/internal/runSchema`, {
    base: getConfig('pipeline/api'),
    ...props
  })

/**
 * Run a schema on db.
 */
export const runSchemaOnDbPromise = (
  props: GetUsingFetchProps<ResponseString, unknown, void, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseString, unknown, void, void>(
    getConfig('pipeline/api'),
    `/pipeline/execute/internal/runSchema`,
    props,
    signal
  )

export interface HandleInterruptQueryParams {
  accountIdentifier: string
  orgIdentifier: string
  projectIdentifier: string
  interruptType:
    | 'Abort'
    | 'Pause'
    | 'Resume'
    | 'Ignore'
    | 'StageRollback'
    | 'StepGroupRollback'
    | 'MarkAsSuccess'
    | 'Retry'
}

export interface HandleInterruptPathParams {
  planExecutionId: string
}

export type HandleInterruptProps = Omit<
  MutateProps<ResponsePipelineExecutionInterrupt, unknown, HandleInterruptQueryParams, void, HandleInterruptPathParams>,
  'path' | 'verb'
> &
  HandleInterruptPathParams

/**
 * pause, resume or stop the pipeline executions
 */
export const HandleInterrupt = ({ planExecutionId, ...props }: HandleInterruptProps) => (
  <Mutate<ResponsePipelineExecutionInterrupt, unknown, HandleInterruptQueryParams, void, HandleInterruptPathParams>
    verb="PUT"
    path="/pipeline/execute/interrupt/${planExecutionId}"
    base={getConfig('pipeline/api')}
    {...props}
  />
)

export type UseHandleInterruptProps = Omit<
  UseMutateProps<
    ResponsePipelineExecutionInterrupt,
    unknown,
    HandleInterruptQueryParams,
    void,
    HandleInterruptPathParams
  >,
  'path' | 'verb'
> &
  HandleInterruptPathParams

/**
 * pause, resume or stop the pipeline executions
 */
export const useHandleInterrupt = ({ planExecutionId, ...props }: UseHandleInterruptProps) =>
  useMutate<ResponsePipelineExecutionInterrupt, unknown, HandleInterruptQueryParams, void, HandleInterruptPathParams>(
    'PUT',
    (paramsInPath: HandleInterruptPathParams) => `/pipeline/execute/interrupt/${paramsInPath.planExecutionId}`,
    { base: getConfig('pipeline/api'), pathParams: { planExecutionId }, ...props }
  )

/**
 * pause, resume or stop the pipeline executions
 */
export const handleInterruptPromise = (
  {
    planExecutionId,
    ...props
  }: MutateUsingFetchProps<
    ResponsePipelineExecutionInterrupt,
    unknown,
    HandleInterruptQueryParams,
    void,
    HandleInterruptPathParams
  > & { planExecutionId: string },
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponsePipelineExecutionInterrupt,
    unknown,
    HandleInterruptQueryParams,
    void,
    HandleInterruptPathParams
  >('PUT', getConfig('pipeline/api'), `/pipeline/execute/interrupt/${planExecutionId}`, props, signal)

export interface GetResourceConstraintsExecutionInfoQueryParams {
  accountId: string
  resourceUnit: string
}

export type GetResourceConstraintsExecutionInfoProps = Omit<
  GetProps<
    ResponseListResourceConstraintExecutionInfo,
    Failure | Error,
    GetResourceConstraintsExecutionInfoQueryParams,
    void
  >,
  'path'
>

/**
 * Gets resource constraints execution info list
 */
export const GetResourceConstraintsExecutionInfo = (props: GetResourceConstraintsExecutionInfoProps) => (
  <Get<
    ResponseListResourceConstraintExecutionInfo,
    Failure | Error,
    GetResourceConstraintsExecutionInfoQueryParams,
    void
  >
    path="/resource-constraints/executionInfo"
    base={getConfig('pipeline/api')}
    {...props}
  />
)

export type UseGetResourceConstraintsExecutionInfoProps = Omit<
  UseGetProps<
    ResponseListResourceConstraintExecutionInfo,
    Failure | Error,
    GetResourceConstraintsExecutionInfoQueryParams,
    void
  >,
  'path'
>

/**
 * Gets resource constraints execution info list
 */
export const useGetResourceConstraintsExecutionInfo = (props: UseGetResourceConstraintsExecutionInfoProps) =>
  useGet<
    ResponseListResourceConstraintExecutionInfo,
    Failure | Error,
    GetResourceConstraintsExecutionInfoQueryParams,
    void
  >(`/resource-constraints/executionInfo`, { base: getConfig('pipeline/api'), ...props })

/**
 * Gets resource constraints execution info list
 */
export const getResourceConstraintsExecutionInfoPromise = (
  props: GetUsingFetchProps<
    ResponseListResourceConstraintExecutionInfo,
    Failure | Error,
    GetResourceConstraintsExecutionInfoQueryParams,
    void
  >,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<
    ResponseListResourceConstraintExecutionInfo,
    Failure | Error,
    GetResourceConstraintsExecutionInfoQueryParams,
    void
  >(getConfig('pipeline/api'), `/resource-constraints/executionInfo`, props, signal)

export interface GetSchemaYamlQueryParams {
  entityType:
    | 'Projects'
    | 'Pipelines'
    | 'PipelineSteps'
    | 'Connectors'
    | 'Secrets'
    | 'Service'
    | 'Environment'
    | 'InputSets'
    | 'CvConfig'
    | 'Delegates'
    | 'DelegateConfigurations'
    | 'CvVerificationJob'
    | 'IntegrationStage'
    | 'IntegrationSteps'
    | 'CvKubernetesActivitySource'
    | 'DeploymentSteps'
    | 'DeploymentStage'
    | 'ApprovalStage'
    | 'Triggers'
  projectIdentifier?: string
  orgIdentifier?: string
  scope?: 'account' | 'org' | 'project' | 'unknown'
  identifier?: string
}

export type GetSchemaYamlProps = Omit<
  GetProps<ResponseJsonNode, Failure | Error, GetSchemaYamlQueryParams, void>,
  'path'
>

/**
 * Get Yaml Schema
 */
export const GetSchemaYaml = (props: GetSchemaYamlProps) => (
  <Get<ResponseJsonNode, Failure | Error, GetSchemaYamlQueryParams, void>
    path="/yaml-schema"
    base={getConfig('pipeline/api')}
    {...props}
  />
)

export type UseGetSchemaYamlProps = Omit<
  UseGetProps<ResponseJsonNode, Failure | Error, GetSchemaYamlQueryParams, void>,
  'path'
>

/**
 * Get Yaml Schema
 */
export const useGetSchemaYaml = (props: UseGetSchemaYamlProps) =>
  useGet<ResponseJsonNode, Failure | Error, GetSchemaYamlQueryParams, void>(`/yaml-schema`, {
    base: getConfig('pipeline/api'),
    ...props
  })

/**
 * Get Yaml Schema
 */
export const getSchemaYamlPromise = (
  props: GetUsingFetchProps<ResponseJsonNode, Failure | Error, GetSchemaYamlQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseJsonNode, Failure | Error, GetSchemaYamlQueryParams, void>(
    getConfig('pipeline/api'),
    `/yaml-schema`,
    props,
    signal
  )

export type GetVersionInfoProps = Omit<GetProps<RestResponseVersionPackage, unknown, void, void>, 'path'>

/**
 * Get Version Info
 */
export const GetVersionInfo = (props: GetVersionInfoProps) => (
  <Get<RestResponseVersionPackage, unknown, void, void> path="/version" base={getConfig('pipeline/api')} {...props} />
)

export type UseGetVersionInfoProps = Omit<UseGetProps<RestResponseVersionPackage, unknown, void, void>, 'path'>

/**
 * Get Version Info
 */
export const useGetVersionInfo = (props: UseGetVersionInfoProps) =>
  useGet<RestResponseVersionPackage, unknown, void, void>(`/version`, { base: getConfig('pipeline/api'), ...props })

/**
 * Get Version Info
 */
export const getVersionInfoPromise = (
  props: GetUsingFetchProps<RestResponseVersionPackage, unknown, void, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<RestResponseVersionPackage, unknown, void, void>(getConfig('pipeline/api'), `/version`, props, signal)
