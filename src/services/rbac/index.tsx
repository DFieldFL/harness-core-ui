/* Generated by restful-react */

import React from 'react'
import { Get, GetProps, useGet, UseGetProps, Mutate, MutateProps, useMutate, UseMutateProps } from 'restful-react'

import { getConfig, getUsingFetch, mutateUsingFetch, GetUsingFetchProps, MutateUsingFetchProps } from '../config'
export interface AccessCheckResponse {
  principal?: Principal
  accessControlList?: AccessControl[]
}

export interface AccessControl {
  permission?: string
  resourceScope?: ResourceScope
  resourceType?: string
  resourceIdentifier?: string
  permitted?: boolean
}

export interface Principal {
  identifier: string
  type: 'USER' | 'USER_GROUP' | 'API_KEY' | 'SERVICE'
}

export interface ResourceScope {
  accountIdentifier?: string
  orgIdentifier?: string
  projectIdentifier?: string
}

export interface Response {
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
  data?: { [key: string]: any }
  metaData?: { [key: string]: any }
  correlationId?: string
}

export interface ResponseAccessCheckResponse {
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
  data?: AccessCheckResponse
  metaData?: { [key: string]: any }
  correlationId?: string
}

export interface Failure {
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
  code?:
    | 'DEFAULT_ERROR_CODE'
    | 'INVALID_ARGUMENT'
    | 'INVALID_EMAIL'
    | 'DOMAIN_NOT_ALLOWED_TO_REGISTER'
    | 'USER_ALREADY_REGISTERED'
    | 'USER_INVITATION_DOES_NOT_EXIST'
    | 'USER_DOES_NOT_EXIST'
    | 'USER_INVITE_OPERATION_FAILED'
    | 'USER_DISABLED'
    | 'ACCOUNT_DOES_NOT_EXIST'
    | 'INACTIVE_ACCOUNT'
    | 'ACCOUNT_MIGRATED'
    | 'USER_DOMAIN_NOT_ALLOWED'
    | 'MAX_FAILED_ATTEMPT_COUNT_EXCEEDED'
    | 'RESOURCE_NOT_FOUND'
    | 'ROLE_DOES_NOT_EXIST'
    | 'EMAIL_NOT_VERIFIED'
    | 'EMAIL_VERIFICATION_TOKEN_NOT_FOUND'
    | 'INVALID_TOKEN'
    | 'INVALID_CAPTCHA_TOKEN'
    | 'NOT_ACCOUNT_MGR_NOR_HAS_ALL_APP_ACCESS'
    | 'EXPIRED_TOKEN'
    | 'TOKEN_ALREADY_REFRESHED_ONCE'
    | 'ACCESS_DENIED'
    | 'NG_ACCESS_DENIED'
    | 'INVALID_CREDENTIAL'
    | 'INVALID_KEY'
    | 'INVALID_KEYPATH'
    | 'INVALID_VARIABLE'
    | 'UNKNOWN_HOST'
    | 'UNREACHABLE_HOST'
    | 'INVALID_PORT'
    | 'SSH_SESSION_TIMEOUT'
    | 'SOCKET_CONNECTION_ERROR'
    | 'SOCKET_CONNECTION_TIMEOUT'
    | 'CONNECTION_TIMEOUT'
    | 'SSH_CONNECTION_ERROR'
    | 'USER_GROUP_ERROR'
    | 'INVALID_EXECUTION_ID'
    | 'ERROR_IN_GETTING_CHANNEL_STREAMS'
    | 'UNEXPECTED'
    | 'UNKNOWN_ERROR'
    | 'UNKNOWN_EXECUTOR_TYPE_ERROR'
    | 'DUPLICATE_STATE_NAMES'
    | 'TRANSITION_NOT_LINKED'
    | 'TRANSITION_TO_INCORRECT_STATE'
    | 'TRANSITION_TYPE_NULL'
    | 'STATES_WITH_DUP_TRANSITIONS'
    | 'BARRIERS_NOT_RUNNING_CONCURRENTLY'
    | 'NON_FORK_STATES'
    | 'NON_REPEAT_STATES'
    | 'INITIAL_STATE_NOT_DEFINED'
    | 'FILE_INTEGRITY_CHECK_FAILED'
    | 'INVALID_URL'
    | 'FILE_DOWNLOAD_FAILED'
    | 'PLATFORM_SOFTWARE_DELETE_ERROR'
    | 'INVALID_CSV_FILE'
    | 'INVALID_REQUEST'
    | 'INVALID_INFRA_STATE'
    | 'PIPELINE_ALREADY_TRIGGERED'
    | 'NON_EXISTING_PIPELINE'
    | 'DUPLICATE_COMMAND_NAMES'
    | 'INVALID_PIPELINE'
    | 'COMMAND_DOES_NOT_EXIST'
    | 'DUPLICATE_ARTIFACTSTREAM_NAMES'
    | 'DUPLICATE_HOST_NAMES'
    | 'STATE_NOT_FOR_TYPE'
    | 'STATE_MACHINE_ISSUE'
    | 'STATE_DISCONTINUE_FAILED'
    | 'STATE_PAUSE_FAILED'
    | 'PAUSE_ALL_ALREADY'
    | 'RESUME_ALL_ALREADY'
    | 'ROLLBACK_ALREADY'
    | 'ABORT_ALL_ALREADY'
    | 'RETRY_FAILED'
    | 'UNKNOWN_ARTIFACT_TYPE'
    | 'UNKNOWN_STAGE_ELEMENT_WRAPPER_TYPE'
    | 'INIT_TIMEOUT'
    | 'LICENSE_EXPIRED'
    | 'NOT_LICENSED'
    | 'REQUEST_TIMEOUT'
    | 'WORKFLOW_ALREADY_TRIGGERED'
    | 'JENKINS_ERROR'
    | 'INVALID_ARTIFACT_SOURCE'
    | 'INVALID_ARTIFACT_SERVER'
    | 'INVALID_CLOUD_PROVIDER'
    | 'UPDATE_NOT_ALLOWED'
    | 'DELETE_NOT_ALLOWED'
    | 'APPDYNAMICS_CONFIGURATION_ERROR'
    | 'APM_CONFIGURATION_ERROR'
    | 'SPLUNK_CONFIGURATION_ERROR'
    | 'ELK_CONFIGURATION_ERROR'
    | 'LOGZ_CONFIGURATION_ERROR'
    | 'SUMO_CONFIGURATION_ERROR'
    | 'INSTANA_CONFIGURATION_ERROR'
    | 'APPDYNAMICS_ERROR'
    | 'STACKDRIVER_ERROR'
    | 'STACKDRIVER_CONFIGURATION_ERROR'
    | 'NEWRELIC_CONFIGURATION_ERROR'
    | 'NEWRELIC_ERROR'
    | 'DYNA_TRACE_CONFIGURATION_ERROR'
    | 'DYNA_TRACE_ERROR'
    | 'CLOUDWATCH_ERROR'
    | 'CLOUDWATCH_CONFIGURATION_ERROR'
    | 'PROMETHEUS_CONFIGURATION_ERROR'
    | 'DATA_DOG_CONFIGURATION_ERROR'
    | 'SERVICE_GUARD_CONFIGURATION_ERROR'
    | 'ENCRYPTION_NOT_CONFIGURED'
    | 'UNAVAILABLE_DELEGATES'
    | 'WORKFLOW_EXECUTION_IN_PROGRESS'
    | 'PIPELINE_EXECUTION_IN_PROGRESS'
    | 'AWS_ACCESS_DENIED'
    | 'AWS_CLUSTER_NOT_FOUND'
    | 'AWS_SERVICE_NOT_FOUND'
    | 'INVALID_YAML_PAYLOAD'
    | 'UNRECOGNIZED_YAML_FIELDS'
    | 'COULD_NOT_MAP_BEFORE_YAML'
    | 'MISSING_BEFORE_YAML'
    | 'MISSING_YAML'
    | 'NON_EMPTY_DELETIONS'
    | 'GENERAL_YAML_ERROR'
    | 'GENERAL_YAML_INFO'
    | 'YAML_GIT_SYNC_ERROR'
    | 'GIT_CONNECTION_ERROR'
    | 'GIT_ERROR'
    | 'ARTIFACT_SERVER_ERROR'
    | 'ENCRYPT_DECRYPT_ERROR'
    | 'SECRET_MANAGEMENT_ERROR'
    | 'KMS_OPERATION_ERROR'
    | 'GCP_KMS_OPERATION_ERROR'
    | 'VAULT_OPERATION_ERROR'
    | 'AWS_SECRETS_MANAGER_OPERATION_ERROR'
    | 'AZURE_KEY_VAULT_OPERATION_ERROR'
    | 'CYBERARK_OPERATION_ERROR'
    | 'UNSUPPORTED_OPERATION_EXCEPTION'
    | 'FEATURE_UNAVAILABLE'
    | 'GENERAL_ERROR'
    | 'BASELINE_CONFIGURATION_ERROR'
    | 'SAML_IDP_CONFIGURATION_NOT_AVAILABLE'
    | 'INVALID_AUTHENTICATION_MECHANISM'
    | 'INVALID_SAML_CONFIGURATION'
    | 'INVALID_OAUTH_CONFIGURATION'
    | 'INVALID_LDAP_CONFIGURATION'
    | 'USER_GROUP_SYNC_FAILURE'
    | 'USER_GROUP_ALREADY_EXIST'
    | 'INVALID_TWO_FACTOR_AUTHENTICATION_CONFIGURATION'
    | 'EXPLANATION'
    | 'HINT'
    | 'NOT_WHITELISTED_IP'
    | 'INVALID_TOTP_TOKEN'
    | 'EMAIL_FAILED'
    | 'SSL_HANDSHAKE_FAILED'
    | 'NO_APPS_ASSIGNED'
    | 'INVALID_INFRA_CONFIGURATION'
    | 'TEMPLATES_LINKED'
    | 'USER_HAS_NO_PERMISSIONS'
    | 'USER_NOT_AUTHORIZED'
    | 'USER_ALREADY_PRESENT'
    | 'INVALID_USAGE_RESTRICTION'
    | 'USAGE_RESTRICTION_ERROR'
    | 'STATE_EXECUTION_INSTANCE_NOT_FOUND'
    | 'DELEGATE_TASK_RETRY'
    | 'KUBERNETES_YAML_ERROR'
    | 'SAVE_FILE_INTO_GCP_STORAGE_FAILED'
    | 'READ_FILE_FROM_GCP_STORAGE_FAILED'
    | 'USAGE_LIMITS_EXCEEDED'
    | 'EVENT_PUBLISH_FAILED'
    | 'JIRA_ERROR'
    | 'EXPRESSION_EVALUATION_FAILED'
    | 'KUBERNETES_VALUES_ERROR'
    | 'KUBERNETES_CLUSTER_ERROR'
    | 'INCORRECT_SIGN_IN_MECHANISM'
    | 'OAUTH_LOGIN_FAILED'
    | 'INVALID_TERRAFORM_TARGETS_REQUEST'
    | 'TERRAFORM_EXECUTION_ERROR'
    | 'FILE_READ_FAILED'
    | 'FILE_SIZE_EXCEEDS_LIMIT'
    | 'CLUSTER_NOT_FOUND'
    | 'MARKETPLACE_TOKEN_NOT_FOUND'
    | 'INVALID_MARKETPLACE_TOKEN'
    | 'INVALID_TICKETING_SERVER'
    | 'SERVICENOW_ERROR'
    | 'PASSWORD_EXPIRED'
    | 'USER_LOCKED'
    | 'PASSWORD_STRENGTH_CHECK_FAILED'
    | 'ACCOUNT_DISABLED'
    | 'INVALID_ACCOUNT_PERMISSION'
    | 'PAGERDUTY_ERROR'
    | 'HEALTH_ERROR'
    | 'SAML_TEST_SUCCESS_MECHANISM_NOT_ENABLED'
    | 'DOMAIN_WHITELIST_FILTER_CHECK_FAILED'
    | 'INVALID_DASHBOARD_UPDATE_REQUEST'
    | 'DUPLICATE_FIELD'
    | 'INVALID_AZURE_VAULT_CONFIGURATION'
    | 'USER_NOT_AUTHORIZED_DUE_TO_USAGE_RESTRICTIONS'
    | 'INVALID_ROLLBACK'
    | 'SUMO_DATA_COLLECTION_ERROR'
    | 'DEPLOYMENT_GOVERNANCE_ERROR'
    | 'BATCH_PROCESSING_ERROR'
    | 'GRAPHQL_ERROR'
    | 'FILE_CREATE_ERROR'
    | 'ILLEGAL_STATE'
    | 'GIT_DIFF_COMMIT_NOT_IN_ORDER'
    | 'FAILED_TO_ACQUIRE_PERSISTENT_LOCK'
    | 'FAILED_TO_ACQUIRE_NON_PERSISTENT_LOCK'
    | 'POD_NOT_FOUND_ERROR'
    | 'COMMAND_EXECUTION_ERROR'
    | 'REGISTRY_EXCEPTION'
    | 'ENGINE_INTERRUPT_PROCESSING_EXCEPTION'
    | 'ENGINE_IO_EXCEPTION'
    | 'ENGINE_OUTCOME_EXCEPTION'
    | 'ENGINE_SWEEPING_OUTPUT_EXCEPTION'
    | 'CACHE_NOT_FOUND_EXCEPTION'
    | 'ENGINE_ENTITY_UPDATE_EXCEPTION'
    | 'SHELL_EXECUTION_EXCEPTION'
    | 'TEMPLATE_NOT_FOUND'
    | 'AZURE_SERVICE_EXCEPTION'
    | 'AZURE_CLIENT_EXCEPTION'
    | 'GIT_UNSEEN_REMOTE_HEAD_COMMIT'
    | 'TIMEOUT_ENGINE_EXCEPTION'
    | 'NO_AVAILABLE_DELEGATES'
    | 'NO_INSTALLED_DELEGATES'
    | 'DUPLICATE_DELEGATE_EXCEPTION'
    | 'GCP_MARKETPLACE_EXCEPTION'
    | 'MISSING_DEFAULT_GOOGLE_CREDENTIALS'
    | 'INCORRECT_DEFAULT_GOOGLE_CREDENTIALS'
    | 'OPTIMISTIC_LOCKING_EXCEPTION'
    | 'NG_PIPELINE_EXECUTION_EXCEPTION'
    | 'NG_PIPELINE_CREATE_EXCEPTION'
    | 'RESOURCE_NOT_FOUND_EXCEPTION'
    | 'PMS_INITIALIZE_SDK_EXCEPTION'
    | 'UNEXPECTED_SNIPPET_EXCEPTION'
    | 'UNEXPECTED_SCHEMA_EXCEPTION'
    | 'CONNECTOR_VALIDATION_EXCEPTION'
    | 'GCP_SECRET_MANAGER_OPERATION_ERROR'
    | 'GCP_SECRET_OPERATION_ERROR'
    | 'GIT_OPERATION_ERROR'
    | 'TASK_FAILURE_ERROR'
    | 'INSTANCE_STATS_PROCESS_ERROR'
    | 'INSTANCE_STATS_MIGRATION_ERROR'
    | 'DEPLOYMENT_MIGRATION_ERROR'
    | 'INSTANCE_STATS_AGGREGATION_ERROR'
    | 'UNRESOLVED_EXPRESSIONS_ERROR'
    | 'KRYO_HANDLER_NOT_FOUND_ERROR'
    | 'DELEGATE_ERROR_HANDLER_EXCEPTION'
    | 'UNEXPECTED_TYPE_ERROR'
    | 'EXCEPTION_HANDLER_NOT_FOUND'
    | 'CONNECTOR_NOT_FOUND_EXCEPTION'
    | 'GCP_SERVER_ERROR'
  message?: string
  correlationId?: string
  errors?: ValidationError[]
}

export interface ValidationError {
  fieldId?: string
  error?: string
}

export interface Error {
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
  code?:
    | 'DEFAULT_ERROR_CODE'
    | 'INVALID_ARGUMENT'
    | 'INVALID_EMAIL'
    | 'DOMAIN_NOT_ALLOWED_TO_REGISTER'
    | 'USER_ALREADY_REGISTERED'
    | 'USER_INVITATION_DOES_NOT_EXIST'
    | 'USER_DOES_NOT_EXIST'
    | 'USER_INVITE_OPERATION_FAILED'
    | 'USER_DISABLED'
    | 'ACCOUNT_DOES_NOT_EXIST'
    | 'INACTIVE_ACCOUNT'
    | 'ACCOUNT_MIGRATED'
    | 'USER_DOMAIN_NOT_ALLOWED'
    | 'MAX_FAILED_ATTEMPT_COUNT_EXCEEDED'
    | 'RESOURCE_NOT_FOUND'
    | 'ROLE_DOES_NOT_EXIST'
    | 'EMAIL_NOT_VERIFIED'
    | 'EMAIL_VERIFICATION_TOKEN_NOT_FOUND'
    | 'INVALID_TOKEN'
    | 'INVALID_CAPTCHA_TOKEN'
    | 'NOT_ACCOUNT_MGR_NOR_HAS_ALL_APP_ACCESS'
    | 'EXPIRED_TOKEN'
    | 'TOKEN_ALREADY_REFRESHED_ONCE'
    | 'ACCESS_DENIED'
    | 'NG_ACCESS_DENIED'
    | 'INVALID_CREDENTIAL'
    | 'INVALID_KEY'
    | 'INVALID_KEYPATH'
    | 'INVALID_VARIABLE'
    | 'UNKNOWN_HOST'
    | 'UNREACHABLE_HOST'
    | 'INVALID_PORT'
    | 'SSH_SESSION_TIMEOUT'
    | 'SOCKET_CONNECTION_ERROR'
    | 'SOCKET_CONNECTION_TIMEOUT'
    | 'CONNECTION_TIMEOUT'
    | 'SSH_CONNECTION_ERROR'
    | 'USER_GROUP_ERROR'
    | 'INVALID_EXECUTION_ID'
    | 'ERROR_IN_GETTING_CHANNEL_STREAMS'
    | 'UNEXPECTED'
    | 'UNKNOWN_ERROR'
    | 'UNKNOWN_EXECUTOR_TYPE_ERROR'
    | 'DUPLICATE_STATE_NAMES'
    | 'TRANSITION_NOT_LINKED'
    | 'TRANSITION_TO_INCORRECT_STATE'
    | 'TRANSITION_TYPE_NULL'
    | 'STATES_WITH_DUP_TRANSITIONS'
    | 'BARRIERS_NOT_RUNNING_CONCURRENTLY'
    | 'NON_FORK_STATES'
    | 'NON_REPEAT_STATES'
    | 'INITIAL_STATE_NOT_DEFINED'
    | 'FILE_INTEGRITY_CHECK_FAILED'
    | 'INVALID_URL'
    | 'FILE_DOWNLOAD_FAILED'
    | 'PLATFORM_SOFTWARE_DELETE_ERROR'
    | 'INVALID_CSV_FILE'
    | 'INVALID_REQUEST'
    | 'INVALID_INFRA_STATE'
    | 'PIPELINE_ALREADY_TRIGGERED'
    | 'NON_EXISTING_PIPELINE'
    | 'DUPLICATE_COMMAND_NAMES'
    | 'INVALID_PIPELINE'
    | 'COMMAND_DOES_NOT_EXIST'
    | 'DUPLICATE_ARTIFACTSTREAM_NAMES'
    | 'DUPLICATE_HOST_NAMES'
    | 'STATE_NOT_FOR_TYPE'
    | 'STATE_MACHINE_ISSUE'
    | 'STATE_DISCONTINUE_FAILED'
    | 'STATE_PAUSE_FAILED'
    | 'PAUSE_ALL_ALREADY'
    | 'RESUME_ALL_ALREADY'
    | 'ROLLBACK_ALREADY'
    | 'ABORT_ALL_ALREADY'
    | 'RETRY_FAILED'
    | 'UNKNOWN_ARTIFACT_TYPE'
    | 'UNKNOWN_STAGE_ELEMENT_WRAPPER_TYPE'
    | 'INIT_TIMEOUT'
    | 'LICENSE_EXPIRED'
    | 'NOT_LICENSED'
    | 'REQUEST_TIMEOUT'
    | 'WORKFLOW_ALREADY_TRIGGERED'
    | 'JENKINS_ERROR'
    | 'INVALID_ARTIFACT_SOURCE'
    | 'INVALID_ARTIFACT_SERVER'
    | 'INVALID_CLOUD_PROVIDER'
    | 'UPDATE_NOT_ALLOWED'
    | 'DELETE_NOT_ALLOWED'
    | 'APPDYNAMICS_CONFIGURATION_ERROR'
    | 'APM_CONFIGURATION_ERROR'
    | 'SPLUNK_CONFIGURATION_ERROR'
    | 'ELK_CONFIGURATION_ERROR'
    | 'LOGZ_CONFIGURATION_ERROR'
    | 'SUMO_CONFIGURATION_ERROR'
    | 'INSTANA_CONFIGURATION_ERROR'
    | 'APPDYNAMICS_ERROR'
    | 'STACKDRIVER_ERROR'
    | 'STACKDRIVER_CONFIGURATION_ERROR'
    | 'NEWRELIC_CONFIGURATION_ERROR'
    | 'NEWRELIC_ERROR'
    | 'DYNA_TRACE_CONFIGURATION_ERROR'
    | 'DYNA_TRACE_ERROR'
    | 'CLOUDWATCH_ERROR'
    | 'CLOUDWATCH_CONFIGURATION_ERROR'
    | 'PROMETHEUS_CONFIGURATION_ERROR'
    | 'DATA_DOG_CONFIGURATION_ERROR'
    | 'SERVICE_GUARD_CONFIGURATION_ERROR'
    | 'ENCRYPTION_NOT_CONFIGURED'
    | 'UNAVAILABLE_DELEGATES'
    | 'WORKFLOW_EXECUTION_IN_PROGRESS'
    | 'PIPELINE_EXECUTION_IN_PROGRESS'
    | 'AWS_ACCESS_DENIED'
    | 'AWS_CLUSTER_NOT_FOUND'
    | 'AWS_SERVICE_NOT_FOUND'
    | 'INVALID_YAML_PAYLOAD'
    | 'UNRECOGNIZED_YAML_FIELDS'
    | 'COULD_NOT_MAP_BEFORE_YAML'
    | 'MISSING_BEFORE_YAML'
    | 'MISSING_YAML'
    | 'NON_EMPTY_DELETIONS'
    | 'GENERAL_YAML_ERROR'
    | 'GENERAL_YAML_INFO'
    | 'YAML_GIT_SYNC_ERROR'
    | 'GIT_CONNECTION_ERROR'
    | 'GIT_ERROR'
    | 'ARTIFACT_SERVER_ERROR'
    | 'ENCRYPT_DECRYPT_ERROR'
    | 'SECRET_MANAGEMENT_ERROR'
    | 'KMS_OPERATION_ERROR'
    | 'GCP_KMS_OPERATION_ERROR'
    | 'VAULT_OPERATION_ERROR'
    | 'AWS_SECRETS_MANAGER_OPERATION_ERROR'
    | 'AZURE_KEY_VAULT_OPERATION_ERROR'
    | 'CYBERARK_OPERATION_ERROR'
    | 'UNSUPPORTED_OPERATION_EXCEPTION'
    | 'FEATURE_UNAVAILABLE'
    | 'GENERAL_ERROR'
    | 'BASELINE_CONFIGURATION_ERROR'
    | 'SAML_IDP_CONFIGURATION_NOT_AVAILABLE'
    | 'INVALID_AUTHENTICATION_MECHANISM'
    | 'INVALID_SAML_CONFIGURATION'
    | 'INVALID_OAUTH_CONFIGURATION'
    | 'INVALID_LDAP_CONFIGURATION'
    | 'USER_GROUP_SYNC_FAILURE'
    | 'USER_GROUP_ALREADY_EXIST'
    | 'INVALID_TWO_FACTOR_AUTHENTICATION_CONFIGURATION'
    | 'EXPLANATION'
    | 'HINT'
    | 'NOT_WHITELISTED_IP'
    | 'INVALID_TOTP_TOKEN'
    | 'EMAIL_FAILED'
    | 'SSL_HANDSHAKE_FAILED'
    | 'NO_APPS_ASSIGNED'
    | 'INVALID_INFRA_CONFIGURATION'
    | 'TEMPLATES_LINKED'
    | 'USER_HAS_NO_PERMISSIONS'
    | 'USER_NOT_AUTHORIZED'
    | 'USER_ALREADY_PRESENT'
    | 'INVALID_USAGE_RESTRICTION'
    | 'USAGE_RESTRICTION_ERROR'
    | 'STATE_EXECUTION_INSTANCE_NOT_FOUND'
    | 'DELEGATE_TASK_RETRY'
    | 'KUBERNETES_YAML_ERROR'
    | 'SAVE_FILE_INTO_GCP_STORAGE_FAILED'
    | 'READ_FILE_FROM_GCP_STORAGE_FAILED'
    | 'USAGE_LIMITS_EXCEEDED'
    | 'EVENT_PUBLISH_FAILED'
    | 'JIRA_ERROR'
    | 'EXPRESSION_EVALUATION_FAILED'
    | 'KUBERNETES_VALUES_ERROR'
    | 'KUBERNETES_CLUSTER_ERROR'
    | 'INCORRECT_SIGN_IN_MECHANISM'
    | 'OAUTH_LOGIN_FAILED'
    | 'INVALID_TERRAFORM_TARGETS_REQUEST'
    | 'TERRAFORM_EXECUTION_ERROR'
    | 'FILE_READ_FAILED'
    | 'FILE_SIZE_EXCEEDS_LIMIT'
    | 'CLUSTER_NOT_FOUND'
    | 'MARKETPLACE_TOKEN_NOT_FOUND'
    | 'INVALID_MARKETPLACE_TOKEN'
    | 'INVALID_TICKETING_SERVER'
    | 'SERVICENOW_ERROR'
    | 'PASSWORD_EXPIRED'
    | 'USER_LOCKED'
    | 'PASSWORD_STRENGTH_CHECK_FAILED'
    | 'ACCOUNT_DISABLED'
    | 'INVALID_ACCOUNT_PERMISSION'
    | 'PAGERDUTY_ERROR'
    | 'HEALTH_ERROR'
    | 'SAML_TEST_SUCCESS_MECHANISM_NOT_ENABLED'
    | 'DOMAIN_WHITELIST_FILTER_CHECK_FAILED'
    | 'INVALID_DASHBOARD_UPDATE_REQUEST'
    | 'DUPLICATE_FIELD'
    | 'INVALID_AZURE_VAULT_CONFIGURATION'
    | 'USER_NOT_AUTHORIZED_DUE_TO_USAGE_RESTRICTIONS'
    | 'INVALID_ROLLBACK'
    | 'SUMO_DATA_COLLECTION_ERROR'
    | 'DEPLOYMENT_GOVERNANCE_ERROR'
    | 'BATCH_PROCESSING_ERROR'
    | 'GRAPHQL_ERROR'
    | 'FILE_CREATE_ERROR'
    | 'ILLEGAL_STATE'
    | 'GIT_DIFF_COMMIT_NOT_IN_ORDER'
    | 'FAILED_TO_ACQUIRE_PERSISTENT_LOCK'
    | 'FAILED_TO_ACQUIRE_NON_PERSISTENT_LOCK'
    | 'POD_NOT_FOUND_ERROR'
    | 'COMMAND_EXECUTION_ERROR'
    | 'REGISTRY_EXCEPTION'
    | 'ENGINE_INTERRUPT_PROCESSING_EXCEPTION'
    | 'ENGINE_IO_EXCEPTION'
    | 'ENGINE_OUTCOME_EXCEPTION'
    | 'ENGINE_SWEEPING_OUTPUT_EXCEPTION'
    | 'CACHE_NOT_FOUND_EXCEPTION'
    | 'ENGINE_ENTITY_UPDATE_EXCEPTION'
    | 'SHELL_EXECUTION_EXCEPTION'
    | 'TEMPLATE_NOT_FOUND'
    | 'AZURE_SERVICE_EXCEPTION'
    | 'AZURE_CLIENT_EXCEPTION'
    | 'GIT_UNSEEN_REMOTE_HEAD_COMMIT'
    | 'TIMEOUT_ENGINE_EXCEPTION'
    | 'NO_AVAILABLE_DELEGATES'
    | 'NO_INSTALLED_DELEGATES'
    | 'DUPLICATE_DELEGATE_EXCEPTION'
    | 'GCP_MARKETPLACE_EXCEPTION'
    | 'MISSING_DEFAULT_GOOGLE_CREDENTIALS'
    | 'INCORRECT_DEFAULT_GOOGLE_CREDENTIALS'
    | 'OPTIMISTIC_LOCKING_EXCEPTION'
    | 'NG_PIPELINE_EXECUTION_EXCEPTION'
    | 'NG_PIPELINE_CREATE_EXCEPTION'
    | 'RESOURCE_NOT_FOUND_EXCEPTION'
    | 'PMS_INITIALIZE_SDK_EXCEPTION'
    | 'UNEXPECTED_SNIPPET_EXCEPTION'
    | 'UNEXPECTED_SCHEMA_EXCEPTION'
    | 'CONNECTOR_VALIDATION_EXCEPTION'
    | 'GCP_SECRET_MANAGER_OPERATION_ERROR'
    | 'GCP_SECRET_OPERATION_ERROR'
    | 'GIT_OPERATION_ERROR'
    | 'TASK_FAILURE_ERROR'
    | 'INSTANCE_STATS_PROCESS_ERROR'
    | 'INSTANCE_STATS_MIGRATION_ERROR'
    | 'DEPLOYMENT_MIGRATION_ERROR'
    | 'INSTANCE_STATS_AGGREGATION_ERROR'
    | 'UNRESOLVED_EXPRESSIONS_ERROR'
    | 'KRYO_HANDLER_NOT_FOUND_ERROR'
    | 'DELEGATE_ERROR_HANDLER_EXCEPTION'
    | 'UNEXPECTED_TYPE_ERROR'
    | 'EXCEPTION_HANDLER_NOT_FOUND'
    | 'CONNECTOR_NOT_FOUND_EXCEPTION'
    | 'GCP_SERVER_ERROR'
  message?: string
  correlationId?: string
  detailedMessage?: string
  responseMessages?: ResponseMessage[]
}

export interface ResponseMessage {
  code?:
    | 'DEFAULT_ERROR_CODE'
    | 'INVALID_ARGUMENT'
    | 'INVALID_EMAIL'
    | 'DOMAIN_NOT_ALLOWED_TO_REGISTER'
    | 'USER_ALREADY_REGISTERED'
    | 'USER_INVITATION_DOES_NOT_EXIST'
    | 'USER_DOES_NOT_EXIST'
    | 'USER_INVITE_OPERATION_FAILED'
    | 'USER_DISABLED'
    | 'ACCOUNT_DOES_NOT_EXIST'
    | 'INACTIVE_ACCOUNT'
    | 'ACCOUNT_MIGRATED'
    | 'USER_DOMAIN_NOT_ALLOWED'
    | 'MAX_FAILED_ATTEMPT_COUNT_EXCEEDED'
    | 'RESOURCE_NOT_FOUND'
    | 'ROLE_DOES_NOT_EXIST'
    | 'EMAIL_NOT_VERIFIED'
    | 'EMAIL_VERIFICATION_TOKEN_NOT_FOUND'
    | 'INVALID_TOKEN'
    | 'INVALID_CAPTCHA_TOKEN'
    | 'NOT_ACCOUNT_MGR_NOR_HAS_ALL_APP_ACCESS'
    | 'EXPIRED_TOKEN'
    | 'TOKEN_ALREADY_REFRESHED_ONCE'
    | 'ACCESS_DENIED'
    | 'NG_ACCESS_DENIED'
    | 'INVALID_CREDENTIAL'
    | 'INVALID_KEY'
    | 'INVALID_KEYPATH'
    | 'INVALID_VARIABLE'
    | 'UNKNOWN_HOST'
    | 'UNREACHABLE_HOST'
    | 'INVALID_PORT'
    | 'SSH_SESSION_TIMEOUT'
    | 'SOCKET_CONNECTION_ERROR'
    | 'SOCKET_CONNECTION_TIMEOUT'
    | 'CONNECTION_TIMEOUT'
    | 'SSH_CONNECTION_ERROR'
    | 'USER_GROUP_ERROR'
    | 'INVALID_EXECUTION_ID'
    | 'ERROR_IN_GETTING_CHANNEL_STREAMS'
    | 'UNEXPECTED'
    | 'UNKNOWN_ERROR'
    | 'UNKNOWN_EXECUTOR_TYPE_ERROR'
    | 'DUPLICATE_STATE_NAMES'
    | 'TRANSITION_NOT_LINKED'
    | 'TRANSITION_TO_INCORRECT_STATE'
    | 'TRANSITION_TYPE_NULL'
    | 'STATES_WITH_DUP_TRANSITIONS'
    | 'BARRIERS_NOT_RUNNING_CONCURRENTLY'
    | 'NON_FORK_STATES'
    | 'NON_REPEAT_STATES'
    | 'INITIAL_STATE_NOT_DEFINED'
    | 'FILE_INTEGRITY_CHECK_FAILED'
    | 'INVALID_URL'
    | 'FILE_DOWNLOAD_FAILED'
    | 'PLATFORM_SOFTWARE_DELETE_ERROR'
    | 'INVALID_CSV_FILE'
    | 'INVALID_REQUEST'
    | 'INVALID_INFRA_STATE'
    | 'PIPELINE_ALREADY_TRIGGERED'
    | 'NON_EXISTING_PIPELINE'
    | 'DUPLICATE_COMMAND_NAMES'
    | 'INVALID_PIPELINE'
    | 'COMMAND_DOES_NOT_EXIST'
    | 'DUPLICATE_ARTIFACTSTREAM_NAMES'
    | 'DUPLICATE_HOST_NAMES'
    | 'STATE_NOT_FOR_TYPE'
    | 'STATE_MACHINE_ISSUE'
    | 'STATE_DISCONTINUE_FAILED'
    | 'STATE_PAUSE_FAILED'
    | 'PAUSE_ALL_ALREADY'
    | 'RESUME_ALL_ALREADY'
    | 'ROLLBACK_ALREADY'
    | 'ABORT_ALL_ALREADY'
    | 'RETRY_FAILED'
    | 'UNKNOWN_ARTIFACT_TYPE'
    | 'UNKNOWN_STAGE_ELEMENT_WRAPPER_TYPE'
    | 'INIT_TIMEOUT'
    | 'LICENSE_EXPIRED'
    | 'NOT_LICENSED'
    | 'REQUEST_TIMEOUT'
    | 'WORKFLOW_ALREADY_TRIGGERED'
    | 'JENKINS_ERROR'
    | 'INVALID_ARTIFACT_SOURCE'
    | 'INVALID_ARTIFACT_SERVER'
    | 'INVALID_CLOUD_PROVIDER'
    | 'UPDATE_NOT_ALLOWED'
    | 'DELETE_NOT_ALLOWED'
    | 'APPDYNAMICS_CONFIGURATION_ERROR'
    | 'APM_CONFIGURATION_ERROR'
    | 'SPLUNK_CONFIGURATION_ERROR'
    | 'ELK_CONFIGURATION_ERROR'
    | 'LOGZ_CONFIGURATION_ERROR'
    | 'SUMO_CONFIGURATION_ERROR'
    | 'INSTANA_CONFIGURATION_ERROR'
    | 'APPDYNAMICS_ERROR'
    | 'STACKDRIVER_ERROR'
    | 'STACKDRIVER_CONFIGURATION_ERROR'
    | 'NEWRELIC_CONFIGURATION_ERROR'
    | 'NEWRELIC_ERROR'
    | 'DYNA_TRACE_CONFIGURATION_ERROR'
    | 'DYNA_TRACE_ERROR'
    | 'CLOUDWATCH_ERROR'
    | 'CLOUDWATCH_CONFIGURATION_ERROR'
    | 'PROMETHEUS_CONFIGURATION_ERROR'
    | 'DATA_DOG_CONFIGURATION_ERROR'
    | 'SERVICE_GUARD_CONFIGURATION_ERROR'
    | 'ENCRYPTION_NOT_CONFIGURED'
    | 'UNAVAILABLE_DELEGATES'
    | 'WORKFLOW_EXECUTION_IN_PROGRESS'
    | 'PIPELINE_EXECUTION_IN_PROGRESS'
    | 'AWS_ACCESS_DENIED'
    | 'AWS_CLUSTER_NOT_FOUND'
    | 'AWS_SERVICE_NOT_FOUND'
    | 'INVALID_YAML_PAYLOAD'
    | 'UNRECOGNIZED_YAML_FIELDS'
    | 'COULD_NOT_MAP_BEFORE_YAML'
    | 'MISSING_BEFORE_YAML'
    | 'MISSING_YAML'
    | 'NON_EMPTY_DELETIONS'
    | 'GENERAL_YAML_ERROR'
    | 'GENERAL_YAML_INFO'
    | 'YAML_GIT_SYNC_ERROR'
    | 'GIT_CONNECTION_ERROR'
    | 'GIT_ERROR'
    | 'ARTIFACT_SERVER_ERROR'
    | 'ENCRYPT_DECRYPT_ERROR'
    | 'SECRET_MANAGEMENT_ERROR'
    | 'KMS_OPERATION_ERROR'
    | 'GCP_KMS_OPERATION_ERROR'
    | 'VAULT_OPERATION_ERROR'
    | 'AWS_SECRETS_MANAGER_OPERATION_ERROR'
    | 'AZURE_KEY_VAULT_OPERATION_ERROR'
    | 'CYBERARK_OPERATION_ERROR'
    | 'UNSUPPORTED_OPERATION_EXCEPTION'
    | 'FEATURE_UNAVAILABLE'
    | 'GENERAL_ERROR'
    | 'BASELINE_CONFIGURATION_ERROR'
    | 'SAML_IDP_CONFIGURATION_NOT_AVAILABLE'
    | 'INVALID_AUTHENTICATION_MECHANISM'
    | 'INVALID_SAML_CONFIGURATION'
    | 'INVALID_OAUTH_CONFIGURATION'
    | 'INVALID_LDAP_CONFIGURATION'
    | 'USER_GROUP_SYNC_FAILURE'
    | 'USER_GROUP_ALREADY_EXIST'
    | 'INVALID_TWO_FACTOR_AUTHENTICATION_CONFIGURATION'
    | 'EXPLANATION'
    | 'HINT'
    | 'NOT_WHITELISTED_IP'
    | 'INVALID_TOTP_TOKEN'
    | 'EMAIL_FAILED'
    | 'SSL_HANDSHAKE_FAILED'
    | 'NO_APPS_ASSIGNED'
    | 'INVALID_INFRA_CONFIGURATION'
    | 'TEMPLATES_LINKED'
    | 'USER_HAS_NO_PERMISSIONS'
    | 'USER_NOT_AUTHORIZED'
    | 'USER_ALREADY_PRESENT'
    | 'INVALID_USAGE_RESTRICTION'
    | 'USAGE_RESTRICTION_ERROR'
    | 'STATE_EXECUTION_INSTANCE_NOT_FOUND'
    | 'DELEGATE_TASK_RETRY'
    | 'KUBERNETES_YAML_ERROR'
    | 'SAVE_FILE_INTO_GCP_STORAGE_FAILED'
    | 'READ_FILE_FROM_GCP_STORAGE_FAILED'
    | 'USAGE_LIMITS_EXCEEDED'
    | 'EVENT_PUBLISH_FAILED'
    | 'JIRA_ERROR'
    | 'EXPRESSION_EVALUATION_FAILED'
    | 'KUBERNETES_VALUES_ERROR'
    | 'KUBERNETES_CLUSTER_ERROR'
    | 'INCORRECT_SIGN_IN_MECHANISM'
    | 'OAUTH_LOGIN_FAILED'
    | 'INVALID_TERRAFORM_TARGETS_REQUEST'
    | 'TERRAFORM_EXECUTION_ERROR'
    | 'FILE_READ_FAILED'
    | 'FILE_SIZE_EXCEEDS_LIMIT'
    | 'CLUSTER_NOT_FOUND'
    | 'MARKETPLACE_TOKEN_NOT_FOUND'
    | 'INVALID_MARKETPLACE_TOKEN'
    | 'INVALID_TICKETING_SERVER'
    | 'SERVICENOW_ERROR'
    | 'PASSWORD_EXPIRED'
    | 'USER_LOCKED'
    | 'PASSWORD_STRENGTH_CHECK_FAILED'
    | 'ACCOUNT_DISABLED'
    | 'INVALID_ACCOUNT_PERMISSION'
    | 'PAGERDUTY_ERROR'
    | 'HEALTH_ERROR'
    | 'SAML_TEST_SUCCESS_MECHANISM_NOT_ENABLED'
    | 'DOMAIN_WHITELIST_FILTER_CHECK_FAILED'
    | 'INVALID_DASHBOARD_UPDATE_REQUEST'
    | 'DUPLICATE_FIELD'
    | 'INVALID_AZURE_VAULT_CONFIGURATION'
    | 'USER_NOT_AUTHORIZED_DUE_TO_USAGE_RESTRICTIONS'
    | 'INVALID_ROLLBACK'
    | 'SUMO_DATA_COLLECTION_ERROR'
    | 'DEPLOYMENT_GOVERNANCE_ERROR'
    | 'BATCH_PROCESSING_ERROR'
    | 'GRAPHQL_ERROR'
    | 'FILE_CREATE_ERROR'
    | 'ILLEGAL_STATE'
    | 'GIT_DIFF_COMMIT_NOT_IN_ORDER'
    | 'FAILED_TO_ACQUIRE_PERSISTENT_LOCK'
    | 'FAILED_TO_ACQUIRE_NON_PERSISTENT_LOCK'
    | 'POD_NOT_FOUND_ERROR'
    | 'COMMAND_EXECUTION_ERROR'
    | 'REGISTRY_EXCEPTION'
    | 'ENGINE_INTERRUPT_PROCESSING_EXCEPTION'
    | 'ENGINE_IO_EXCEPTION'
    | 'ENGINE_OUTCOME_EXCEPTION'
    | 'ENGINE_SWEEPING_OUTPUT_EXCEPTION'
    | 'CACHE_NOT_FOUND_EXCEPTION'
    | 'ENGINE_ENTITY_UPDATE_EXCEPTION'
    | 'SHELL_EXECUTION_EXCEPTION'
    | 'TEMPLATE_NOT_FOUND'
    | 'AZURE_SERVICE_EXCEPTION'
    | 'AZURE_CLIENT_EXCEPTION'
    | 'GIT_UNSEEN_REMOTE_HEAD_COMMIT'
    | 'TIMEOUT_ENGINE_EXCEPTION'
    | 'NO_AVAILABLE_DELEGATES'
    | 'NO_INSTALLED_DELEGATES'
    | 'DUPLICATE_DELEGATE_EXCEPTION'
    | 'GCP_MARKETPLACE_EXCEPTION'
    | 'MISSING_DEFAULT_GOOGLE_CREDENTIALS'
    | 'INCORRECT_DEFAULT_GOOGLE_CREDENTIALS'
    | 'OPTIMISTIC_LOCKING_EXCEPTION'
    | 'NG_PIPELINE_EXECUTION_EXCEPTION'
    | 'NG_PIPELINE_CREATE_EXCEPTION'
    | 'RESOURCE_NOT_FOUND_EXCEPTION'
    | 'PMS_INITIALIZE_SDK_EXCEPTION'
    | 'UNEXPECTED_SNIPPET_EXCEPTION'
    | 'UNEXPECTED_SCHEMA_EXCEPTION'
    | 'CONNECTOR_VALIDATION_EXCEPTION'
    | 'GCP_SECRET_MANAGER_OPERATION_ERROR'
    | 'GCP_SECRET_OPERATION_ERROR'
    | 'GIT_OPERATION_ERROR'
    | 'TASK_FAILURE_ERROR'
    | 'INSTANCE_STATS_PROCESS_ERROR'
    | 'INSTANCE_STATS_MIGRATION_ERROR'
    | 'DEPLOYMENT_MIGRATION_ERROR'
    | 'INSTANCE_STATS_AGGREGATION_ERROR'
    | 'UNRESOLVED_EXPRESSIONS_ERROR'
    | 'KRYO_HANDLER_NOT_FOUND_ERROR'
    | 'DELEGATE_ERROR_HANDLER_EXCEPTION'
    | 'UNEXPECTED_TYPE_ERROR'
    | 'EXCEPTION_HANDLER_NOT_FOUND'
    | 'CONNECTOR_NOT_FOUND_EXCEPTION'
    | 'GCP_SERVER_ERROR'
  level?: 'INFO' | 'ERROR'
  message?: string
  exception?: Throwable
  failureTypes?: (
    | 'EXPIRED'
    | 'DELEGATE_PROVISIONING'
    | 'CONNECTIVITY'
    | 'AUTHENTICATION'
    | 'VERIFICATION_FAILURE'
    | 'APPLICATION_ERROR'
    | 'AUTHORIZATION_ERROR'
    | 'TIMEOUT_ERROR'
  )[]
}

export interface StackTraceElement {
  methodName?: string
  fileName?: string
  lineNumber?: number
  className?: string
  nativeMethod?: boolean
}

export interface Throwable {
  cause?: Throwable
  stackTrace?: StackTraceElement[]
  message?: string
  localizedMessage?: string
  suppressed?: Throwable[]
}

export interface AccessCheckRequest {
  permissions?: PermissionCheck[]
  principal?: Principal
}

export interface PermissionCheck {
  resourceScope: ResourceScope
  resourceType?: string
  resourceIdentifier?: string
  permission?: string
}

export interface Permission {
  identifier: string
  name: string
  status: 'EXPERIMENTAL' | 'ACTIVE' | 'DEPRECATED'
  allowedScopeLevels: ('organization' | 'project' | 'account')[]
  resourceType: string
  action: string
}

export interface PermissionResponse {
  permission: Permission
}

export interface ResponseListPermissionResponse {
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
  data?: PermissionResponse[]
  metaData?: { [key: string]: any }
  correlationId?: string
}

export interface ResponseSetString {
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
  data?: string[]
  metaData?: { [key: string]: any }
  correlationId?: string
}

export interface Page {
  totalPages?: number
  totalItems?: number
  pageItemCount?: number
  pageSize?: number
  content?: { [key: string]: any }[]
  pageIndex?: number
  empty?: boolean
}

export interface PageRoleAssignmentResponse {
  totalPages?: number
  totalItems?: number
  pageItemCount?: number
  pageSize?: number
  content?: RoleAssignmentResponse[]
  pageIndex?: number
  empty?: boolean
}

export interface ResponsePageRoleAssignmentResponse {
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
  data?: PageRoleAssignmentResponse
  metaData?: { [key: string]: any }
  correlationId?: string
}

export interface RoleAssignment {
  identifier?: string
  resourceGroupIdentifier: string
  roleIdentifier: string
  principal: Principal
  disabled?: boolean
}

export interface RoleAssignmentResponse {
  roleAssignment: RoleAssignment
  scope: ScopeDTO
  createdAt?: number
  lastModifiedAt?: number
  harnessManaged?: boolean
}

export interface ScopeDTO {
  accountIdentifier?: string
  orgIdentifier?: string
  projectIdentifier?: string
}

export interface RoleAssignmentFilter {
  resourceGroupFilter?: string[]
  roleFilter?: string[]
  principalTypeFilter?: ('USER' | 'USER_GROUP' | 'API_KEY' | 'SERVICE')[]
  principalFilter?: Principal[]
  harnessManagedFilter?: boolean[]
  disabledFilter?: boolean[]
}

export interface ResponseRoleAssignmentResponse {
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
  data?: RoleAssignmentResponse
  metaData?: { [key: string]: any }
  correlationId?: string
}

export interface ResponseListRoleAssignmentResponse {
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
  data?: RoleAssignmentResponse[]
  metaData?: { [key: string]: any }
  correlationId?: string
}

export interface BatchRoleAssignmentCreateRequest {
  roleAssignments?: RoleAssignment[]
}

export interface ResponseRoleAssignmentValidationResponse {
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
  data?: RoleAssignmentValidationResponse
  metaData?: { [key: string]: any }
  correlationId?: string
}

export interface RoleAssignmentValidationResponse {
  principalValidationResult?: ValidationResult
  roleValidationResult?: ValidationResult
  resourceGroupValidationResult?: ValidationResult
}

export interface ValidationResult {
  errorMessage?: string
  valid?: boolean
}

export interface RoleAssignmentValidationRequestDTO {
  roleAssignment: RoleAssignment
  validatePrincipal?: boolean
  validateRole?: boolean
  validateResourceGroup?: boolean
}

export interface ResourceGroupDTO {
  identifier?: string
  name?: string
}

export interface ResponseRoleAssignmentAggregateResponse {
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
  data?: RoleAssignmentAggregateResponse
  metaData?: { [key: string]: any }
  correlationId?: string
}

export interface Role {
  identifier: string
  name: string
  permissions?: string[]
  allowedScopeLevels?: ('organization' | 'project' | 'account')[]
  description?: string
  tags?: {
    [key: string]: string
  }
}

export interface RoleAssignmentAggregateResponse {
  roleAssignments?: RoleAssignment[]
  scope?: ScopeDTO
  roles?: RoleResponse[]
  resourceGroups?: ResourceGroupDTO[]
}

export interface RoleResponse {
  role: Role
  scope: ScopeDTO
  harnessManaged?: boolean
  createdAt?: number
  lastModifiedAt?: number
}

export interface ResponseRoleResponse {
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
  data?: RoleResponse
  metaData?: { [key: string]: any }
  correlationId?: string
}

export interface PageRoleResponse {
  totalPages?: number
  totalItems?: number
  pageItemCount?: number
  pageSize?: number
  content?: RoleResponse[]
  pageIndex?: number
  empty?: boolean
}

export interface ResponsePageRoleResponse {
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
  data?: PageRoleResponse
  metaData?: { [key: string]: any }
  correlationId?: string
}

export interface ResponseString {
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
  data?: string
  metaData?: { [key: string]: any }
  correlationId?: string
}

export type RoleAssignmentFilterRequestBody = RoleAssignmentFilter

export type RoleAssignmentRequestBody = RoleAssignment

export type RoleRequestBody = Role

export type GetAccessControlListProps = Omit<
  MutateProps<ResponseAccessCheckResponse, Failure | Error, void, AccessCheckRequest, void>,
  'path' | 'verb'
>

/**
 * Check for access to resources
 */
export const GetAccessControlList = (props: GetAccessControlListProps) => (
  <Mutate<ResponseAccessCheckResponse, Failure | Error, void, AccessCheckRequest, void>
    verb="POST"
    path="/acl"
    base={getConfig('authz/api')}
    {...props}
  />
)

export type UseGetAccessControlListProps = Omit<
  UseMutateProps<ResponseAccessCheckResponse, Failure | Error, void, AccessCheckRequest, void>,
  'path' | 'verb'
>

/**
 * Check for access to resources
 */
export const useGetAccessControlList = (props: UseGetAccessControlListProps) =>
  useMutate<ResponseAccessCheckResponse, Failure | Error, void, AccessCheckRequest, void>('POST', `/acl`, {
    base: getConfig('authz/api'),
    ...props
  })

/**
 * Check for access to resources
 */
export const getAccessControlListPromise = (
  props: MutateUsingFetchProps<ResponseAccessCheckResponse, Failure | Error, void, AccessCheckRequest, void>,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<ResponseAccessCheckResponse, Failure | Error, void, AccessCheckRequest, void>(
    'POST',
    getConfig('authz/api'),
    `/acl`,
    props,
    signal
  )

export interface GetPermissionListQueryParams {
  accountIdentifier?: string
  orgIdentifier?: string
  projectIdentifier?: string
  scopeFilterDisabled?: boolean
}

export type GetPermissionListProps = Omit<
  GetProps<ResponseListPermissionResponse, Failure | Error, GetPermissionListQueryParams, void>,
  'path'
>

/**
 * Get All Permissions in a Scope
 */
export const GetPermissionList = (props: GetPermissionListProps) => (
  <Get<ResponseListPermissionResponse, Failure | Error, GetPermissionListQueryParams, void>
    path="/permissions"
    base={getConfig('authz/api')}
    {...props}
  />
)

export type UseGetPermissionListProps = Omit<
  UseGetProps<ResponseListPermissionResponse, Failure | Error, GetPermissionListQueryParams, void>,
  'path'
>

/**
 * Get All Permissions in a Scope
 */
export const useGetPermissionList = (props: UseGetPermissionListProps) =>
  useGet<ResponseListPermissionResponse, Failure | Error, GetPermissionListQueryParams, void>(`/permissions`, {
    base: getConfig('authz/api'),
    ...props
  })

/**
 * Get All Permissions in a Scope
 */
export const getPermissionListPromise = (
  props: GetUsingFetchProps<ResponseListPermissionResponse, Failure | Error, GetPermissionListQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseListPermissionResponse, Failure | Error, GetPermissionListQueryParams, void>(
    getConfig('authz/api'),
    `/permissions`,
    props,
    signal
  )

export interface GetPermissionResourceTypesListQueryParams {
  accountIdentifier?: string
  orgIdentifier?: string
  projectIdentifier?: string
  scopeFilterDisabled?: boolean
}

export type GetPermissionResourceTypesListProps = Omit<
  GetProps<ResponseSetString, Failure | Error, GetPermissionResourceTypesListQueryParams, void>,
  'path'
>

/**
 * Get All Resource Types for Permissions in a Scope
 */
export const GetPermissionResourceTypesList = (props: GetPermissionResourceTypesListProps) => (
  <Get<ResponseSetString, Failure | Error, GetPermissionResourceTypesListQueryParams, void>
    path="/permissions/resourcetypes"
    base={getConfig('authz/api')}
    {...props}
  />
)

export type UseGetPermissionResourceTypesListProps = Omit<
  UseGetProps<ResponseSetString, Failure | Error, GetPermissionResourceTypesListQueryParams, void>,
  'path'
>

/**
 * Get All Resource Types for Permissions in a Scope
 */
export const useGetPermissionResourceTypesList = (props: UseGetPermissionResourceTypesListProps) =>
  useGet<ResponseSetString, Failure | Error, GetPermissionResourceTypesListQueryParams, void>(
    `/permissions/resourcetypes`,
    { base: getConfig('authz/api'), ...props }
  )

/**
 * Get All Resource Types for Permissions in a Scope
 */
export const getPermissionResourceTypesListPromise = (
  props: GetUsingFetchProps<ResponseSetString, Failure | Error, GetPermissionResourceTypesListQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseSetString, Failure | Error, GetPermissionResourceTypesListQueryParams, void>(
    getConfig('authz/api'),
    `/permissions/resourcetypes`,
    props,
    signal
  )

export interface GetRoleAssignmentListQueryParams {
  pageIndex?: number
  pageSize?: number
  sortOrders?: string[]
  accountIdentifier?: string
  orgIdentifier?: string
  projectIdentifier?: string
}

export type GetRoleAssignmentListProps = Omit<
  GetProps<ResponsePageRoleAssignmentResponse, Failure | Error, GetRoleAssignmentListQueryParams, void>,
  'path'
>

/**
 * Get Role Assignments
 */
export const GetRoleAssignmentList = (props: GetRoleAssignmentListProps) => (
  <Get<ResponsePageRoleAssignmentResponse, Failure | Error, GetRoleAssignmentListQueryParams, void>
    path="/roleassignments"
    base={getConfig('authz/api')}
    {...props}
  />
)

export type UseGetRoleAssignmentListProps = Omit<
  UseGetProps<ResponsePageRoleAssignmentResponse, Failure | Error, GetRoleAssignmentListQueryParams, void>,
  'path'
>

/**
 * Get Role Assignments
 */
export const useGetRoleAssignmentList = (props: UseGetRoleAssignmentListProps) =>
  useGet<ResponsePageRoleAssignmentResponse, Failure | Error, GetRoleAssignmentListQueryParams, void>(
    `/roleassignments`,
    { base: getConfig('authz/api'), ...props }
  )

/**
 * Get Role Assignments
 */
export const getRoleAssignmentListPromise = (
  props: GetUsingFetchProps<
    ResponsePageRoleAssignmentResponse,
    Failure | Error,
    GetRoleAssignmentListQueryParams,
    void
  >,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponsePageRoleAssignmentResponse, Failure | Error, GetRoleAssignmentListQueryParams, void>(
    getConfig('authz/api'),
    `/roleassignments`,
    props,
    signal
  )

export interface CreateRoleAssignmentQueryParams {
  accountIdentifier?: string
  orgIdentifier?: string
  projectIdentifier?: string
}

export type CreateRoleAssignmentProps = Omit<
  MutateProps<
    ResponseRoleAssignmentResponse,
    Failure | Error,
    CreateRoleAssignmentQueryParams,
    RoleAssignmentRequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Create Role Assignment
 */
export const CreateRoleAssignment = (props: CreateRoleAssignmentProps) => (
  <Mutate<
    ResponseRoleAssignmentResponse,
    Failure | Error,
    CreateRoleAssignmentQueryParams,
    RoleAssignmentRequestBody,
    void
  >
    verb="POST"
    path="/roleassignments"
    base={getConfig('authz/api')}
    {...props}
  />
)

export type UseCreateRoleAssignmentProps = Omit<
  UseMutateProps<
    ResponseRoleAssignmentResponse,
    Failure | Error,
    CreateRoleAssignmentQueryParams,
    RoleAssignmentRequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Create Role Assignment
 */
export const useCreateRoleAssignment = (props: UseCreateRoleAssignmentProps) =>
  useMutate<
    ResponseRoleAssignmentResponse,
    Failure | Error,
    CreateRoleAssignmentQueryParams,
    RoleAssignmentRequestBody,
    void
  >('POST', `/roleassignments`, { base: getConfig('authz/api'), ...props })

/**
 * Create Role Assignment
 */
export const createRoleAssignmentPromise = (
  props: MutateUsingFetchProps<
    ResponseRoleAssignmentResponse,
    Failure | Error,
    CreateRoleAssignmentQueryParams,
    RoleAssignmentRequestBody,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseRoleAssignmentResponse,
    Failure | Error,
    CreateRoleAssignmentQueryParams,
    RoleAssignmentRequestBody,
    void
  >('POST', getConfig('authz/api'), `/roleassignments`, props, signal)

export interface GetFilteredRoleAssignmentListQueryParams {
  pageIndex?: number
  pageSize?: number
  sortOrders?: string[]
  accountIdentifier?: string
  orgIdentifier?: string
  projectIdentifier?: string
}

export type GetFilteredRoleAssignmentListProps = Omit<
  MutateProps<
    ResponsePageRoleAssignmentResponse,
    Failure | Error,
    GetFilteredRoleAssignmentListQueryParams,
    RoleAssignmentFilterRequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Get Filtered Role Assignments
 */
export const GetFilteredRoleAssignmentList = (props: GetFilteredRoleAssignmentListProps) => (
  <Mutate<
    ResponsePageRoleAssignmentResponse,
    Failure | Error,
    GetFilteredRoleAssignmentListQueryParams,
    RoleAssignmentFilterRequestBody,
    void
  >
    verb="POST"
    path="/roleassignments/filter"
    base={getConfig('authz/api')}
    {...props}
  />
)

export type UseGetFilteredRoleAssignmentListProps = Omit<
  UseMutateProps<
    ResponsePageRoleAssignmentResponse,
    Failure | Error,
    GetFilteredRoleAssignmentListQueryParams,
    RoleAssignmentFilterRequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Get Filtered Role Assignments
 */
export const useGetFilteredRoleAssignmentList = (props: UseGetFilteredRoleAssignmentListProps) =>
  useMutate<
    ResponsePageRoleAssignmentResponse,
    Failure | Error,
    GetFilteredRoleAssignmentListQueryParams,
    RoleAssignmentFilterRequestBody,
    void
  >('POST', `/roleassignments/filter`, { base: getConfig('authz/api'), ...props })

/**
 * Get Filtered Role Assignments
 */
export const getFilteredRoleAssignmentListPromise = (
  props: MutateUsingFetchProps<
    ResponsePageRoleAssignmentResponse,
    Failure | Error,
    GetFilteredRoleAssignmentListQueryParams,
    RoleAssignmentFilterRequestBody,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponsePageRoleAssignmentResponse,
    Failure | Error,
    GetFilteredRoleAssignmentListQueryParams,
    RoleAssignmentFilterRequestBody,
    void
  >('POST', getConfig('authz/api'), `/roleassignments/filter`, props, signal)

export interface UpdateRoleAssignmentQueryParams {
  accountIdentifier?: string
  orgIdentifier?: string
  projectIdentifier?: string
}

export interface UpdateRoleAssignmentPathParams {
  identifier: string
}

export type UpdateRoleAssignmentProps = Omit<
  MutateProps<
    ResponseRoleAssignmentResponse,
    Failure | Error,
    UpdateRoleAssignmentQueryParams,
    RoleAssignmentRequestBody,
    UpdateRoleAssignmentPathParams
  >,
  'path' | 'verb'
> &
  UpdateRoleAssignmentPathParams

/**
 * Update Role Assignment
 */
export const UpdateRoleAssignment = ({ identifier, ...props }: UpdateRoleAssignmentProps) => (
  <Mutate<
    ResponseRoleAssignmentResponse,
    Failure | Error,
    UpdateRoleAssignmentQueryParams,
    RoleAssignmentRequestBody,
    UpdateRoleAssignmentPathParams
  >
    verb="PUT"
    path="/roleassignments/${identifier}"
    base={getConfig('authz/api')}
    {...props}
  />
)

export type UseUpdateRoleAssignmentProps = Omit<
  UseMutateProps<
    ResponseRoleAssignmentResponse,
    Failure | Error,
    UpdateRoleAssignmentQueryParams,
    RoleAssignmentRequestBody,
    UpdateRoleAssignmentPathParams
  >,
  'path' | 'verb'
> &
  UpdateRoleAssignmentPathParams

/**
 * Update Role Assignment
 */
export const useUpdateRoleAssignment = ({ identifier, ...props }: UseUpdateRoleAssignmentProps) =>
  useMutate<
    ResponseRoleAssignmentResponse,
    Failure | Error,
    UpdateRoleAssignmentQueryParams,
    RoleAssignmentRequestBody,
    UpdateRoleAssignmentPathParams
  >('PUT', (paramsInPath: UpdateRoleAssignmentPathParams) => `/roleassignments/${paramsInPath.identifier}`, {
    base: getConfig('authz/api'),
    pathParams: { identifier },
    ...props
  })

/**
 * Update Role Assignment
 */
export const updateRoleAssignmentPromise = (
  {
    identifier,
    ...props
  }: MutateUsingFetchProps<
    ResponseRoleAssignmentResponse,
    Failure | Error,
    UpdateRoleAssignmentQueryParams,
    RoleAssignmentRequestBody,
    UpdateRoleAssignmentPathParams
  > & { identifier: string },
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseRoleAssignmentResponse,
    Failure | Error,
    UpdateRoleAssignmentQueryParams,
    RoleAssignmentRequestBody,
    UpdateRoleAssignmentPathParams
  >('PUT', getConfig('authz/api'), `/roleassignments/${identifier}`, props, signal)

export interface DeleteRoleAssignmentQueryParams {
  accountIdentifier?: string
  orgIdentifier?: string
  projectIdentifier?: string
}

export type DeleteRoleAssignmentProps = Omit<
  MutateProps<ResponseRoleAssignmentResponse, Failure | Error, DeleteRoleAssignmentQueryParams, string, void>,
  'path' | 'verb'
>

/**
 * Delete Role Assignment
 */
export const DeleteRoleAssignment = (props: DeleteRoleAssignmentProps) => (
  <Mutate<ResponseRoleAssignmentResponse, Failure | Error, DeleteRoleAssignmentQueryParams, string, void>
    verb="DELETE"
    path="/roleassignments"
    base={getConfig('authz/api')}
    {...props}
  />
)

export type UseDeleteRoleAssignmentProps = Omit<
  UseMutateProps<ResponseRoleAssignmentResponse, Failure | Error, DeleteRoleAssignmentQueryParams, string, void>,
  'path' | 'verb'
>

/**
 * Delete Role Assignment
 */
export const useDeleteRoleAssignment = (props: UseDeleteRoleAssignmentProps) =>
  useMutate<ResponseRoleAssignmentResponse, Failure | Error, DeleteRoleAssignmentQueryParams, string, void>(
    'DELETE',
    `/roleassignments`,
    { base: getConfig('authz/api'), ...props }
  )

/**
 * Delete Role Assignment
 */
export const deleteRoleAssignmentPromise = (
  props: MutateUsingFetchProps<
    ResponseRoleAssignmentResponse,
    Failure | Error,
    DeleteRoleAssignmentQueryParams,
    string,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<ResponseRoleAssignmentResponse, Failure | Error, DeleteRoleAssignmentQueryParams, string, void>(
    'DELETE',
    getConfig('authz/api'),
    `/roleassignments`,
    props,
    signal
  )

export interface CreateRoleAssignmentsQueryParams {
  accountIdentifier?: string
  orgIdentifier?: string
  projectIdentifier?: string
}

export type CreateRoleAssignmentsProps = Omit<
  MutateProps<
    ResponseListRoleAssignmentResponse,
    Failure | Error,
    CreateRoleAssignmentsQueryParams,
    BatchRoleAssignmentCreateRequest,
    void
  >,
  'path' | 'verb'
>

/**
 * Create Multiple Role Assignments
 */
export const CreateRoleAssignments = (props: CreateRoleAssignmentsProps) => (
  <Mutate<
    ResponseListRoleAssignmentResponse,
    Failure | Error,
    CreateRoleAssignmentsQueryParams,
    BatchRoleAssignmentCreateRequest,
    void
  >
    verb="POST"
    path="/roleassignments/multi"
    base={getConfig('authz/api')}
    {...props}
  />
)

export type UseCreateRoleAssignmentsProps = Omit<
  UseMutateProps<
    ResponseListRoleAssignmentResponse,
    Failure | Error,
    CreateRoleAssignmentsQueryParams,
    BatchRoleAssignmentCreateRequest,
    void
  >,
  'path' | 'verb'
>

/**
 * Create Multiple Role Assignments
 */
export const useCreateRoleAssignments = (props: UseCreateRoleAssignmentsProps) =>
  useMutate<
    ResponseListRoleAssignmentResponse,
    Failure | Error,
    CreateRoleAssignmentsQueryParams,
    BatchRoleAssignmentCreateRequest,
    void
  >('POST', `/roleassignments/multi`, { base: getConfig('authz/api'), ...props })

/**
 * Create Multiple Role Assignments
 */
export const createRoleAssignmentsPromise = (
  props: MutateUsingFetchProps<
    ResponseListRoleAssignmentResponse,
    Failure | Error,
    CreateRoleAssignmentsQueryParams,
    BatchRoleAssignmentCreateRequest,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseListRoleAssignmentResponse,
    Failure | Error,
    CreateRoleAssignmentsQueryParams,
    BatchRoleAssignmentCreateRequest,
    void
  >('POST', getConfig('authz/api'), `/roleassignments/multi`, props, signal)

export interface ValidateRoleAssignmentQueryParams {
  accountIdentifier?: string
  orgIdentifier?: string
  projectIdentifier?: string
}

export type ValidateRoleAssignmentProps = Omit<
  MutateProps<
    ResponseRoleAssignmentValidationResponse,
    Failure | Error,
    ValidateRoleAssignmentQueryParams,
    RoleAssignmentValidationRequestDTO,
    void
  >,
  'path' | 'verb'
>

/**
 * Validate Role Assignment
 */
export const ValidateRoleAssignment = (props: ValidateRoleAssignmentProps) => (
  <Mutate<
    ResponseRoleAssignmentValidationResponse,
    Failure | Error,
    ValidateRoleAssignmentQueryParams,
    RoleAssignmentValidationRequestDTO,
    void
  >
    verb="POST"
    path="/roleassignments/validate"
    base={getConfig('authz/api')}
    {...props}
  />
)

export type UseValidateRoleAssignmentProps = Omit<
  UseMutateProps<
    ResponseRoleAssignmentValidationResponse,
    Failure | Error,
    ValidateRoleAssignmentQueryParams,
    RoleAssignmentValidationRequestDTO,
    void
  >,
  'path' | 'verb'
>

/**
 * Validate Role Assignment
 */
export const useValidateRoleAssignment = (props: UseValidateRoleAssignmentProps) =>
  useMutate<
    ResponseRoleAssignmentValidationResponse,
    Failure | Error,
    ValidateRoleAssignmentQueryParams,
    RoleAssignmentValidationRequestDTO,
    void
  >('POST', `/roleassignments/validate`, { base: getConfig('authz/api'), ...props })

/**
 * Validate Role Assignment
 */
export const validateRoleAssignmentPromise = (
  props: MutateUsingFetchProps<
    ResponseRoleAssignmentValidationResponse,
    Failure | Error,
    ValidateRoleAssignmentQueryParams,
    RoleAssignmentValidationRequestDTO,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseRoleAssignmentValidationResponse,
    Failure | Error,
    ValidateRoleAssignmentQueryParams,
    RoleAssignmentValidationRequestDTO,
    void
  >('POST', getConfig('authz/api'), `/roleassignments/validate`, props, signal)

export interface GetRoleAssignmentsAggregateQueryParams {
  accountIdentifier?: string
  orgIdentifier?: string
  projectIdentifier?: string
}

export type GetRoleAssignmentsAggregateProps = Omit<
  MutateProps<
    ResponseRoleAssignmentAggregateResponse,
    Failure | Error,
    GetRoleAssignmentsAggregateQueryParams,
    RoleAssignmentFilterRequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Get Role Assignments Aggregate
 */
export const GetRoleAssignmentsAggregate = (props: GetRoleAssignmentsAggregateProps) => (
  <Mutate<
    ResponseRoleAssignmentAggregateResponse,
    Failure | Error,
    GetRoleAssignmentsAggregateQueryParams,
    RoleAssignmentFilterRequestBody,
    void
  >
    verb="POST"
    path="/roleassignments/aggregate"
    base={getConfig('authz/api')}
    {...props}
  />
)

export type UseGetRoleAssignmentsAggregateProps = Omit<
  UseMutateProps<
    ResponseRoleAssignmentAggregateResponse,
    Failure | Error,
    GetRoleAssignmentsAggregateQueryParams,
    RoleAssignmentFilterRequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Get Role Assignments Aggregate
 */
export const useGetRoleAssignmentsAggregate = (props: UseGetRoleAssignmentsAggregateProps) =>
  useMutate<
    ResponseRoleAssignmentAggregateResponse,
    Failure | Error,
    GetRoleAssignmentsAggregateQueryParams,
    RoleAssignmentFilterRequestBody,
    void
  >('POST', `/roleassignments/aggregate`, { base: getConfig('authz/api'), ...props })

/**
 * Get Role Assignments Aggregate
 */
export const getRoleAssignmentsAggregatePromise = (
  props: MutateUsingFetchProps<
    ResponseRoleAssignmentAggregateResponse,
    Failure | Error,
    GetRoleAssignmentsAggregateQueryParams,
    RoleAssignmentFilterRequestBody,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseRoleAssignmentAggregateResponse,
    Failure | Error,
    GetRoleAssignmentsAggregateQueryParams,
    RoleAssignmentFilterRequestBody,
    void
  >('POST', getConfig('authz/api'), `/roleassignments/aggregate`, props, signal)

export interface GetRoleQueryParams {
  accountIdentifier?: string
  orgIdentifier?: string
  projectIdentifier?: string
  harnessManaged?: boolean
}

export interface GetRolePathParams {
  identifier: string
}

export type GetRoleProps = Omit<
  GetProps<ResponseRoleResponse, Failure | Error, GetRoleQueryParams, GetRolePathParams>,
  'path'
> &
  GetRolePathParams

/**
 * Get Role
 */
export const GetRole = ({ identifier, ...props }: GetRoleProps) => (
  <Get<ResponseRoleResponse, Failure | Error, GetRoleQueryParams, GetRolePathParams>
    path="/roles/${identifier}"
    base={getConfig('authz/api')}
    {...props}
  />
)

export type UseGetRoleProps = Omit<
  UseGetProps<ResponseRoleResponse, Failure | Error, GetRoleQueryParams, GetRolePathParams>,
  'path'
> &
  GetRolePathParams

/**
 * Get Role
 */
export const useGetRole = ({ identifier, ...props }: UseGetRoleProps) =>
  useGet<ResponseRoleResponse, Failure | Error, GetRoleQueryParams, GetRolePathParams>(
    (paramsInPath: GetRolePathParams) => `/roles/${paramsInPath.identifier}`,
    { base: getConfig('authz/api'), pathParams: { identifier }, ...props }
  )

/**
 * Get Role
 */
export const getRolePromise = (
  {
    identifier,
    ...props
  }: GetUsingFetchProps<ResponseRoleResponse, Failure | Error, GetRoleQueryParams, GetRolePathParams> & {
    identifier: string
  },
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseRoleResponse, Failure | Error, GetRoleQueryParams, GetRolePathParams>(
    getConfig('authz/api'),
    `/roles/${identifier}`,
    props,
    signal
  )

export interface UpdateRoleQueryParams {
  accountIdentifier?: string
  orgIdentifier?: string
  projectIdentifier?: string
}

export interface UpdateRolePathParams {
  identifier: string
}

export type UpdateRoleProps = Omit<
  MutateProps<ResponseRoleResponse, Failure | Error, UpdateRoleQueryParams, RoleRequestBody, UpdateRolePathParams>,
  'path' | 'verb'
> &
  UpdateRolePathParams

/**
 * Update Role
 */
export const UpdateRole = ({ identifier, ...props }: UpdateRoleProps) => (
  <Mutate<ResponseRoleResponse, Failure | Error, UpdateRoleQueryParams, RoleRequestBody, UpdateRolePathParams>
    verb="PUT"
    path="/roles/${identifier}"
    base={getConfig('authz/api')}
    {...props}
  />
)

export type UseUpdateRoleProps = Omit<
  UseMutateProps<ResponseRoleResponse, Failure | Error, UpdateRoleQueryParams, RoleRequestBody, UpdateRolePathParams>,
  'path' | 'verb'
> &
  UpdateRolePathParams

/**
 * Update Role
 */
export const useUpdateRole = ({ identifier, ...props }: UseUpdateRoleProps) =>
  useMutate<ResponseRoleResponse, Failure | Error, UpdateRoleQueryParams, RoleRequestBody, UpdateRolePathParams>(
    'PUT',
    (paramsInPath: UpdateRolePathParams) => `/roles/${paramsInPath.identifier}`,
    { base: getConfig('authz/api'), pathParams: { identifier }, ...props }
  )

/**
 * Update Role
 */
export const updateRolePromise = (
  {
    identifier,
    ...props
  }: MutateUsingFetchProps<
    ResponseRoleResponse,
    Failure | Error,
    UpdateRoleQueryParams,
    RoleRequestBody,
    UpdateRolePathParams
  > & { identifier: string },
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<ResponseRoleResponse, Failure | Error, UpdateRoleQueryParams, RoleRequestBody, UpdateRolePathParams>(
    'PUT',
    getConfig('authz/api'),
    `/roles/${identifier}`,
    props,
    signal
  )

export interface DeleteRoleQueryParams {
  accountIdentifier?: string
  orgIdentifier?: string
  projectIdentifier?: string
}

export type DeleteRoleProps = Omit<
  MutateProps<ResponseRoleResponse, Failure | Error, DeleteRoleQueryParams, string, void>,
  'path' | 'verb'
>

/**
 * Delete Role
 */
export const DeleteRole = (props: DeleteRoleProps) => (
  <Mutate<ResponseRoleResponse, Failure | Error, DeleteRoleQueryParams, string, void>
    verb="DELETE"
    path="/roles"
    base={getConfig('authz/api')}
    {...props}
  />
)

export type UseDeleteRoleProps = Omit<
  UseMutateProps<ResponseRoleResponse, Failure | Error, DeleteRoleQueryParams, string, void>,
  'path' | 'verb'
>

/**
 * Delete Role
 */
export const useDeleteRole = (props: UseDeleteRoleProps) =>
  useMutate<ResponseRoleResponse, Failure | Error, DeleteRoleQueryParams, string, void>('DELETE', `/roles`, {
    base: getConfig('authz/api'),
    ...props
  })

/**
 * Delete Role
 */
export const deleteRolePromise = (
  props: MutateUsingFetchProps<ResponseRoleResponse, Failure | Error, DeleteRoleQueryParams, string, void>,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<ResponseRoleResponse, Failure | Error, DeleteRoleQueryParams, string, void>(
    'DELETE',
    getConfig('authz/api'),
    `/roles`,
    props,
    signal
  )

export interface GetRoleListQueryParams {
  pageIndex?: number
  pageSize?: number
  sortOrders?: string[]
  accountIdentifier?: string
  orgIdentifier?: string
  projectIdentifier?: string
  searchTerm?: string
}

export type GetRoleListProps = Omit<
  GetProps<ResponsePageRoleResponse, Failure | Error, GetRoleListQueryParams, void>,
  'path'
>

/**
 * Get Roles
 */
export const GetRoleList = (props: GetRoleListProps) => (
  <Get<ResponsePageRoleResponse, Failure | Error, GetRoleListQueryParams, void>
    path="/roles"
    base={getConfig('authz/api')}
    {...props}
  />
)

export type UseGetRoleListProps = Omit<
  UseGetProps<ResponsePageRoleResponse, Failure | Error, GetRoleListQueryParams, void>,
  'path'
>

/**
 * Get Roles
 */
export const useGetRoleList = (props: UseGetRoleListProps) =>
  useGet<ResponsePageRoleResponse, Failure | Error, GetRoleListQueryParams, void>(`/roles`, {
    base: getConfig('authz/api'),
    ...props
  })

/**
 * Get Roles
 */
export const getRoleListPromise = (
  props: GetUsingFetchProps<ResponsePageRoleResponse, Failure | Error, GetRoleListQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponsePageRoleResponse, Failure | Error, GetRoleListQueryParams, void>(
    getConfig('authz/api'),
    `/roles`,
    props,
    signal
  )

export interface CreateRoleQueryParams {
  accountIdentifier?: string
  orgIdentifier?: string
  projectIdentifier?: string
}

export type CreateRoleProps = Omit<
  MutateProps<ResponseRoleResponse, Failure | Error, CreateRoleQueryParams, RoleRequestBody, void>,
  'path' | 'verb'
>

/**
 * Create Role
 */
export const CreateRole = (props: CreateRoleProps) => (
  <Mutate<ResponseRoleResponse, Failure | Error, CreateRoleQueryParams, RoleRequestBody, void>
    verb="POST"
    path="/roles"
    base={getConfig('authz/api')}
    {...props}
  />
)

export type UseCreateRoleProps = Omit<
  UseMutateProps<ResponseRoleResponse, Failure | Error, CreateRoleQueryParams, RoleRequestBody, void>,
  'path' | 'verb'
>

/**
 * Create Role
 */
export const useCreateRole = (props: UseCreateRoleProps) =>
  useMutate<ResponseRoleResponse, Failure | Error, CreateRoleQueryParams, RoleRequestBody, void>('POST', `/roles`, {
    base: getConfig('authz/api'),
    ...props
  })

/**
 * Create Role
 */
export const createRolePromise = (
  props: MutateUsingFetchProps<ResponseRoleResponse, Failure | Error, CreateRoleQueryParams, RoleRequestBody, void>,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<ResponseRoleResponse, Failure | Error, CreateRoleQueryParams, RoleRequestBody, void>(
    'POST',
    getConfig('authz/api'),
    `/roles`,
    props,
    signal
  )

export interface TestACLQueryParams {
  account?: string
  org?: string
  project?: string
  resourceIdentifier?: string
}

export type TestACLProps = Omit<GetProps<ResponseString, Failure | Error, TestACLQueryParams, void>, 'path'>

/**
 * Test ACL
 */
export const TestACL = (props: TestACLProps) => (
  <Get<ResponseString, Failure | Error, TestACLQueryParams, void>
    path="/acl/acl-test"
    base={getConfig('authz/api')}
    {...props}
  />
)

export type UseTestACLProps = Omit<UseGetProps<ResponseString, Failure | Error, TestACLQueryParams, void>, 'path'>

/**
 * Test ACL
 */
export const useTestACL = (props: UseTestACLProps) =>
  useGet<ResponseString, Failure | Error, TestACLQueryParams, void>(`/acl/acl-test`, {
    base: getConfig('authz/api'),
    ...props
  })

/**
 * Test ACL
 */
export const testACLPromise = (
  props: GetUsingFetchProps<ResponseString, Failure | Error, TestACLQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseString, Failure | Error, TestACLQueryParams, void>(
    getConfig('authz/api'),
    `/acl/acl-test`,
    props,
    signal
  )
