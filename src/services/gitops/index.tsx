/* Generated by restful-react */

import React from 'react'
import { Get, GetProps, useGet, UseGetProps, Mutate, MutateProps, useMutate, UseMutateProps } from 'restful-react'

import { getConfig } from '../config'
export const SPEC_VERSION = 'version not set'
export interface ApplicationApplicationCreateRequest {
  application?: V1alpha1Application
  upsert?: boolean
  validate?: boolean
}

export interface ApplicationApplicationDeleteRequest {
  cascade?: boolean
  name?: string
  propagationPolicy?: string
}

export interface ApplicationApplicationQuery {
  name?: string
  project?: string[]
  refresh?: string
  repo?: string
  /**
   * when specified with a watch call, shows changes that occur after that particular version of a resource.
   */
  resourceVersion?: string
  selector?: string
}

export interface ApplicationApplicationResponse {
  [key: string]: any
}

export interface ApplicationApplicationRollbackRequest {
  dryRun?: boolean
  id?: string
  name?: string
  prune?: boolean
}

export interface ApplicationApplicationSyncRequest {
  dryRun?: boolean
  infos?: V1alpha1Info[]
  manifests?: string[]
  name?: string
  prune?: boolean
  resources?: V1alpha1SyncOperationResource[]
  retryStrategy?: V1alpha1RetryStrategy
  revision?: string
  strategy?: V1alpha1SyncStrategy
  syncOptions?: ApplicationSyncOptions
}

export interface ApplicationApplicationUpdateRequest {
  application?: V1alpha1Application
  validate?: boolean
}

export interface ApplicationSyncOptions {
  items?: string[]
}

export interface Applicationv1alpha1EnvEntry {
  name?: string
  value?: string
}

export interface Applicationv1alpha1HealthStatus {
  message?: string
  status?: string
}

export interface ClusterClusterCreateRequest {
  cluster?: V1alpha1Cluster
  upsert?: boolean
}

export interface ClusterClusterQuery {
  name?: string
  server?: string
}

export interface ClusterClusterResponse {
  [key: string]: any
}

export interface ClusterClusterUpdateRequest {
  cluster?: V1alpha1Cluster
  updatedFields?: string[]
}

export interface GatewayruntimeError {
  code?: number
  details?: ProtobufAny[]
  error?: string
  message?: string
}

export interface ProjectEmptyResponse {
  [key: string]: any
}

/**
 * ProjectCreateRequest defines project creation parameters.
 */
export interface ProjectProjectCreateRequest {
  project?: V1alpha1AppProject
  upsert?: boolean
}

export interface ProjectProjectQuery {
  name?: string
}

export interface ProjectProjectUpdateRequest {
  project?: V1alpha1AppProject
}

export interface ProtobufAny {
  type_url?: string
  value?: string
}

export interface RepositoryRepoCreateRequest {
  credsOnly?: boolean
  repo?: V1alpha1Repository
  upsert?: boolean
}

export interface RepositoryRepoQuery {
  forceRefresh?: boolean
  repo?: string
}

export interface RepositoryRepoResponse {
  [key: string]: any
}

export interface RepositoryRepoUpdateRequest {
  repo?: V1alpha1Repository
}

export interface Servicev1ApplicationCreateRequest {
  agentIdentifier?: string
  request?: ApplicationApplicationCreateRequest
}

export interface Servicev1ApplicationDeleteRequest {
  agentIdentifier?: string
  request?: ApplicationApplicationDeleteRequest
}

export interface Servicev1ApplicationQuery {
  agentIdentifier?: string
  query?: ApplicationApplicationQuery
}

export interface Servicev1ApplicationResponse {
  agentIdentifier?: string
  response?: V1alpha1Application
}

export interface Servicev1ApplicationRollbackRequest {
  agentIdentifier?: string
  request?: ApplicationApplicationRollbackRequest
}

export interface Servicev1ApplicationSyncRequest {
  agentIdentifier?: string
  request?: ApplicationApplicationSyncRequest
}

export interface Servicev1ApplicationUpdateRequest {
  agentIdentifier?: string
  request?: ApplicationApplicationUpdateRequest
}

export interface Servicev1ClusterCreateRequest {
  agentIdentifier?: string
  request?: ClusterClusterCreateRequest
}

export interface Servicev1ClusterUpdateRequest {
  agentIdentifier?: string
  request?: ClusterClusterUpdateRequest
}

export interface Servicev1Error {
  code?: number
  message?: string
  nested_errors?: {
    [key: string]: string
  }
}

export type Servicev1HealthStatus = 'UP' | 'DOWN'

export interface Servicev1ProjectCreateRequest {
  agentIdentifier?: string
  request?: ProjectProjectCreateRequest
}

export interface Servicev1ProjectQuery {
  agentIdentifier?: string
  query?: ProjectProjectQuery
}

export interface Servicev1ProjectUpdateRequest {
  agentIdentifier?: string
  request?: ProjectProjectUpdateRequest
}

export interface V1Agent {
  accountIdentifier?: string
  createdAt?: string
  deploymentMetadata?: V1DeploymentMetadata
  description?: string
  health?: V1AgentHealth
  identifier?: string
  lastModifiedAt?: string
  metadata?: V1AgentMetadata
  name?: string
  orgIdentifier?: string
  projectIdentifier?: string
  tags?: string[]
  type?: V1AgentType
}

export interface V1AgentHealth {
  argoAppController?: Servicev1HealthStatus
  argoDexServer?: Servicev1HealthStatus
  argoRedisServer?: Servicev1HealthStatus
  argoRepoServer?: Servicev1HealthStatus
  harnessGitopsAgent?: Servicev1HealthStatus
  lastHeartbeat?: string
}

export interface V1AgentList {
  items?: V1Agent[]
}

export interface V1AgentMetadata {
  adapterUrl?: string
}

export type V1AgentType = 'CONNECTED_ARGO_PROVIDER' | 'MANAGED_ARGO_PROVIDER'

export interface V1ApplicationDeleteResponse {
  agentIdentifier?: string
}

export interface V1ApplicationListResponse {
  agentIdentifier?: string
  response?: V1alpha1ApplicationList
}

export interface V1DeploymentMetadata {
  nApplications?: number
}

export interface V1Empty {
  [key: string]: any
}

/**
 * FieldsV1 stores a set of fields in a data structure like a Trie, in JSON format.
 *
 * Each key is either a '.' representing the field itself, and will always map to an empty set,
 * or a string representing a sub-field or item. The string will follow one of these four formats:
 * 'f:<name>', where <name> is the name of a field in a struct, or key in a map
 * 'v:<value>', where <value> is the exact json formatted value of a list item
 * 'i:<index>', where <index> is position of a item in a list
 * 'k:<keys>', where <keys> is a map of  a list item's key fields to their unique values
 * If a key maps to an empty Fields value, the field that key represents is part of the set.
 *
 * The exact format is defined in sigs.k8s.io/structured-merge-diff
 * +protobuf.options.(gogoproto.goproto_stringer)=false
 */
export interface V1FieldsV1 {
  /**
   * Raw is the underlying serialization of this object.
   */
  Raw?: string
}

/**
 * +protobuf.options.(gogoproto.goproto_stringer)=false
 */
export interface V1GroupKind {
  group?: string
  kind?: string
}

export interface V1IdentityMeta {
  accountIdentifier?: string
  agentIdentifier?: string
  orgIdentifier?: string
  projectIdentifier?: string
}

/**
 * ListMeta describes metadata that synthetic resources must have, including lists and
 * various status objects. A resource may have only one of {ObjectMeta, ListMeta}.
 */
export interface V1ListMeta {
  /**
   * continue may be set if the user set a limit on the number of items returned, and indicates that
   * the server has more data available. The value is opaque and may be used to issue another request
   * to the endpoint that served this list to retrieve the next set of available objects. Continuing a
   * consistent list may not be possible if the server configuration has changed or more than a few
   * minutes have passed. The resourceVersion field returned when using this continue value will be
   * identical to the value in the first response, unless you have received this token from an error
   * message.
   */
  continue?: string
  remainingItemCount?: string
  resourceVersion?: string
  /**
   * selfLink is a URL representing this object.
   * Populated by the system.
   * Read-only.
   *
   * DEPRECATED
   * Kubernetes will stop propagating this field in 1.20 release and the field is planned
   * to be removed in 1.21 release.
   * +optional
   */
  selfLink?: string
}

/**
 * ManagedFieldsEntry is a workflow-id, a FieldSet and the group version of the resource
 * that the fieldset applies to.
 */
export interface V1ManagedFieldsEntry {
  /**
   * APIVersion defines the version of this resource that this field set
   * applies to. The format is "group/version" just like the top-level
   * APIVersion field. It is necessary to track the version of a field
   * set because it cannot be automatically converted.
   */
  apiVersion?: string
  fieldsType?: string
  fieldsV1?: V1FieldsV1
  /**
   * Manager is an identifier of the workflow managing these fields.
   */
  manager?: string
  /**
   * Operation is the type of operation which lead to this ManagedFieldsEntry being created.
   * The only valid values for this field are 'Apply' and 'Update'.
   */
  operation?: string
  time?: V1Time
}

/**
 * ObjectMeta is metadata that all persisted resources must have, which includes all objects
 * users must create.
 */
export interface V1ObjectMeta {
  annotations?: {
    [key: string]: string
  }
  clusterName?: string
  creationTimestamp?: V1Time
  deletionGracePeriodSeconds?: string
  deletionTimestamp?: V1Time
  finalizers?: string[]
  /**
   * GenerateName is an optional prefix, used by the server, to generate a unique
   * name ONLY IF the Name field has not been provided.
   * If this field is used, the name returned to the client will be different
   * than the name passed. This value will also be combined with a unique suffix.
   * The provided value has the same validation rules as the Name field,
   * and may be truncated by the length of the suffix required to make the value
   * unique on the server.
   *
   * If this field is specified and the generated name exists, the server will
   * NOT return a 409 - instead, it will either return 201 Created or 500 with Reason
   * ServerTimeout indicating a unique name could not be found in the time allotted, and the client
   * should retry (optionally after the time indicated in the Retry-After header).
   *
   * Applied only if Name is not specified.
   * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#idempotency
   * +optional
   */
  generateName?: string
  generation?: string
  labels?: {
    [key: string]: string
  }
  /**
   * ManagedFields maps workflow-id and version to the set of fields
   * that are managed by that workflow. This is mostly for internal
   * housekeeping, and users typically shouldn't need to set or
   * understand this field. A workflow can be the user's name, a
   * controller's name, or the name of a specific apply path like
   * "ci-cd". The set of fields is always in the version that the
   * workflow used when modifying the object.
   *
   * +optional
   */
  managedFields?: V1ManagedFieldsEntry[]
  name?: string
  /**
   * Namespace defines the space within which each name must be unique. An empty namespace is
   * equivalent to the "default" namespace, but "default" is the canonical representation.
   * Not all objects are required to be scoped to a namespace - the value of this field for
   * those objects will be empty.
   *
   * Must be a DNS_LABEL.
   * Cannot be updated.
   * More info: http://kubernetes.io/docs/user-guide/namespaces
   * +optional
   */
  namespace?: string
  ownerReferences?: V1OwnerReference[]
  /**
   * An opaque value that represents the internal version of this object that can
   * be used by clients to determine when objects have changed. May be used for optimistic
   * concurrency, change detection, and the watch operation on a resource or set of resources.
   * Clients must treat these values as opaque and passed unmodified back to the server.
   * They may only be valid for a particular resource or set of resources.
   *
   * Populated by the system.
   * Read-only.
   * Value must be treated as opaque by clients and .
   * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
   * +optional
   */
  resourceVersion?: string
  /**
   * SelfLink is a URL representing this object.
   * Populated by the system.
   * Read-only.
   *
   * DEPRECATED
   * Kubernetes will stop propagating this field in 1.20 release and the field is planned
   * to be removed in 1.21 release.
   * +optional
   */
  selfLink?: string
  /**
   * UID is the unique in time and space value for this object. It is typically generated by
   * the server on successful creation of a resource and is not allowed to change on PUT
   * operations.
   *
   * Populated by the system.
   * Read-only.
   * More info: http://kubernetes.io/docs/user-guide/identifiers#uids
   * +optional
   */
  uid?: string
}

/**
 * OwnerReference contains enough information to let you identify an owning
 * object. An owning object must be in the same namespace as the dependent, or
 * be cluster-scoped, so there is no namespace field.
 */
export interface V1OwnerReference {
  /**
   * API version of the referent.
   */
  apiVersion?: string
  blockOwnerDeletion?: boolean
  controller?: boolean
  kind?: string
  name?: string
  uid?: string
}

export interface V1ProjectDeleteRequest {
  agentIdentifier?: string
  query?: ProjectProjectQuery
}

export interface V1ProjectListResponse {
  agentIdentifier?: string
  projectList?: V1alpha1AppProjectList
}

export interface V1ProjectResponse {
  agentIdentifier?: string
  project?: V1alpha1AppProject
}

export interface V1Task {
  appCreate?: Servicev1ApplicationCreateRequest
  appDelete?: Servicev1ApplicationDeleteRequest
  appGet?: Servicev1ApplicationQuery
  appList?: Servicev1ApplicationQuery
  appRollback?: Servicev1ApplicationRollbackRequest
  appSync?: Servicev1ApplicationSyncRequest
  appUpdate?: Servicev1ApplicationUpdateRequest
  clusterCreate?: Servicev1ClusterCreateRequest
  clusterUpdate?: Servicev1ClusterUpdateRequest
  error?: Servicev1Error
  identifier?: string
  identityMeta?: V1IdentityMeta
  projectCreate?: Servicev1ProjectCreateRequest
  projectDelete?: V1ProjectDeleteRequest
  projectGet?: Servicev1ProjectQuery
  projectList?: Servicev1ProjectQuery
  projectUpdate?: Servicev1ProjectUpdateRequest
}

export interface V1TaskList {
  tasks?: V1Task[]
}

/**
 * Time is a wrapper around time.Time which supports correct
 * marshaling to YAML and JSON.  Wrappers are provided for many
 * of the factory methods that the time package offers.
 *
 * +protobuf.options.marshal=false
 * +protobuf.as=Timestamp
 * +protobuf.options.(gogoproto.goproto_stringer)=false
 */
export interface V1Time {
  /**
   * Non-negative fractions of a second at nanosecond resolution. Negative
   * second values with fractions must still have non-negative nanos values
   * that count forward in time. Must be from 0 to 999,999,999
   * inclusive. This field may be limited in precision depending on context.
   */
  nanos?: number
  /**
   * Represents seconds of UTC time since Unix epoch
   * 1970-01-01T00:00:00Z. Must be from 0001-01-01T00:00:00Z to
   * 9999-12-31T23:59:59Z inclusive.
   */
  seconds?: string
}

export interface V1alpha1AWSAuthConfig {
  clusterName?: string
  /**
   * RoleARN contains optional role ARN. If set then AWS IAM Authenticator assume a role to perform cluster operations instead of the default AWS credential provider chain.
   */
  roleARN?: string
}

export interface V1alpha1AppProject {
  metadata?: V1ObjectMeta
  spec?: V1alpha1AppProjectSpec
  status?: V1alpha1AppProjectStatus
}

export interface V1alpha1AppProjectList {
  items?: V1alpha1AppProject[]
  metadata?: V1ListMeta
}

export interface V1alpha1AppProjectSpec {
  clusterResourceBlacklist?: V1GroupKind[]
  clusterResourceWhitelist?: V1GroupKind[]
  description?: string
  destinations?: V1alpha1ApplicationDestination[]
  namespaceResourceBlacklist?: V1GroupKind[]
  namespaceResourceWhitelist?: V1GroupKind[]
  orphanedResources?: V1alpha1OrphanedResourcesMonitorSettings
  roles?: V1alpha1ProjectRole[]
  signatureKeys?: V1alpha1SignatureKey[]
  sourceRepos?: string[]
  syncWindows?: V1alpha1SyncWindow[]
}

export interface V1alpha1AppProjectStatus {
  jwtTokensByRole?: {
    [key: string]: V1alpha1JWTTokens
  }
}

export interface V1alpha1Application {
  metadata?: V1ObjectMeta
  operation?: V1alpha1Operation
  spec?: V1alpha1ApplicationSpec
  status?: V1alpha1ApplicationStatus
}

export interface V1alpha1ApplicationCondition {
  lastTransitionTime?: V1Time
  message?: string
  type?: string
}

export interface V1alpha1ApplicationDestination {
  name?: string
  namespace?: string
  server?: string
}

export interface V1alpha1ApplicationList {
  items?: V1alpha1Application[]
  metadata?: V1ListMeta
}

export interface V1alpha1ApplicationSource {
  /**
   * Chart is a Helm chart name, and must be specified for applications sourced from a Helm repo.
   */
  chart?: string
  directory?: V1alpha1ApplicationSourceDirectory
  helm?: V1alpha1ApplicationSourceHelm
  ksonnet?: V1alpha1ApplicationSourceKsonnet
  kustomize?: V1alpha1ApplicationSourceKustomize
  /**
   * Path is a directory path within the Git repository, and is only valid for applications sourced from Git.
   */
  path?: string
  plugin?: V1alpha1ApplicationSourcePlugin
  repoURL?: string
  /**
   * TargetRevision defines the revision of the source to sync the application to.
   * In case of Git, this can be commit, tag, or branch. If omitted, will equal to HEAD.
   * In case of Helm, this is a semver tag for the Chart's version.
   */
  targetRevision?: string
}

export interface V1alpha1ApplicationSourceDirectory {
  exclude?: string
  include?: string
  jsonnet?: V1alpha1ApplicationSourceJsonnet
  recurse?: boolean
}

export interface V1alpha1ApplicationSourceHelm {
  fileParameters?: V1alpha1HelmFileParameter[]
  parameters?: V1alpha1HelmParameter[]
  releaseName?: string
  valueFiles?: string[]
  values?: string
  version?: string
}

export interface V1alpha1ApplicationSourceJsonnet {
  extVars?: V1alpha1JsonnetVar[]
  libs?: string[]
  tlas?: V1alpha1JsonnetVar[]
}

export interface V1alpha1ApplicationSourceKsonnet {
  environment?: string
  parameters?: V1alpha1KsonnetParameter[]
}

export interface V1alpha1ApplicationSourceKustomize {
  commonAnnotations?: {
    [key: string]: string
  }
  commonLabels?: {
    [key: string]: string
  }
  forceCommonAnnotations?: boolean
  forceCommonLabels?: boolean
  images?: string[]
  namePrefix?: string
  nameSuffix?: string
  version?: string
}

export interface V1alpha1ApplicationSourcePlugin {
  env?: Applicationv1alpha1EnvEntry[]
  name?: string
}

/**
 * ApplicationSpec represents desired application state. Contains link to repository with application definition and additional parameters link definition revision.
 */
export interface V1alpha1ApplicationSpec {
  destination?: V1alpha1ApplicationDestination
  ignoreDifferences?: V1alpha1ResourceIgnoreDifferences[]
  info?: V1alpha1Info[]
  /**
   * Project is a reference to the project this application belongs to.
   * The empty string means that application belongs to the 'default' project.
   */
  project?: string
  /**
   * RevisionHistoryLimit limits the number of items kept in the application's revision history, which is used for informational purposes as well as for rollbacks to previous versions.
   * This should only be changed in exceptional circumstances.
   * Setting to zero will store no history. This will reduce storage used.
   * Increasing will increase the space used to store the history, so we do not recommend increasing it.
   * Default is 10.
   */
  revisionHistoryLimit?: string
  source?: V1alpha1ApplicationSource
  syncPolicy?: V1alpha1SyncPolicy
}

export interface V1alpha1ApplicationStatus {
  conditions?: V1alpha1ApplicationCondition[]
  health?: Applicationv1alpha1HealthStatus
  history?: V1alpha1RevisionHistory[]
  observedAt?: V1Time
  operationState?: V1alpha1OperationState
  reconciledAt?: V1Time
  resources?: V1alpha1ResourceStatus[]
  sourceType?: string
  summary?: V1alpha1ApplicationSummary
  sync?: V1alpha1SyncStatus
}

export interface V1alpha1ApplicationSummary {
  /**
   * ExternalURLs holds all external URLs of application child resources.
   */
  externalURLs?: string[]
  /**
   * Images holds all images of application child resources.
   */
  images?: string[]
}

export interface V1alpha1Backoff {
  duration?: string
  factor?: string
  maxDuration?: string
}

export interface V1alpha1Cluster {
  /**
   * Indicates if cluster level resources should be managed. This setting is used only if cluster is connected in a namespaced mode.
   */
  clusterResources?: boolean
  config?: V1alpha1ClusterConfig
  connectionState?: V1alpha1ConnectionState
  info?: V1alpha1ClusterInfo
  name?: string
  /**
   * Holds list of namespaces which are accessible in that cluster. Cluster level resources will be ignored if namespace list is not empty.
   */
  namespaces?: string[]
  refreshRequestedAt?: V1Time
  server?: string
  serverVersion?: string
  /**
   * Shard contains optional shard number. Calculated on the fly by the application controller if not specified.
   */
  shard?: string
}

export interface V1alpha1ClusterCacheInfo {
  apisCount?: string
  lastCacheSyncTime?: V1Time
  resourcesCount?: string
}

/**
 * ClusterConfig is the configuration attributes. This structure is subset of the go-client
 * rest.Config with annotations added for marshalling.
 */
export interface V1alpha1ClusterConfig {
  awsAuthConfig?: V1alpha1AWSAuthConfig
  /**
   * Server requires Bearer authentication. This client will not attempt to use
   * refresh tokens for an OAuth2 flow.
   * TODO: demonstrate an OAuth2 compatible client.
   */
  bearerToken?: string
  execProviderConfig?: V1alpha1ExecProviderConfig
  password?: string
  tlsClientConfig?: V1alpha1TLSClientConfig
  username?: string
}

export interface V1alpha1ClusterInfo {
  apiVersions?: string[]
  applicationsCount?: string
  cacheInfo?: V1alpha1ClusterCacheInfo
  connectionState?: V1alpha1ConnectionState
  serverVersion?: string
}

/**
 * ClusterList is a collection of Clusters.
 */
export interface V1alpha1ClusterList {
  items?: V1alpha1Cluster[]
  metadata?: V1ListMeta
}

export interface V1alpha1ComparedTo {
  destination?: V1alpha1ApplicationDestination
  source?: V1alpha1ApplicationSource
}

export interface V1alpha1ConnectionState {
  attemptedAt?: V1Time
  message?: string
  status?: string
}

export interface V1alpha1ExecProviderConfig {
  apiVersion?: string
  args?: string[]
  command?: string
  env?: {
    [key: string]: string
  }
  installHint?: string
}

export interface V1alpha1HelmFileParameter {
  name?: string
  path?: string
}

export interface V1alpha1HelmParameter {
  forceString?: boolean
  name?: string
  value?: string
}

export interface V1alpha1Info {
  name?: string
  value?: string
}

export interface V1alpha1JWTToken {
  exp?: string
  iat?: string
  id?: string
}

export interface V1alpha1JWTTokens {
  items?: V1alpha1JWTToken[]
}

export interface V1alpha1JsonnetVar {
  code?: boolean
  name?: string
  value?: string
}

export interface V1alpha1KsonnetParameter {
  component?: string
  name?: string
  value?: string
}

export interface V1alpha1Operation {
  info?: V1alpha1Info[]
  initiatedBy?: V1alpha1OperationInitiator
  retry?: V1alpha1RetryStrategy
  sync?: V1alpha1SyncOperation
}

export interface V1alpha1OperationInitiator {
  /**
   * Automated is set to true if operation was initiated automatically by the application controller.
   */
  automated?: boolean
  username?: string
}

export interface V1alpha1OperationState {
  finishedAt?: V1Time
  /**
   * Message holds any pertinent messages when attempting to perform operation (typically errors).
   */
  message?: string
  operation?: V1alpha1Operation
  phase?: string
  retryCount?: string
  startedAt?: V1Time
  syncResult?: V1alpha1SyncOperationResult
}

export interface V1alpha1OrphanedResourceKey {
  group?: string
  kind?: string
  name?: string
}

export interface V1alpha1OrphanedResourcesMonitorSettings {
  ignore?: V1alpha1OrphanedResourceKey[]
  warn?: boolean
}

export interface V1alpha1ProjectRole {
  description?: string
  groups?: string[]
  jwtTokens?: V1alpha1JWTToken[]
  name?: string
  policies?: string[]
}

export interface V1alpha1Repository {
  connectionState?: V1alpha1ConnectionState
  /**
   * EnableLFS specifies whether git-lfs support should be enabled for this repo. Only valid for Git repositories.
   */
  enableLfs?: boolean
  enableOCI?: boolean
  githubAppEnterpriseBaseUrl?: string
  githubAppID?: string
  githubAppInstallationID?: string
  githubAppPrivateKey?: string
  inheritedCreds?: boolean
  insecure?: boolean
  insecureIgnoreHostKey?: boolean
  name?: string
  password?: string
  proxy?: string
  repo?: string
  /**
   * SSHPrivateKey contains the PEM data for authenticating at the repo server. Only used with Git repos.
   */
  sshPrivateKey?: string
  tlsClientCertData?: string
  tlsClientCertKey?: string
  /**
   * Type specifies the type of the repo. Can be either "git" or "helm. "git" is assumed if empty or absent.
   */
  type?: string
  username?: string
}

/**
 * RepositoryList is a collection of Repositories.
 */
export interface V1alpha1RepositoryList {
  items?: V1alpha1Repository[]
  metadata?: V1ListMeta
}

/**
 * ResourceIgnoreDifferences contains resource filter and list of json paths which should be ignored during comparison with live state.
 */
export interface V1alpha1ResourceIgnoreDifferences {
  group?: string
  jqPathExpressions?: string[]
  jsonPointers?: string[]
  kind?: string
  name?: string
  namespace?: string
}

export interface V1alpha1ResourceResult {
  group?: string
  /**
   * HookPhase contains the state of any operation associated with this resource OR hook
   * This can also contain values for non-hook resources.
   */
  hookPhase?: string
  hookType?: string
  kind?: string
  message?: string
  name?: string
  namespace?: string
  status?: string
  syncPhase?: string
  version?: string
}

export interface V1alpha1ResourceStatus {
  group?: string
  health?: Applicationv1alpha1HealthStatus
  hook?: boolean
  kind?: string
  name?: string
  namespace?: string
  requiresPruning?: boolean
  status?: string
  version?: string
}

export interface V1alpha1RetryStrategy {
  backoff?: V1alpha1Backoff
  /**
   * Limit is the maximum number of attempts for retrying a failed sync. If set to 0, no retries will be performed.
   */
  limit?: string
}

export interface V1alpha1RevisionHistory {
  deployStartedAt?: V1Time
  deployedAt?: V1Time
  id?: string
  revision?: string
  source?: V1alpha1ApplicationSource
}

export interface V1alpha1SignatureKey {
  keyID?: string
}

/**
 * SyncOperation contains details about a sync operation.
 */
export interface V1alpha1SyncOperation {
  dryRun?: boolean
  manifests?: string[]
  prune?: boolean
  resources?: V1alpha1SyncOperationResource[]
  /**
   * Revision is the revision (Git) or chart version (Helm) which to sync the application to
   * If omitted, will use the revision specified in app spec.
   */
  revision?: string
  source?: V1alpha1ApplicationSource
  syncOptions?: string[]
  syncStrategy?: V1alpha1SyncStrategy
}

/**
 * SyncOperationResource contains resources to sync.
 */
export interface V1alpha1SyncOperationResource {
  group?: string
  kind?: string
  name?: string
  namespace?: string
}

export interface V1alpha1SyncOperationResult {
  resources?: V1alpha1ResourceResult[]
  revision?: string
  source?: V1alpha1ApplicationSource
}

export interface V1alpha1SyncPolicy {
  automated?: V1alpha1SyncPolicyAutomated
  retry?: V1alpha1RetryStrategy
  syncOptions?: string[]
}

export interface V1alpha1SyncPolicyAutomated {
  allowEmpty?: boolean
  prune?: boolean
  selfHeal?: boolean
}

export interface V1alpha1SyncStatus {
  comparedTo?: V1alpha1ComparedTo
  revision?: string
  status?: string
}

export interface V1alpha1SyncStrategy {
  apply?: V1alpha1SyncStrategyApply
  hook?: V1alpha1SyncStrategyHook
}

export interface V1alpha1SyncStrategyApply {
  /**
   * Force indicates whether or not to supply the --force flag to `kubectl apply`.
   * The --force flag deletes and re-create the resource, when PATCH encounters conflict and has
   * retried for 5 times.
   */
  force?: boolean
}

/**
 * SyncStrategyHook will perform a sync using hooks annotations.
 * If no hook annotation is specified falls back to `kubectl apply`.
 */
export interface V1alpha1SyncStrategyHook {
  syncStrategyApply?: V1alpha1SyncStrategyApply
}

export interface V1alpha1SyncWindow {
  applications?: string[]
  clusters?: string[]
  duration?: string
  kind?: string
  manualSync?: boolean
  namespaces?: string[]
  schedule?: string
}

export interface V1alpha1TLSClientConfig {
  caData?: string
  certData?: string
  /**
   * Insecure specifies that the server should be accessed without verifying the TLS certificate. For testing only.
   */
  insecure?: boolean
  keyData?: string
  /**
   * ServerName is passed to the server for SNI and is used in the client to check server
   * certificates against. If ServerName is empty, the hostname used to contact the
   * server is used.
   */
  serverName?: string
}

export type V1AgentRequestBody = V1Agent

export interface AgentServiceListQueryParams {
  accountIdentifier?: string
  projectIdentifier?: string
  orgIdentifier?: string
  identifier?: string
  name?: string
  type?: 'CONNECTED_ARGO_PROVIDER' | 'MANAGED_ARGO_PROVIDER'
  tags?: string[]
}

export type AgentServiceListProps = Omit<
  GetProps<V1AgentList, GatewayruntimeError, AgentServiceListQueryParams, void>,
  'path'
>

export const AgentServiceList = (props: AgentServiceListProps) => (
  <Get<V1AgentList, GatewayruntimeError, AgentServiceListQueryParams, void>
    path={`/api/v1/agents`}
    base={getConfig('gitops-api')}
    {...props}
  />
)

export type UseAgentServiceListProps = Omit<
  UseGetProps<V1AgentList, GatewayruntimeError, AgentServiceListQueryParams, void>,
  'path'
>

export const useAgentServiceList = (props: UseAgentServiceListProps) =>
  useGet<V1AgentList, GatewayruntimeError, AgentServiceListQueryParams, void>(`/api/v1/agents`, {
    base: getConfig('gitops-api'),
    ...props
  })

export type AgentServiceCreateProps = Omit<
  MutateProps<V1Agent, GatewayruntimeError, void, V1AgentRequestBody, void>,
  'path' | 'verb'
>

export const AgentServiceCreate = (props: AgentServiceCreateProps) => (
  <Mutate<V1Agent, GatewayruntimeError, void, V1AgentRequestBody, void>
    verb="POST"
    path={`/api/v1/agents`}
    base={getConfig('gitops-api')}
    {...props}
  />
)

export type UseAgentServiceCreateProps = Omit<
  UseMutateProps<V1Agent, GatewayruntimeError, void, V1AgentRequestBody, void>,
  'path' | 'verb'
>

export const useAgentServiceCreate = (props: UseAgentServiceCreateProps) =>
  useMutate<V1Agent, GatewayruntimeError, void, V1AgentRequestBody, void>('POST', `/api/v1/agents`, {
    base: getConfig('gitops-api'),
    ...props
  })

export interface AgentServiceUpdatePathParams {
  /**
   * The gitops-server generated ID for this gitops-agent
   */
  agentIdentifier: string
}

export type AgentServiceUpdateProps = Omit<
  MutateProps<V1Agent, GatewayruntimeError, void, V1AgentRequestBody, AgentServiceUpdatePathParams>,
  'path' | 'verb'
> &
  AgentServiceUpdatePathParams

export const AgentServiceUpdate = ({ agentIdentifier, ...props }: AgentServiceUpdateProps) => (
  <Mutate<V1Agent, GatewayruntimeError, void, V1AgentRequestBody, AgentServiceUpdatePathParams>
    verb="PUT"
    path={`/api/v1/agents/${agentIdentifier}`}
    base={getConfig('gitops-api')}
    {...props}
  />
)

export type UseAgentServiceUpdateProps = Omit<
  UseMutateProps<V1Agent, GatewayruntimeError, void, V1AgentRequestBody, AgentServiceUpdatePathParams>,
  'path' | 'verb'
> &
  AgentServiceUpdatePathParams

export const useAgentServiceUpdate = ({ agentIdentifier, ...props }: UseAgentServiceUpdateProps) =>
  useMutate<V1Agent, GatewayruntimeError, void, V1AgentRequestBody, AgentServiceUpdatePathParams>(
    'PUT',
    (paramsInPath: AgentServiceUpdatePathParams) => `/api/v1/agents/${paramsInPath.agentIdentifier}`,
    { base: getConfig('gitops-api'), pathParams: { agentIdentifier }, ...props }
  )

export interface ApplicationServiceListQueryParams {
  /**
   * the application's name.
   */
  'query.name'?: string
  /**
   * forces application reconciliation if set to true.
   */
  'query.refresh'?: string
  /**
   * the project names to restrict returned list applications.
   */
  'query.project'?: string[]
  /**
   * when specified with a watch call, shows changes that occur after that particular version of a resource.
   */
  'query.resourceVersion'?: string
  /**
   * the selector to to restrict returned list to applications only with matched labels.
   */
  'query.selector'?: string
  /**
   * the repoURL to restrict returned list applications.
   */
  'query.repo'?: string
}

export interface ApplicationServiceListPathParams {
  agentIdentifier: string
}

export type ApplicationServiceListProps = Omit<
  GetProps<
    V1alpha1ApplicationList,
    GatewayruntimeError,
    ApplicationServiceListQueryParams,
    ApplicationServiceListPathParams
  >,
  'path'
> &
  ApplicationServiceListPathParams

/**
 * List returns list of applications
 */
export const ApplicationServiceList = ({ agentIdentifier, ...props }: ApplicationServiceListProps) => (
  <Get<
    V1alpha1ApplicationList,
    GatewayruntimeError,
    ApplicationServiceListQueryParams,
    ApplicationServiceListPathParams
  >
    path={`/api/v1/agents/${agentIdentifier}/applications`}
    base={getConfig('gitops-api')}
    {...props}
  />
)

export type UseApplicationServiceListProps = Omit<
  UseGetProps<
    V1alpha1ApplicationList,
    GatewayruntimeError,
    ApplicationServiceListQueryParams,
    ApplicationServiceListPathParams
  >,
  'path'
> &
  ApplicationServiceListPathParams

/**
 * List returns list of applications
 */
export const useApplicationServiceList = ({ agentIdentifier, ...props }: UseApplicationServiceListProps) =>
  useGet<
    V1alpha1ApplicationList,
    GatewayruntimeError,
    ApplicationServiceListQueryParams,
    ApplicationServiceListPathParams
  >((paramsInPath: ApplicationServiceListPathParams) => `/api/v1/agents/${paramsInPath.agentIdentifier}/applications`, {
    base: getConfig('gitops-api'),
    pathParams: { agentIdentifier },
    ...props
  })

export interface ApplicationServiceCreatePathParams {
  agentIdentifier: string
}

export type ApplicationServiceCreateProps = Omit<
  MutateProps<
    V1alpha1Application,
    GatewayruntimeError,
    void,
    ApplicationApplicationCreateRequest,
    ApplicationServiceCreatePathParams
  >,
  'path' | 'verb'
> &
  ApplicationServiceCreatePathParams

/**
 * Create creates an application
 */
export const ApplicationServiceCreate = ({ agentIdentifier, ...props }: ApplicationServiceCreateProps) => (
  <Mutate<
    V1alpha1Application,
    GatewayruntimeError,
    void,
    ApplicationApplicationCreateRequest,
    ApplicationServiceCreatePathParams
  >
    verb="POST"
    path={`/api/v1/agents/${agentIdentifier}/applications`}
    base={getConfig('gitops-api')}
    {...props}
  />
)

export type UseApplicationServiceCreateProps = Omit<
  UseMutateProps<
    V1alpha1Application,
    GatewayruntimeError,
    void,
    ApplicationApplicationCreateRequest,
    ApplicationServiceCreatePathParams
  >,
  'path' | 'verb'
> &
  ApplicationServiceCreatePathParams

/**
 * Create creates an application
 */
export const useApplicationServiceCreate = ({ agentIdentifier, ...props }: UseApplicationServiceCreateProps) =>
  useMutate<
    V1alpha1Application,
    GatewayruntimeError,
    void,
    ApplicationApplicationCreateRequest,
    ApplicationServiceCreatePathParams
  >(
    'POST',
    (paramsInPath: ApplicationServiceCreatePathParams) => `/api/v1/agents/${paramsInPath.agentIdentifier}/applications`,
    { base: getConfig('gitops-api'), pathParams: { agentIdentifier }, ...props }
  )

export interface ApplicationServiceGetQueryParams {
  /**
   * forces application reconciliation if set to true.
   */
  'query.refresh'?: string
  /**
   * the project names to restrict returned list applications.
   */
  'query.project'?: string[]
  /**
   * when specified with a watch call, shows changes that occur after that particular version of a resource.
   */
  'query.resourceVersion'?: string
  /**
   * the selector to to restrict returned list to applications only with matched labels.
   */
  'query.selector'?: string
  /**
   * the repoURL to restrict returned list applications.
   */
  'query.repo'?: string
}

export interface ApplicationServiceGetPathParams {
  agentIdentifier: string
  /**
   * the application's name
   */
  queryName: string
}

export type ApplicationServiceGetProps = Omit<
  GetProps<V1alpha1Application, GatewayruntimeError, ApplicationServiceGetQueryParams, ApplicationServiceGetPathParams>,
  'path'
> &
  ApplicationServiceGetPathParams

/**
 * Get returns an application by name
 */
export const ApplicationServiceGet = ({ agentIdentifier, queryName, ...props }: ApplicationServiceGetProps) => (
  <Get<V1alpha1Application, GatewayruntimeError, ApplicationServiceGetQueryParams, ApplicationServiceGetPathParams>
    path={`/api/v1/agents/${agentIdentifier}/applications/${queryName}`}
    base={getConfig('gitops-api')}
    {...props}
  />
)

export type UseApplicationServiceGetProps = Omit<
  UseGetProps<
    V1alpha1Application,
    GatewayruntimeError,
    ApplicationServiceGetQueryParams,
    ApplicationServiceGetPathParams
  >,
  'path'
> &
  ApplicationServiceGetPathParams

/**
 * Get returns an application by name
 */
export const useApplicationServiceGet = ({ agentIdentifier, queryName, ...props }: UseApplicationServiceGetProps) =>
  useGet<V1alpha1Application, GatewayruntimeError, ApplicationServiceGetQueryParams, ApplicationServiceGetPathParams>(
    (paramsInPath: ApplicationServiceGetPathParams) =>
      `/api/v1/agents/${paramsInPath.agentIdentifier}/applications/${paramsInPath.queryName}`,
    { base: getConfig('gitops-api'), pathParams: { agentIdentifier, queryName }, ...props }
  )

export interface ApplicationServiceUpdatePathParams {
  agentIdentifier: string
  /**
   * Name must be unique within a namespace. Is required when creating resources, although
   * some resources may allow a client to request the generation of an appropriate name
   * automatically. Name is primarily intended for creation idempotence and configuration
   * definition.
   * Cannot be updated.
   * More info: http://kubernetes.io/docs/user-guide/identifiers#names
   * +optional
   */
  requestApplicationMetadataName: string
}

export type ApplicationServiceUpdateProps = Omit<
  MutateProps<
    V1alpha1Application,
    GatewayruntimeError,
    void,
    ApplicationApplicationUpdateRequest,
    ApplicationServiceUpdatePathParams
  >,
  'path' | 'verb'
> &
  ApplicationServiceUpdatePathParams

/**
 * Update updates an application
 */
export const ApplicationServiceUpdate = ({
  agentIdentifier,
  requestApplicationMetadataName,
  ...props
}: ApplicationServiceUpdateProps) => (
  <Mutate<
    V1alpha1Application,
    GatewayruntimeError,
    void,
    ApplicationApplicationUpdateRequest,
    ApplicationServiceUpdatePathParams
  >
    verb="PUT"
    path={`/api/v1/agents/${agentIdentifier}/applications/${requestApplicationMetadataName}`}
    base={getConfig('gitops-api')}
    {...props}
  />
)

export type UseApplicationServiceUpdateProps = Omit<
  UseMutateProps<
    V1alpha1Application,
    GatewayruntimeError,
    void,
    ApplicationApplicationUpdateRequest,
    ApplicationServiceUpdatePathParams
  >,
  'path' | 'verb'
> &
  ApplicationServiceUpdatePathParams

/**
 * Update updates an application
 */
export const useApplicationServiceUpdate = ({
  agentIdentifier,
  requestApplicationMetadataName,
  ...props
}: UseApplicationServiceUpdateProps) =>
  useMutate<
    V1alpha1Application,
    GatewayruntimeError,
    void,
    ApplicationApplicationUpdateRequest,
    ApplicationServiceUpdatePathParams
  >(
    'PUT',
    (paramsInPath: ApplicationServiceUpdatePathParams) =>
      `/api/v1/agents/${paramsInPath.agentIdentifier}/applications/${paramsInPath.requestApplicationMetadataName}`,
    { base: getConfig('gitops-api'), pathParams: { agentIdentifier, requestApplicationMetadataName }, ...props }
  )

export interface ApplicationServiceDeleteQueryParams {
  'request.cascade'?: boolean
  'request.propagationPolicy'?: string
}

export interface ApplicationServiceDeletePathParams {
  agentIdentifier: string
}

export type ApplicationServiceDeleteProps = Omit<
  MutateProps<
    ApplicationApplicationResponse,
    GatewayruntimeError,
    ApplicationServiceDeleteQueryParams,
    string,
    ApplicationServiceDeletePathParams
  >,
  'path' | 'verb'
> &
  ApplicationServiceDeletePathParams

/**
 * Delete deletes an application
 */
export const ApplicationServiceDelete = ({ agentIdentifier, ...props }: ApplicationServiceDeleteProps) => (
  <Mutate<
    ApplicationApplicationResponse,
    GatewayruntimeError,
    ApplicationServiceDeleteQueryParams,
    string,
    ApplicationServiceDeletePathParams
  >
    verb="DELETE"
    path={`/api/v1/agents/${agentIdentifier}/applications`}
    base={getConfig('gitops-api')}
    {...props}
  />
)

export type UseApplicationServiceDeleteProps = Omit<
  UseMutateProps<
    ApplicationApplicationResponse,
    GatewayruntimeError,
    ApplicationServiceDeleteQueryParams,
    string,
    ApplicationServiceDeletePathParams
  >,
  'path' | 'verb'
> &
  ApplicationServiceDeletePathParams

/**
 * Delete deletes an application
 */
export const useApplicationServiceDelete = ({ agentIdentifier, ...props }: UseApplicationServiceDeleteProps) =>
  useMutate<
    ApplicationApplicationResponse,
    GatewayruntimeError,
    ApplicationServiceDeleteQueryParams,
    string,
    ApplicationServiceDeletePathParams
  >(
    'DELETE',
    (paramsInPath: ApplicationServiceDeletePathParams) => `/api/v1/agents/${paramsInPath.agentIdentifier}/applications`,
    { base: getConfig('gitops-api'), pathParams: { agentIdentifier }, ...props }
  )

export interface ApplicationServiceRollbackPathParams {
  agentIdentifier: string
  requestName: string
}

export type ApplicationServiceRollbackProps = Omit<
  MutateProps<
    V1alpha1Application,
    GatewayruntimeError,
    void,
    ApplicationApplicationRollbackRequest,
    ApplicationServiceRollbackPathParams
  >,
  'path' | 'verb'
> &
  ApplicationServiceRollbackPathParams

/**
 * Rollback syncs an application to its target state
 */
export const ApplicationServiceRollback = ({
  agentIdentifier,
  requestName,
  ...props
}: ApplicationServiceRollbackProps) => (
  <Mutate<
    V1alpha1Application,
    GatewayruntimeError,
    void,
    ApplicationApplicationRollbackRequest,
    ApplicationServiceRollbackPathParams
  >
    verb="POST"
    path={`/api/v1/agents/${agentIdentifier}/applications/${requestName}/rollback`}
    base={getConfig('gitops-api')}
    {...props}
  />
)

export type UseApplicationServiceRollbackProps = Omit<
  UseMutateProps<
    V1alpha1Application,
    GatewayruntimeError,
    void,
    ApplicationApplicationRollbackRequest,
    ApplicationServiceRollbackPathParams
  >,
  'path' | 'verb'
> &
  ApplicationServiceRollbackPathParams

/**
 * Rollback syncs an application to its target state
 */
export const useApplicationServiceRollback = ({
  agentIdentifier,
  requestName,
  ...props
}: UseApplicationServiceRollbackProps) =>
  useMutate<
    V1alpha1Application,
    GatewayruntimeError,
    void,
    ApplicationApplicationRollbackRequest,
    ApplicationServiceRollbackPathParams
  >(
    'POST',
    (paramsInPath: ApplicationServiceRollbackPathParams) =>
      `/api/v1/agents/${paramsInPath.agentIdentifier}/applications/${paramsInPath.requestName}/rollback`,
    { base: getConfig('gitops-api'), pathParams: { agentIdentifier, requestName }, ...props }
  )

export interface ApplicationServiceSyncPathParams {
  agentIdentifier: string
  requestName: string
}

export type ApplicationServiceSyncProps = Omit<
  MutateProps<
    V1alpha1Application,
    GatewayruntimeError,
    void,
    ApplicationApplicationSyncRequest,
    ApplicationServiceSyncPathParams
  >,
  'path' | 'verb'
> &
  ApplicationServiceSyncPathParams

/**
 * Sync syncs an application to its target state
 */
export const ApplicationServiceSync = ({ agentIdentifier, requestName, ...props }: ApplicationServiceSyncProps) => (
  <Mutate<
    V1alpha1Application,
    GatewayruntimeError,
    void,
    ApplicationApplicationSyncRequest,
    ApplicationServiceSyncPathParams
  >
    verb="POST"
    path={`/api/v1/agents/${agentIdentifier}/applications/${requestName}/sync`}
    base={getConfig('gitops-api')}
    {...props}
  />
)

export type UseApplicationServiceSyncProps = Omit<
  UseMutateProps<
    V1alpha1Application,
    GatewayruntimeError,
    void,
    ApplicationApplicationSyncRequest,
    ApplicationServiceSyncPathParams
  >,
  'path' | 'verb'
> &
  ApplicationServiceSyncPathParams

/**
 * Sync syncs an application to its target state
 */
export const useApplicationServiceSync = ({ agentIdentifier, requestName, ...props }: UseApplicationServiceSyncProps) =>
  useMutate<
    V1alpha1Application,
    GatewayruntimeError,
    void,
    ApplicationApplicationSyncRequest,
    ApplicationServiceSyncPathParams
  >(
    'POST',
    (paramsInPath: ApplicationServiceSyncPathParams) =>
      `/api/v1/agents/${paramsInPath.agentIdentifier}/applications/${paramsInPath.requestName}/sync`,
    { base: getConfig('gitops-api'), pathParams: { agentIdentifier, requestName }, ...props }
  )

export interface ClusterServiceListQueryParams {
  'query.server'?: string
  'query.name'?: string
}

export interface ClusterServiceListPathParams {
  agentIdentifier: string
}

export type ClusterServiceListProps = Omit<
  GetProps<V1alpha1ClusterList, GatewayruntimeError, ClusterServiceListQueryParams, ClusterServiceListPathParams>,
  'path'
> &
  ClusterServiceListPathParams

/**
 * List returns list of clusters
 */
export const ClusterServiceList = ({ agentIdentifier, ...props }: ClusterServiceListProps) => (
  <Get<V1alpha1ClusterList, GatewayruntimeError, ClusterServiceListQueryParams, ClusterServiceListPathParams>
    path={`/api/v1/agents/${agentIdentifier}/clusters`}
    base={getConfig('gitops-api')}
    {...props}
  />
)

export type UseClusterServiceListProps = Omit<
  UseGetProps<V1alpha1ClusterList, GatewayruntimeError, ClusterServiceListQueryParams, ClusterServiceListPathParams>,
  'path'
> &
  ClusterServiceListPathParams

/**
 * List returns list of clusters
 */
export const useClusterServiceList = ({ agentIdentifier, ...props }: UseClusterServiceListProps) =>
  useGet<V1alpha1ClusterList, GatewayruntimeError, ClusterServiceListQueryParams, ClusterServiceListPathParams>(
    (paramsInPath: ClusterServiceListPathParams) => `/api/v1/agents/${paramsInPath.agentIdentifier}/clusters`,
    { base: getConfig('gitops-api'), pathParams: { agentIdentifier }, ...props }
  )

export interface ClusterServiceCreatePathParams {
  agentIdentifier: string
}

export type ClusterServiceCreateProps = Omit<
  MutateProps<V1alpha1Cluster, GatewayruntimeError, void, ClusterClusterCreateRequest, ClusterServiceCreatePathParams>,
  'path' | 'verb'
> &
  ClusterServiceCreatePathParams

/**
 * Create creates a cluster
 */
export const ClusterServiceCreate = ({ agentIdentifier, ...props }: ClusterServiceCreateProps) => (
  <Mutate<V1alpha1Cluster, GatewayruntimeError, void, ClusterClusterCreateRequest, ClusterServiceCreatePathParams>
    verb="POST"
    path={`/api/v1/agents/${agentIdentifier}/clusters`}
    base={getConfig('gitops-api')}
    {...props}
  />
)

export type UseClusterServiceCreateProps = Omit<
  UseMutateProps<
    V1alpha1Cluster,
    GatewayruntimeError,
    void,
    ClusterClusterCreateRequest,
    ClusterServiceCreatePathParams
  >,
  'path' | 'verb'
> &
  ClusterServiceCreatePathParams

/**
 * Create creates a cluster
 */
export const useClusterServiceCreate = ({ agentIdentifier, ...props }: UseClusterServiceCreateProps) =>
  useMutate<V1alpha1Cluster, GatewayruntimeError, void, ClusterClusterCreateRequest, ClusterServiceCreatePathParams>(
    'POST',
    (paramsInPath: ClusterServiceCreatePathParams) => `/api/v1/agents/${paramsInPath.agentIdentifier}/clusters`,
    { base: getConfig('gitops-api'), pathParams: { agentIdentifier }, ...props }
  )

export interface ClusterServiceDeleteQueryParams {
  'query.name'?: string
}

export interface ClusterServiceDeletePathParams {
  agentIdentifier: string
}

export type ClusterServiceDeleteProps = Omit<
  MutateProps<
    ClusterClusterResponse,
    GatewayruntimeError,
    ClusterServiceDeleteQueryParams,
    string,
    ClusterServiceDeletePathParams
  >,
  'path' | 'verb'
> &
  ClusterServiceDeletePathParams

/**
 * Delete deletes a cluster
 */
export const ClusterServiceDelete = ({ agentIdentifier, ...props }: ClusterServiceDeleteProps) => (
  <Mutate<
    ClusterClusterResponse,
    GatewayruntimeError,
    ClusterServiceDeleteQueryParams,
    string,
    ClusterServiceDeletePathParams
  >
    verb="DELETE"
    path={`/api/v1/agents/${agentIdentifier}/clusters`}
    base={getConfig('gitops-api')}
    {...props}
  />
)

export type UseClusterServiceDeleteProps = Omit<
  UseMutateProps<
    ClusterClusterResponse,
    GatewayruntimeError,
    ClusterServiceDeleteQueryParams,
    string,
    ClusterServiceDeletePathParams
  >,
  'path' | 'verb'
> &
  ClusterServiceDeletePathParams

/**
 * Delete deletes a cluster
 */
export const useClusterServiceDelete = ({ agentIdentifier, ...props }: UseClusterServiceDeleteProps) =>
  useMutate<
    ClusterClusterResponse,
    GatewayruntimeError,
    ClusterServiceDeleteQueryParams,
    string,
    ClusterServiceDeletePathParams
  >(
    'DELETE',
    (paramsInPath: ClusterServiceDeletePathParams) => `/api/v1/agents/${paramsInPath.agentIdentifier}/clusters`,
    { base: getConfig('gitops-api'), pathParams: { agentIdentifier }, ...props }
  )

export interface ClusterServiceGetQueryParams {
  'query.name'?: string
}

export interface ClusterServiceGetPathParams {
  agentIdentifier: string
  queryServer: string
}

export type ClusterServiceGetProps = Omit<
  GetProps<V1alpha1Cluster, GatewayruntimeError, ClusterServiceGetQueryParams, ClusterServiceGetPathParams>,
  'path'
> &
  ClusterServiceGetPathParams

/**
 * Get returns a cluster by server address
 */
export const ClusterServiceGet = ({ agentIdentifier, queryServer, ...props }: ClusterServiceGetProps) => (
  <Get<V1alpha1Cluster, GatewayruntimeError, ClusterServiceGetQueryParams, ClusterServiceGetPathParams>
    path={`/api/v1/agents/${agentIdentifier}/clusters/${queryServer}`}
    base={getConfig('gitops-api')}
    {...props}
  />
)

export type UseClusterServiceGetProps = Omit<
  UseGetProps<V1alpha1Cluster, GatewayruntimeError, ClusterServiceGetQueryParams, ClusterServiceGetPathParams>,
  'path'
> &
  ClusterServiceGetPathParams

/**
 * Get returns a cluster by server address
 */
export const useClusterServiceGet = ({ agentIdentifier, queryServer, ...props }: UseClusterServiceGetProps) =>
  useGet<V1alpha1Cluster, GatewayruntimeError, ClusterServiceGetQueryParams, ClusterServiceGetPathParams>(
    (paramsInPath: ClusterServiceGetPathParams) =>
      `/api/v1/agents/${paramsInPath.agentIdentifier}/clusters/${paramsInPath.queryServer}`,
    { base: getConfig('gitops-api'), pathParams: { agentIdentifier, queryServer }, ...props }
  )

export interface ClusterServiceUpdatePathParams {
  agentIdentifier: string
  /**
   * Server is the API server URL of the Kubernetes cluster
   */
  requestClusterServer: string
}

export type ClusterServiceUpdateProps = Omit<
  MutateProps<V1alpha1Cluster, GatewayruntimeError, void, ClusterClusterUpdateRequest, ClusterServiceUpdatePathParams>,
  'path' | 'verb'
> &
  ClusterServiceUpdatePathParams

/**
 * Update updates a cluster
 */
export const ClusterServiceUpdate = ({
  agentIdentifier,
  requestClusterServer,
  ...props
}: ClusterServiceUpdateProps) => (
  <Mutate<V1alpha1Cluster, GatewayruntimeError, void, ClusterClusterUpdateRequest, ClusterServiceUpdatePathParams>
    verb="PUT"
    path={`/api/v1/agents/${agentIdentifier}/clusters/${requestClusterServer}`}
    base={getConfig('gitops-api')}
    {...props}
  />
)

export type UseClusterServiceUpdateProps = Omit<
  UseMutateProps<
    V1alpha1Cluster,
    GatewayruntimeError,
    void,
    ClusterClusterUpdateRequest,
    ClusterServiceUpdatePathParams
  >,
  'path' | 'verb'
> &
  ClusterServiceUpdatePathParams

/**
 * Update updates a cluster
 */
export const useClusterServiceUpdate = ({
  agentIdentifier,
  requestClusterServer,
  ...props
}: UseClusterServiceUpdateProps) =>
  useMutate<V1alpha1Cluster, GatewayruntimeError, void, ClusterClusterUpdateRequest, ClusterServiceUpdatePathParams>(
    'PUT',
    (paramsInPath: ClusterServiceUpdatePathParams) =>
      `/api/v1/agents/${paramsInPath.agentIdentifier}/clusters/${paramsInPath.requestClusterServer}`,
    { base: getConfig('gitops-api'), pathParams: { agentIdentifier, requestClusterServer }, ...props }
  )

export interface ProjectServiceListQueryParams {
  'query.name'?: string
}

export interface ProjectServiceListPathParams {
  agentIdentifier: string
}

export type ProjectServiceListProps = Omit<
  GetProps<V1alpha1AppProjectList, GatewayruntimeError, ProjectServiceListQueryParams, ProjectServiceListPathParams>,
  'path'
> &
  ProjectServiceListPathParams

/**
 * List returns list of projects
 */
export const ProjectServiceList = ({ agentIdentifier, ...props }: ProjectServiceListProps) => (
  <Get<V1alpha1AppProjectList, GatewayruntimeError, ProjectServiceListQueryParams, ProjectServiceListPathParams>
    path={`/api/v1/agents/${agentIdentifier}/projects`}
    base={getConfig('gitops-api')}
    {...props}
  />
)

export type UseProjectServiceListProps = Omit<
  UseGetProps<V1alpha1AppProjectList, GatewayruntimeError, ProjectServiceListQueryParams, ProjectServiceListPathParams>,
  'path'
> &
  ProjectServiceListPathParams

/**
 * List returns list of projects
 */
export const useProjectServiceList = ({ agentIdentifier, ...props }: UseProjectServiceListProps) =>
  useGet<V1alpha1AppProjectList, GatewayruntimeError, ProjectServiceListQueryParams, ProjectServiceListPathParams>(
    (paramsInPath: ProjectServiceListPathParams) => `/api/v1/agents/${paramsInPath.agentIdentifier}/projects`,
    { base: getConfig('gitops-api'), pathParams: { agentIdentifier }, ...props }
  )

export interface ProjectServiceCreatePathParams {
  agentIdentifier: string
}

export type ProjectServiceCreateProps = Omit<
  MutateProps<
    V1alpha1AppProject,
    GatewayruntimeError,
    void,
    ProjectProjectCreateRequest,
    ProjectServiceCreatePathParams
  >,
  'path' | 'verb'
> &
  ProjectServiceCreatePathParams

/**
 * Create a new project
 */
export const ProjectServiceCreate = ({ agentIdentifier, ...props }: ProjectServiceCreateProps) => (
  <Mutate<V1alpha1AppProject, GatewayruntimeError, void, ProjectProjectCreateRequest, ProjectServiceCreatePathParams>
    verb="POST"
    path={`/api/v1/agents/${agentIdentifier}/projects`}
    base={getConfig('gitops-api')}
    {...props}
  />
)

export type UseProjectServiceCreateProps = Omit<
  UseMutateProps<
    V1alpha1AppProject,
    GatewayruntimeError,
    void,
    ProjectProjectCreateRequest,
    ProjectServiceCreatePathParams
  >,
  'path' | 'verb'
> &
  ProjectServiceCreatePathParams

/**
 * Create a new project
 */
export const useProjectServiceCreate = ({ agentIdentifier, ...props }: UseProjectServiceCreateProps) =>
  useMutate<V1alpha1AppProject, GatewayruntimeError, void, ProjectProjectCreateRequest, ProjectServiceCreatePathParams>(
    'POST',
    (paramsInPath: ProjectServiceCreatePathParams) => `/api/v1/agents/${paramsInPath.agentIdentifier}/projects`,
    { base: getConfig('gitops-api'), pathParams: { agentIdentifier }, ...props }
  )

export interface ProjectServiceDeletePathParams {
  agentIdentifier: string
}

export type ProjectServiceDeleteProps = Omit<
  MutateProps<ProjectEmptyResponse, GatewayruntimeError, void, string, ProjectServiceDeletePathParams>,
  'path' | 'verb'
> &
  ProjectServiceDeletePathParams

/**
 * Delete deletes a project
 */
export const ProjectServiceDelete = ({ agentIdentifier, ...props }: ProjectServiceDeleteProps) => (
  <Mutate<ProjectEmptyResponse, GatewayruntimeError, void, string, ProjectServiceDeletePathParams>
    verb="DELETE"
    path={`/api/v1/agents/${agentIdentifier}/projects`}
    base={getConfig('gitops-api')}
    {...props}
  />
)

export type UseProjectServiceDeleteProps = Omit<
  UseMutateProps<ProjectEmptyResponse, GatewayruntimeError, void, string, ProjectServiceDeletePathParams>,
  'path' | 'verb'
> &
  ProjectServiceDeletePathParams

/**
 * Delete deletes a project
 */
export const useProjectServiceDelete = ({ agentIdentifier, ...props }: UseProjectServiceDeleteProps) =>
  useMutate<ProjectEmptyResponse, GatewayruntimeError, void, string, ProjectServiceDeletePathParams>(
    'DELETE',
    (paramsInPath: ProjectServiceDeletePathParams) => `/api/v1/agents/${paramsInPath.agentIdentifier}/projects`,
    { base: getConfig('gitops-api'), pathParams: { agentIdentifier }, ...props }
  )

export interface ProjectServiceGetPathParams {
  agentIdentifier: string
  queryName: string
}

export type ProjectServiceGetProps = Omit<
  GetProps<V1alpha1AppProject, GatewayruntimeError, void, ProjectServiceGetPathParams>,
  'path'
> &
  ProjectServiceGetPathParams

/**
 * Get returns a project by name
 */
export const ProjectServiceGet = ({ agentIdentifier, queryName, ...props }: ProjectServiceGetProps) => (
  <Get<V1alpha1AppProject, GatewayruntimeError, void, ProjectServiceGetPathParams>
    path={`/api/v1/agents/${agentIdentifier}/projects/${queryName}`}
    base={getConfig('gitops-api')}
    {...props}
  />
)

export type UseProjectServiceGetProps = Omit<
  UseGetProps<V1alpha1AppProject, GatewayruntimeError, void, ProjectServiceGetPathParams>,
  'path'
> &
  ProjectServiceGetPathParams

/**
 * Get returns a project by name
 */
export const useProjectServiceGet = ({ agentIdentifier, queryName, ...props }: UseProjectServiceGetProps) =>
  useGet<V1alpha1AppProject, GatewayruntimeError, void, ProjectServiceGetPathParams>(
    (paramsInPath: ProjectServiceGetPathParams) =>
      `/api/v1/agents/${paramsInPath.agentIdentifier}/projects/${paramsInPath.queryName}`,
    { base: getConfig('gitops-api'), pathParams: { agentIdentifier, queryName }, ...props }
  )

export interface ProjectServiceUpdatePathParams {
  agentIdentifier: string
  /**
   * Name must be unique within a namespace. Is required when creating resources, although
   * some resources may allow a client to request the generation of an appropriate name
   * automatically. Name is primarily intended for creation idempotence and configuration
   * definition.
   * Cannot be updated.
   * More info: http://kubernetes.io/docs/user-guide/identifiers#names
   * +optional
   */
  requestProjectMetadataName: string
}

export type ProjectServiceUpdateProps = Omit<
  MutateProps<
    V1alpha1AppProject,
    GatewayruntimeError,
    void,
    ProjectProjectUpdateRequest,
    ProjectServiceUpdatePathParams
  >,
  'path' | 'verb'
> &
  ProjectServiceUpdatePathParams

/**
 * Update updates a project
 */
export const ProjectServiceUpdate = ({
  agentIdentifier,
  requestProjectMetadataName,
  ...props
}: ProjectServiceUpdateProps) => (
  <Mutate<V1alpha1AppProject, GatewayruntimeError, void, ProjectProjectUpdateRequest, ProjectServiceUpdatePathParams>
    verb="PUT"
    path={`/api/v1/agents/${agentIdentifier}/projects/${requestProjectMetadataName}`}
    base={getConfig('gitops-api')}
    {...props}
  />
)

export type UseProjectServiceUpdateProps = Omit<
  UseMutateProps<
    V1alpha1AppProject,
    GatewayruntimeError,
    void,
    ProjectProjectUpdateRequest,
    ProjectServiceUpdatePathParams
  >,
  'path' | 'verb'
> &
  ProjectServiceUpdatePathParams

/**
 * Update updates a project
 */
export const useProjectServiceUpdate = ({
  agentIdentifier,
  requestProjectMetadataName,
  ...props
}: UseProjectServiceUpdateProps) =>
  useMutate<V1alpha1AppProject, GatewayruntimeError, void, ProjectProjectUpdateRequest, ProjectServiceUpdatePathParams>(
    'PUT',
    (paramsInPath: ProjectServiceUpdatePathParams) =>
      `/api/v1/agents/${paramsInPath.agentIdentifier}/projects/${paramsInPath.requestProjectMetadataName}`,
    { base: getConfig('gitops-api'), pathParams: { agentIdentifier, requestProjectMetadataName }, ...props }
  )

export interface RepositoryServiceListRepositoriesQueryParams {
  /**
   * Repo URL for query.
   */
  'query.repo'?: string
  /**
   * Whether to force a cache refresh on repo's connection state.
   */
  'query.forceRefresh'?: boolean
}

export interface RepositoryServiceListRepositoriesPathParams {
  agentIdentifier: string
}

export type RepositoryServiceListRepositoriesProps = Omit<
  GetProps<
    V1alpha1RepositoryList,
    GatewayruntimeError,
    RepositoryServiceListRepositoriesQueryParams,
    RepositoryServiceListRepositoriesPathParams
  >,
  'path'
> &
  RepositoryServiceListRepositoriesPathParams

/**
 * ListRepositories gets a list of all configured repositories
 */
export const RepositoryServiceListRepositories = ({
  agentIdentifier,
  ...props
}: RepositoryServiceListRepositoriesProps) => (
  <Get<
    V1alpha1RepositoryList,
    GatewayruntimeError,
    RepositoryServiceListRepositoriesQueryParams,
    RepositoryServiceListRepositoriesPathParams
  >
    path={`/api/v1/agents/${agentIdentifier}/repositories`}
    base={getConfig('gitops-api')}
    {...props}
  />
)

export type UseRepositoryServiceListRepositoriesProps = Omit<
  UseGetProps<
    V1alpha1RepositoryList,
    GatewayruntimeError,
    RepositoryServiceListRepositoriesQueryParams,
    RepositoryServiceListRepositoriesPathParams
  >,
  'path'
> &
  RepositoryServiceListRepositoriesPathParams

/**
 * ListRepositories gets a list of all configured repositories
 */
export const useRepositoryServiceListRepositories = ({
  agentIdentifier,
  ...props
}: UseRepositoryServiceListRepositoriesProps) =>
  useGet<
    V1alpha1RepositoryList,
    GatewayruntimeError,
    RepositoryServiceListRepositoriesQueryParams,
    RepositoryServiceListRepositoriesPathParams
  >(
    (paramsInPath: RepositoryServiceListRepositoriesPathParams) =>
      `/api/v1/agents/${paramsInPath.agentIdentifier}/repositories`,
    { base: getConfig('gitops-api'), pathParams: { agentIdentifier }, ...props }
  )

export interface RepositoryServiceCreateRepositoryPathParams {
  agentIdentifier: string
}

export type RepositoryServiceCreateRepositoryProps = Omit<
  MutateProps<
    V1alpha1Repository,
    GatewayruntimeError,
    void,
    RepositoryRepoCreateRequest,
    RepositoryServiceCreateRepositoryPathParams
  >,
  'path' | 'verb'
> &
  RepositoryServiceCreateRepositoryPathParams

/**
 * CreateRepository creates a new repository configuration
 */
export const RepositoryServiceCreateRepository = ({
  agentIdentifier,
  ...props
}: RepositoryServiceCreateRepositoryProps) => (
  <Mutate<
    V1alpha1Repository,
    GatewayruntimeError,
    void,
    RepositoryRepoCreateRequest,
    RepositoryServiceCreateRepositoryPathParams
  >
    verb="POST"
    path={`/api/v1/agents/${agentIdentifier}/repositories`}
    base={getConfig('gitops-api')}
    {...props}
  />
)

export type UseRepositoryServiceCreateRepositoryProps = Omit<
  UseMutateProps<
    V1alpha1Repository,
    GatewayruntimeError,
    void,
    RepositoryRepoCreateRequest,
    RepositoryServiceCreateRepositoryPathParams
  >,
  'path' | 'verb'
> &
  RepositoryServiceCreateRepositoryPathParams

/**
 * CreateRepository creates a new repository configuration
 */
export const useRepositoryServiceCreateRepository = ({
  agentIdentifier,
  ...props
}: UseRepositoryServiceCreateRepositoryProps) =>
  useMutate<
    V1alpha1Repository,
    GatewayruntimeError,
    void,
    RepositoryRepoCreateRequest,
    RepositoryServiceCreateRepositoryPathParams
  >(
    'POST',
    (paramsInPath: RepositoryServiceCreateRepositoryPathParams) =>
      `/api/v1/agents/${paramsInPath.agentIdentifier}/repositories`,
    { base: getConfig('gitops-api'), pathParams: { agentIdentifier }, ...props }
  )

export interface RepositoryServiceDeleteRepositoryQueryParams {
  /**
   * Whether to force a cache refresh on repo's connection state.
   */
  'query.forceRefresh'?: boolean
}

export interface RepositoryServiceDeleteRepositoryPathParams {
  agentIdentifier: string
}

export type RepositoryServiceDeleteRepositoryProps = Omit<
  MutateProps<
    RepositoryRepoResponse,
    GatewayruntimeError,
    RepositoryServiceDeleteRepositoryQueryParams,
    string,
    RepositoryServiceDeleteRepositoryPathParams
  >,
  'path' | 'verb'
> &
  RepositoryServiceDeleteRepositoryPathParams

/**
 * DeleteRepository deletes a repository from the configuration
 */
export const RepositoryServiceDeleteRepository = ({
  agentIdentifier,
  ...props
}: RepositoryServiceDeleteRepositoryProps) => (
  <Mutate<
    RepositoryRepoResponse,
    GatewayruntimeError,
    RepositoryServiceDeleteRepositoryQueryParams,
    string,
    RepositoryServiceDeleteRepositoryPathParams
  >
    verb="DELETE"
    path={`/api/v1/agents/${agentIdentifier}/repositories`}
    base={getConfig('gitops-api')}
    {...props}
  />
)

export type UseRepositoryServiceDeleteRepositoryProps = Omit<
  UseMutateProps<
    RepositoryRepoResponse,
    GatewayruntimeError,
    RepositoryServiceDeleteRepositoryQueryParams,
    string,
    RepositoryServiceDeleteRepositoryPathParams
  >,
  'path' | 'verb'
> &
  RepositoryServiceDeleteRepositoryPathParams

/**
 * DeleteRepository deletes a repository from the configuration
 */
export const useRepositoryServiceDeleteRepository = ({
  agentIdentifier,
  ...props
}: UseRepositoryServiceDeleteRepositoryProps) =>
  useMutate<
    RepositoryRepoResponse,
    GatewayruntimeError,
    RepositoryServiceDeleteRepositoryQueryParams,
    string,
    RepositoryServiceDeleteRepositoryPathParams
  >(
    'DELETE',
    (paramsInPath: RepositoryServiceDeleteRepositoryPathParams) =>
      `/api/v1/agents/${paramsInPath.agentIdentifier}/repositories`,
    { base: getConfig('gitops-api'), pathParams: { agentIdentifier }, ...props }
  )

export interface RepositoryServiceGetQueryParams {
  /**
   * Whether to force a cache refresh on repo's connection state.
   */
  'query.forceRefresh'?: boolean
}

export interface RepositoryServiceGetPathParams {
  agentIdentifier: string
  /**
   * Repo URL for query
   */
  queryRepo: string
}

export type RepositoryServiceGetProps = Omit<
  GetProps<V1alpha1Repository, GatewayruntimeError, RepositoryServiceGetQueryParams, RepositoryServiceGetPathParams>,
  'path'
> &
  RepositoryServiceGetPathParams

/**
 * Get returns a repository or its credentials
 */
export const RepositoryServiceGet = ({ agentIdentifier, queryRepo, ...props }: RepositoryServiceGetProps) => (
  <Get<V1alpha1Repository, GatewayruntimeError, RepositoryServiceGetQueryParams, RepositoryServiceGetPathParams>
    path={`/api/v1/agents/${agentIdentifier}/repositories/${queryRepo}`}
    base={getConfig('gitops-api')}
    {...props}
  />
)

export type UseRepositoryServiceGetProps = Omit<
  UseGetProps<V1alpha1Repository, GatewayruntimeError, RepositoryServiceGetQueryParams, RepositoryServiceGetPathParams>,
  'path'
> &
  RepositoryServiceGetPathParams

/**
 * Get returns a repository or its credentials
 */
export const useRepositoryServiceGet = ({ agentIdentifier, queryRepo, ...props }: UseRepositoryServiceGetProps) =>
  useGet<V1alpha1Repository, GatewayruntimeError, RepositoryServiceGetQueryParams, RepositoryServiceGetPathParams>(
    (paramsInPath: RepositoryServiceGetPathParams) =>
      `/api/v1/agents/${paramsInPath.agentIdentifier}/repositories/${paramsInPath.queryRepo}`,
    { base: getConfig('gitops-api'), pathParams: { agentIdentifier, queryRepo }, ...props }
  )

export interface RepositoryServiceUpdateRepositoryPathParams {
  agentIdentifier: string
  /**
   * Repo contains the URL to the remote repository
   */
  requestRepoRepo: string
}

export type RepositoryServiceUpdateRepositoryProps = Omit<
  MutateProps<
    V1alpha1Repository,
    GatewayruntimeError,
    void,
    RepositoryRepoUpdateRequest,
    RepositoryServiceUpdateRepositoryPathParams
  >,
  'path' | 'verb'
> &
  RepositoryServiceUpdateRepositoryPathParams

/**
 * UpdateRepository updates a repository configuration
 */
export const RepositoryServiceUpdateRepository = ({
  agentIdentifier,
  requestRepoRepo,
  ...props
}: RepositoryServiceUpdateRepositoryProps) => (
  <Mutate<
    V1alpha1Repository,
    GatewayruntimeError,
    void,
    RepositoryRepoUpdateRequest,
    RepositoryServiceUpdateRepositoryPathParams
  >
    verb="PUT"
    path={`/api/v1/agents/${agentIdentifier}/repositories/${requestRepoRepo}`}
    base={getConfig('gitops-api')}
    {...props}
  />
)

export type UseRepositoryServiceUpdateRepositoryProps = Omit<
  UseMutateProps<
    V1alpha1Repository,
    GatewayruntimeError,
    void,
    RepositoryRepoUpdateRequest,
    RepositoryServiceUpdateRepositoryPathParams
  >,
  'path' | 'verb'
> &
  RepositoryServiceUpdateRepositoryPathParams

/**
 * UpdateRepository updates a repository configuration
 */
export const useRepositoryServiceUpdateRepository = ({
  agentIdentifier,
  requestRepoRepo,
  ...props
}: UseRepositoryServiceUpdateRepositoryProps) =>
  useMutate<
    V1alpha1Repository,
    GatewayruntimeError,
    void,
    RepositoryRepoUpdateRequest,
    RepositoryServiceUpdateRepositoryPathParams
  >(
    'PUT',
    (paramsInPath: RepositoryServiceUpdateRepositoryPathParams) =>
      `/api/v1/agents/${paramsInPath.agentIdentifier}/repositories/${paramsInPath.requestRepoRepo}`,
    { base: getConfig('gitops-api'), pathParams: { agentIdentifier, requestRepoRepo }, ...props }
  )

export interface AgentTaskServiceGetTasksQueryParams {
  identifier?: string
}

export interface AgentTaskServiceGetTasksPathParams {
  agentIdentifier: string
}

export type AgentTaskServiceGetTasksProps = Omit<
  GetProps<V1TaskList, GatewayruntimeError, AgentTaskServiceGetTasksQueryParams, AgentTaskServiceGetTasksPathParams>,
  'path'
> &
  AgentTaskServiceGetTasksPathParams

export const AgentTaskServiceGetTasks = ({ agentIdentifier, ...props }: AgentTaskServiceGetTasksProps) => (
  <Get<V1TaskList, GatewayruntimeError, AgentTaskServiceGetTasksQueryParams, AgentTaskServiceGetTasksPathParams>
    path={`/api/v1/agents/${agentIdentifier}/tasks`}
    base={getConfig('gitops-api')}
    {...props}
  />
)

export type UseAgentTaskServiceGetTasksProps = Omit<
  UseGetProps<V1TaskList, GatewayruntimeError, AgentTaskServiceGetTasksQueryParams, AgentTaskServiceGetTasksPathParams>,
  'path'
> &
  AgentTaskServiceGetTasksPathParams

export const useAgentTaskServiceGetTasks = ({ agentIdentifier, ...props }: UseAgentTaskServiceGetTasksProps) =>
  useGet<V1TaskList, GatewayruntimeError, AgentTaskServiceGetTasksQueryParams, AgentTaskServiceGetTasksPathParams>(
    (paramsInPath: AgentTaskServiceGetTasksPathParams) => `/api/v1/agents/${paramsInPath.agentIdentifier}/tasks`,
    { base: getConfig('gitops-api'), pathParams: { agentIdentifier }, ...props }
  )

export interface AgentServiceDeleteQueryParams {
  accountIdentifier?: string
  projectIdentifier?: string
  orgIdentifier?: string
  name?: string
  type?: 'CONNECTED_ARGO_PROVIDER' | 'MANAGED_ARGO_PROVIDER'
  tags?: string[]
}

export type AgentServiceDeleteProps = Omit<
  MutateProps<V1Agent, GatewayruntimeError, AgentServiceDeleteQueryParams, string, void>,
  'path' | 'verb'
>

export const AgentServiceDelete = (props: AgentServiceDeleteProps) => (
  <Mutate<V1Agent, GatewayruntimeError, AgentServiceDeleteQueryParams, string, void>
    verb="DELETE"
    path={`/api/v1/agents`}
    base={getConfig('gitops-api')}
    {...props}
  />
)

export type UseAgentServiceDeleteProps = Omit<
  UseMutateProps<V1Agent, GatewayruntimeError, AgentServiceDeleteQueryParams, string, void>,
  'path' | 'verb'
>

export const useAgentServiceDelete = (props: UseAgentServiceDeleteProps) =>
  useMutate<V1Agent, GatewayruntimeError, AgentServiceDeleteQueryParams, string, void>('DELETE', `/api/v1/agents`, {
    base: getConfig('gitops-api'),
    ...props
  })

export interface AgentServiceGetQueryParams {
  accountIdentifier?: string
  projectIdentifier?: string
  orgIdentifier?: string
  name?: string
  type?: 'CONNECTED_ARGO_PROVIDER' | 'MANAGED_ARGO_PROVIDER'
  tags?: string[]
}

export interface AgentServiceGetPathParams {
  identifier: string
}

export type AgentServiceGetProps = Omit<
  GetProps<V1Agent, GatewayruntimeError, AgentServiceGetQueryParams, AgentServiceGetPathParams>,
  'path'
> &
  AgentServiceGetPathParams

export const AgentServiceGet = ({ identifier, ...props }: AgentServiceGetProps) => (
  <Get<V1Agent, GatewayruntimeError, AgentServiceGetQueryParams, AgentServiceGetPathParams>
    path={`/api/v1/agents/${identifier}`}
    base={getConfig('gitops-api')}
    {...props}
  />
)

export type UseAgentServiceGetProps = Omit<
  UseGetProps<V1Agent, GatewayruntimeError, AgentServiceGetQueryParams, AgentServiceGetPathParams>,
  'path'
> &
  AgentServiceGetPathParams

export const useAgentServiceGet = ({ identifier, ...props }: UseAgentServiceGetProps) =>
  useGet<V1Agent, GatewayruntimeError, AgentServiceGetQueryParams, AgentServiceGetPathParams>(
    (paramsInPath: AgentServiceGetPathParams) => `/api/v1/agents/${paramsInPath.identifier}`,
    { base: getConfig('gitops-api'), pathParams: { identifier }, ...props }
  )
